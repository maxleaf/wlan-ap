From ac589a9d86a85c1e715a4a1a52a6022bbc98de64 Mon Sep 17 00:00:00 2001
From: P Praneesh <quic_ppranees@quicinc.com>
Date: Fri, 22 Jul 2022 13:39:00 +0530
Subject: [PATCH] ath12k: Update HTT ppdu stats from the firmware descriptor

Current implementation updates success frame in the station specific
stats whenever driver receives USR_COMPLTN_ACK_BA_STATUS. But
firmware provides either USR_COMPLTN_ACK_BA_STATUS or SCH_CMD_STATUS
to indicate particular frame for the peer is successfully transmitted.
Add  SCH_CMD_STATUS HTT TLV tag handling while processing ppdu
descriptors.

Firmware can provide user rate specific information as an ordinary
rate information or response type rate information. If the flag
HTT_PPDU_STATS_USER_RATE_INFO1_RESP_TYPE_VALID then driver should
parse the response type rate information.  Since driver process only
ordinary rate information, less amount of success packet count
updated in the peer sepcific statistics. Add support to parse the
response type rate information.

Signed-off-by: P Praneesh <quic_ppranees@quicinc.com>
---
 .../net/wireless/ath/ath12k/debugfs_htt_stats.h    |  19 ++++
 drivers/net/wireless/ath/ath12k/dp.h               |  14 ++-
 drivers/net/wireless/ath/ath12k/dp_rx.c            | 126 ++++++++++++++++-----
 3 files changed, 131 insertions(+), 28 deletions(-)

--- a/drivers/net/wireless/ath/ath12k/debugfs_htt_stats.h
+++ b/drivers/net/wireless/ath/ath12k/debugfs_htt_stats.h
@@ -180,6 +180,25 @@ enum htt_tx_pdev_underrun_enum {
 	HTT_TX_PDEV_MAX_URRN_STATS                   = 3,
 };
 
+enum htt_ppdu_stats_ru_size {
+	HTT_PPDU_STATS_RU_26,
+	HTT_PPDU_STATS_RU_52,
+	HTT_PPDU_STATS_RU_52_26,
+	HTT_PPDU_STATS_RU_106,
+	HTT_PPDU_STATS_RU_106_26,
+	HTT_PPDU_STATS_RU_242,
+	HTT_PPDU_STATS_RU_484,
+	HTT_PPDU_STATS_RU_484_242,
+	HTT_PPDU_STATS_RU_996,
+	HTT_PPDU_STATS_RU_996_484,
+	HTT_PPDU_STATS_RU_996_484_242,
+	HTT_PPDU_STATS_RU_996x2,
+	HTT_PPDU_STATS_RU_996x2_484,
+	HTT_PPDU_STATS_RU_996x3,
+	HTT_PPDU_STATS_RU_996x3_484,
+	HTT_PPDU_STATS_RU_996x4,
+};
+
 #define HTT_TX_PDEV_MAX_FLUSH_REASON_STATS     71
 #define HTT_TX_PDEV_MAX_SIFS_BURST_STATS       9
 #define HTT_TX_PDEV_MAX_SIFS_BURST_HIST_STATS  10
--- a/drivers/net/wireless/ath/ath12k/dp.h
+++ b/drivers/net/wireless/ath/ath12k/dp.h
@@ -1519,6 +1519,7 @@ enum htt_ppdu_stats_gi {
 
 #define HTT_PPDU_STATS_USER_RATE_INFO0_USER_POS_M	GENMASK(3, 0)
 #define HTT_PPDU_STATS_USER_RATE_INFO0_MU_GROUP_ID_M	GENMASK(11, 4)
+#define HTT_PPDU_STATS_USER_RATE_INFO0_RU_SIZE		GENMASK(15, 12)
 
 enum HTT_PPDU_STATS_PPDU_TYPE {
 	HTT_PPDU_STATS_PPDU_TYPE_SU,
@@ -1533,7 +1534,12 @@ enum HTT_PPDU_STATS_PPDU_TYPE {
 	HTT_PPDU_STATS_PPDU_TYPE_MAX
 };
 
-#define HTT_PPDU_STATS_USER_RATE_INFO1_RESP_TYPE_VALD_M	BIT(0)
+enum HTT_PPDU_STATS_RESP_PPDU_TYPE {
+	HTT_PPDU_STATS_RESP_PPDU_TYPE_MU_MIMO_UL,
+	HTT_PPDU_STATS_RESP_PPDU_TYPE_MU_OFDMA_UL,
+};
+
+#define HTT_PPDU_STATS_USER_RATE_INFO1_RESP_TYPE_VALID	BIT(0)
 #define HTT_PPDU_STATS_USER_RATE_INFO1_PPDU_TYPE_M	GENMASK(5, 1)
 
 #define HTT_PPDU_STATS_USER_RATE_FLAGS_LTF_SIZE_M	GENMASK(1, 0)
@@ -1574,6 +1580,10 @@ enum HTT_PPDU_STATS_PPDU_TYPE {
 #define HTT_PPDU_STATS_USER_RATE_RESP_FLAGS_GI_M		GENMASK(27, 24)
 #define HTT_PPDU_STATS_USER_RATE_RESP_FLAGS_DCM_M		BIT(28)
 #define HTT_PPDU_STATS_USER_RATE_RESP_FLAGS_LDPC_M		BIT(29)
+#define HTT_PPDU_STATS_USER_RATE_RESP_FLAGS_PPDU_TYPE		GENMASK(31, 30)
+
+#define HTT_USR_RESP_RATE_PPDU_TYPE(_val) \
+	u32_get_bits(_val, HTT_PPDU_STATS_USER_RATE_RESP_FLAGS_PPDU_TYPE)
 
 struct htt_ppdu_stats_user_rate {
 	u8 tid_num;
@@ -1588,6 +1598,8 @@ struct htt_ppdu_stats_user_rate {
 	u32 rate_flags; /* %HTT_PPDU_STATS_USER_RATE_FLAGS_ */
 	/* Note: resp_rate_info is only valid for if resp_type is UL */
 	u32 resp_rate_flags; /* %HTT_PPDU_STATS_USER_RATE_RESP_FLAGS_ */
+	u16 punctured;
+	u16 reserved1;
 } __packed;
 
 #define HTT_PPDU_STATS_TX_INFO_FLAGS_RATECODE_M		GENMASK(7, 0)
--- a/drivers/net/wireless/ath/ath12k/dp_rx.c
+++ b/drivers/net/wireless/ath/ath12k/dp_rx.c
@@ -1206,7 +1206,7 @@ static int ath12k_htt_tlv_ppdu_stats_par
 		user_stats->is_valid_peer_id = true;
 		memcpy((void *)&user_stats->rate, ptr,
 		       sizeof(struct htt_ppdu_stats_user_rate));
-		user_stats->tlv_flags |= BIT(tag);
+		ppdu_info->tlv_bitmap |= BIT(tag);
 		break;
 	case HTT_PPDU_STATS_TAG_USR_COMPLTN_COMMON:
 		if (len < sizeof(struct htt_ppdu_stats_usr_cmpltn_cmn)) {
@@ -1225,7 +1225,7 @@ static int ath12k_htt_tlv_ppdu_stats_par
 		user_stats->is_valid_peer_id = true;
 		memcpy((void *)&user_stats->cmpltn_cmn, ptr,
 		       sizeof(struct htt_ppdu_stats_usr_cmpltn_cmn));
-		user_stats->tlv_flags |= BIT(tag);
+		ppdu_info->tlv_bitmap |= BIT(tag);
 		break;
 	case HTT_PPDU_STATS_TAG_USR_COMPLTN_ACK_BA_STATUS:
 		if (len <
@@ -1246,7 +1246,10 @@ static int ath12k_htt_tlv_ppdu_stats_par
 		user_stats->is_valid_peer_id = true;
 		memcpy((void *)&user_stats->ack_ba, ptr,
 		       sizeof(struct htt_ppdu_stats_usr_cmpltn_ack_ba_status));
-		user_stats->tlv_flags |= BIT(tag);
+		ppdu_info->tlv_bitmap |= BIT(tag);
+		break;
+	case HTT_PPDU_STATS_TAG_SCH_CMD_STATUS:
+		ppdu_info->tlv_bitmap |= BIT(tag);
 		break;
 	}
 	return 0;
@@ -1257,11 +1260,17 @@ int ath12k_dp_htt_tlv_iter(struct ath12k
 				       const void *ptr, void *data),
 			   void *data)
 {
+	struct htt_ppdu_stats_info *ppdu_info = NULL;
 	const struct htt_tlv *tlv;
 	const void *begin = ptr;
 	u16 tlv_tag, tlv_len;
 	int ret = -EINVAL;
 
+	if (!data)
+		return ret;
+
+	ppdu_info = (struct htt_ppdu_stats_info *)data;
+
 	while (len > 0) {
 		if (len < sizeof(*tlv)) {
 			ath12k_err(ab, "htt tlv parse failure at byte %zd (%zu bytes left, %zu expected)\n",
@@ -1279,7 +1288,7 @@ int ath12k_dp_htt_tlv_iter(struct ath12k
 				   tlv_tag, ptr - begin, len, tlv_len);
 			return -EINVAL;
 		}
-		ret = iter(ab, tlv_tag, tlv_len, ptr, data);
+		ret = iter(ab, tlv_tag, tlv_len, ptr, ppdu_info);
 		if (ret == -ENOMEM)
 			return ret;
 
@@ -1289,38 +1298,76 @@ int ath12k_dp_htt_tlv_iter(struct ath12k
 	return 0;
 }
 
+static u32 ath12k_dp_rx_ru_alloc_from_ru_size(u16 ru_size)
+{
+	u32 width = 0;
+
+	switch (ru_size) {
+	case HTT_PPDU_STATS_RU_26:
+		width = NL80211_RATE_INFO_HE_RU_ALLOC_26;
+		break;
+	case HTT_PPDU_STATS_RU_52:
+		width = NL80211_RATE_INFO_HE_RU_ALLOC_52;
+		break;
+	case HTT_PPDU_STATS_RU_106:
+		width = NL80211_RATE_INFO_HE_RU_ALLOC_106;
+		break;
+	case HTT_PPDU_STATS_RU_242:
+		width = NL80211_RATE_INFO_HE_RU_ALLOC_242;
+		break;
+	case HTT_PPDU_STATS_RU_484:
+		width = NL80211_RATE_INFO_HE_RU_ALLOC_484;
+		break;
+	case HTT_PPDU_STATS_RU_996:
+		width = NL80211_RATE_INFO_HE_RU_ALLOC_996;
+		break;
+	default:
+		width = NL80211_RATE_INFO_HE_RU_ALLOC_26;
+		break;
+	}
+
+	return width;
+}
+
 static void
 ath12k_update_per_peer_tx_stats(struct ath12k *ar,
-				struct htt_ppdu_stats *ppdu_stats, u8 user)
+				struct htt_ppdu_stats_info *ppdu_info, u8 user)
 {
 	struct ath12k_base *ab = ar->ab;
 	struct ath12k_peer *peer;
 	struct ieee80211_sta *sta;
 	struct ath12k_sta *arsta;
 	struct htt_ppdu_stats_user_rate *user_rate;
+	struct htt_ppdu_stats *ppdu_stats = &ppdu_info->ppdu_stats;
 	struct ath12k_per_peer_tx_stats *peer_stats = &ar->peer_tx_stats;
 	struct htt_ppdu_user_stats *usr_stats = &ppdu_stats->user_stats[user];
 	struct htt_ppdu_stats_common *common = &ppdu_stats->common;
 	int ret;
 	u8 flags, mcs, nss, bw, sgi, dcm, rate_idx = 0;
 	u32 succ_bytes = 0, ppdu_type;
-	u16 rate = 0, succ_pkts = 0;
-	u32 tx_duration = 0;
+	u16 rate = 0, succ_pkts = 0, ru_start, ru_end;
+	u32 tx_duration = 0, ru_tones, ru_format, tlv_bitmap, rate_flags;
 	u8 tid = HTT_PPDU_STATS_NON_QOS_TID;
-	bool is_ampdu = false;
+	bool is_ampdu = false, resp_type_valid;
 
 	if (!usr_stats)
 		return;
 
-	if (!(usr_stats->tlv_flags & BIT(HTT_PPDU_STATS_TAG_USR_RATE)))
+	tlv_bitmap = ppdu_info->tlv_bitmap;
+
+	if (!(tlv_bitmap & BIT(HTT_PPDU_STATS_TAG_USR_RATE)))
 		return;
 
-	if (usr_stats->tlv_flags & BIT(HTT_PPDU_STATS_TAG_USR_COMPLTN_COMMON))
+	if (tlv_bitmap & BIT(HTT_PPDU_STATS_TAG_USR_COMPLTN_COMMON)) {
 		is_ampdu =
 			HTT_USR_CMPLTN_IS_AMPDU(usr_stats->cmpltn_cmn.flags);
+		if (tlv_bitmap & BIT(HTT_PPDU_STATS_TAG_SCH_CMD_STATUS)) {
+			succ_pkts = usr_stats->cmpltn_cmn.mpdu_success;
+			tid = usr_stats->cmpltn_cmn.tid_num;
+		}
+	}
 
-	if (usr_stats->tlv_flags &
-	    BIT(HTT_PPDU_STATS_TAG_USR_COMPLTN_ACK_BA_STATUS)) {
+	if (tlv_bitmap & BIT(HTT_PPDU_STATS_TAG_USR_COMPLTN_ACK_BA_STATUS)) {
 		succ_bytes = usr_stats->ack_ba.success_bytes;
 		succ_pkts = FIELD_GET(HTT_PPDU_STATS_ACK_BA_INFO_NUM_MSDU_M,
 				      usr_stats->ack_ba.info);
@@ -1332,13 +1379,38 @@ ath12k_update_per_peer_tx_stats(struct a
 		tx_duration = common->fes_duration_us;
 
 	user_rate = &usr_stats->rate;
-	flags = HTT_USR_RATE_PREAMBLE(user_rate->rate_flags);
-	bw = HTT_USR_RATE_BW(user_rate->rate_flags) - 2;
-	nss = HTT_USR_RATE_NSS(user_rate->rate_flags) + 1;
-	mcs = HTT_USR_RATE_MCS(user_rate->rate_flags);
-	sgi = HTT_USR_RATE_GI(user_rate->rate_flags);
-	dcm = HTT_USR_RATE_DCM(user_rate->rate_flags);
 	ppdu_type = HTT_USR_RATE_PPDU_TYPE(user_rate->info1);
+	resp_type_valid = u32_get_bits(user_rate->info1,
+				       HTT_PPDU_STATS_USER_RATE_INFO1_RESP_TYPE_VALID);
+	if (resp_type_valid) {
+		rate_flags = user_rate->resp_rate_flags;
+		ru_start = user_rate->resp_ru_start;
+		ru_end = user_rate->ru_end;
+		ppdu_type = HTT_USR_RESP_RATE_PPDU_TYPE(user_rate->resp_rate_flags);
+		if (ppdu_type == HTT_PPDU_STATS_RESP_PPDU_TYPE_MU_OFDMA_UL)
+			ppdu_type = HTT_PPDU_STATS_PPDU_TYPE_MU_OFDMA;
+		else
+			ppdu_type = HTT_PPDU_STATS_PPDU_TYPE_MU_MIMO;
+	} else {
+		rate_flags = user_rate->rate_flags;
+		ru_start = user_rate->ru_start;
+		ru_end = user_rate->ru_end;
+	}
+
+	flags = HTT_USR_RATE_PREAMBLE(rate_flags);
+	bw = HTT_USR_RATE_BW(rate_flags) - 2;
+	nss = HTT_USR_RATE_NSS(rate_flags) + 1;
+	mcs = HTT_USR_RATE_MCS(rate_flags);
+	sgi = HTT_USR_RATE_GI(rate_flags);
+	dcm = HTT_USR_RATE_DCM(rate_flags);
+	ru_format = FIELD_GET(HTT_PPDU_STATS_USER_RATE_INFO0_RU_SIZE,
+			      user_rate->info0);
+	if (ru_format == 1)
+		ru_tones = ath12k_dp_rx_ru_alloc_from_ru_size(ru_start);
+	else if (!ru_format)
+		ru_tones = ru_end - ru_start + 1;
+	else
+		ru_tones = ath12k_dp_rx_ru_alloc_from_ru_size(HTT_PPDU_STATS_RU_26);
 
 	/* Note: If host configured fixed rates and in some other special
 	 * cases, the broadcast/management frames are sent in different rates.
@@ -1419,18 +1491,17 @@ ath12k_update_per_peer_tx_stats(struct a
 		arsta->txrate.flags = RATE_INFO_FLAGS_HE_MCS;
 		arsta->txrate.he_dcm = dcm;
 		arsta->txrate.he_gi = ath12k_he_gi_to_nl80211_he_gi(sgi);
-		arsta->txrate.he_ru_alloc = ath12k_mac_he_ru_tones_to_nl80211_he_ru_alloc(
-						(user_rate->ru_end -
-						 user_rate->ru_start) + 1);
+		arsta->txrate.he_ru_alloc = ru_tones;
+		peer_stats->ru_tones = arsta->txrate.he_ru_alloc;
 		break;
 	case WMI_RATE_PREAMBLE_EHT:
 		arsta->txrate.mcs = mcs;
 		arsta->txrate.flags = RATE_INFO_FLAGS_EHT_MCS;
 		arsta->txrate.he_dcm = dcm;
 		arsta->txrate.he_gi = ath12k_he_gi_to_nl80211_he_gi(sgi);
-		arsta->txrate.he_ru_alloc = ath12k_mac_he_ru_tones_to_nl80211_he_ru_alloc(
-						(user_rate->ru_end -
-						 user_rate->ru_start) + 1);
+		arsta->txrate.he_ru_alloc =
+			ath12k_mac_he_ru_tones_to_nl80211_he_ru_alloc(
+						(ru_end - ru_start) + 1);
 		break;
 	default:
 		break;
@@ -1450,6 +1521,7 @@ ath12k_update_per_peer_tx_stats(struct a
 		peer_stats->succ_bytes = succ_bytes;
 		peer_stats->is_ampdu = is_ampdu;
 		peer_stats->duration = tx_duration;
+		peer_stats->ru_tones = ru_tones;
 		peer_stats->ba_fails =
 			HTT_USR_CMPLTN_LONG_RETRY(usr_stats->cmpltn_cmn.flags) +
 			HTT_USR_CMPLTN_SHORT_RETRY(usr_stats->cmpltn_cmn.flags);
@@ -1464,12 +1536,12 @@ ath12k_update_per_peer_tx_stats(struct a
 }
 
 static void ath12k_htt_update_ppdu_stats(struct ath12k *ar,
-					 struct htt_ppdu_stats *ppdu_stats)
+					 struct htt_ppdu_stats_info *ppdu_info)
 {
 	u8 user;
 
 	for (user = 0; user < HTT_PPDU_STATS_MAX_USERS - 1; user++)
-		ath12k_update_per_peer_tx_stats(ar, ppdu_stats, user);
+		ath12k_update_per_peer_tx_stats(ar, ppdu_info, user);
 }
 
 static
@@ -1490,7 +1562,7 @@ struct htt_ppdu_stats_info *ath12k_dp_ht
 						     typeof(*ppdu_info), list);
 			list_del(&ppdu_info->list);
 			ar->ppdu_stat_list_depth--;
-			ath12k_htt_update_ppdu_stats(ar, &ppdu_info->ppdu_stats);
+			ath12k_htt_update_ppdu_stats(ar, ppdu_info);
 			kfree(ppdu_info);
 		}
 	}
