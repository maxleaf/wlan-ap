From 29352929a0b06d8bb9a6705520bad9dcc8b5f917 Mon Sep 17 00:00:00 2001
From: John Crispin <john@phrozen.org>
Date: Thu, 17 Aug 2023 20:04:07 +0200
Subject: [PATCH 3/6] hostapd: drop current version

Signed-off-by: John Crispin <john@phrozen.org>
---
 package/network/services/hostapd/Config.in    |   89 -
 package/network/services/hostapd/Makefile     |  710 --------
 .../hostapd/files/hostapd-basic.config        |  401 -----
 .../hostapd/files/hostapd-full.config         |  401 -----
 .../hostapd/files/hostapd-mini.config         |  401 -----
 .../network/services/hostapd/files/hostapd.sh | 1499 ----------------
 .../services/hostapd/files/multicall.c        |   28 -
 .../hostapd/files/wpa_supplicant-basic.config |  625 -------
 .../hostapd/files/wpa_supplicant-full.config  |  625 -------
 .../hostapd/files/wpa_supplicant-mini.config  |  625 -------
 .../hostapd/files/wpa_supplicant-p2p.config   |  625 -------
 .../network/services/hostapd/files/wpad.init  |   41 -
 .../network/services/hostapd/files/wpad.json  |   22 -
 .../services/hostapd/files/wpad_acl.json      |   10 -
 .../services/hostapd/files/wps-hotplug.sh     |   62 -
 ...-fix-frequency-setup-with-HE-enabled.patch |  196 ---
 ...-init-order-disable-pri-sec-channel-.patch |  126 --
 ...andle-HT40-and-mode-downgrade-in-AP-.patch |  102 --
 ...ix-frequency-config-for-non-p2p-vht-.patch |   63 -
 ...nable-vht-and-he-in-default-config-p.patch |   25 -
 ...er-debug-messages-for-some-error-cas.patch |   83 -
 ...lper-functions-for-vht-he-parameters.patch |   27 -
 ...ompletion-callback-to-complete-mesh-.patch |  108 --
 ...-frequency-as-pri-sec-channel-switch.patch |   26 -
 ...hannels-to-be-selected-if-dfs-is-ena.patch |   80 -
 ...offchanok-on-DFS-channels-in-non-ETS.patch |   53 -
 ...-fix-channel-switch-error-during-CAC.patch |   66 -
 ...rnel-driver-DFS-handler-in-userspace.patch |   48 -
 .../014-mesh-fixes-for-mesh-init-deinit.patch |  158 --
 .../015-mesh-fix-DFS-deinit-init.patch        |  262 ---
 ...sts-DFS-test-for-wpa_supplicant-mesh.patch |   94 -
 .../patches/017-mesh-fix-mesh_oom-test.patch  |   24 -
 ...ve-mesh-freq-setting-to-own-function.patch |   93 -
 ...erministic-channel-on-channel-switch.patch |   81 -
 ...020-ignore-4addr-mode-enabling-error.patch |   73 -
 ...-dl_list_del-before-freeing-ipv6-add.patch |   19 -
 ...ewrite-neigh-code-to-not-depend-on-l.patch |  275 ---
 ...ssing-authentication-frames-in-block.patch |   34 -
 ...50-mesh-make-forwarding-configurable.patch |  219 ---
 ...-case-in-peer-addition-based-on-PD-R.patch |   45 -
 .../hostapd/patches/100-daemonize_fix.patch   |   97 -
 .../patches/110-notify-mgmt-frames.patch      |  116 --
 .../patches/110-wolfssl-compile-fix.patch     |   10 -
 .../120-reconfigure-wps-credentials.patch     |  178 --
 .../hostapd/patches/200-multicall.patch       |  355 ----
 .../services/hostapd/patches/300-noscan.patch |   58 -
 .../hostapd/patches/301-mesh-noscan.patch     |   68 -
 .../patches/310-rescan_immediately.patch      |   11 -
 .../hostapd/patches/320-optional_rfkill.patch |   61 -
 .../patches/330-nl80211_fix_set_freq.patch    |   11 -
 .../patches/340-reload_freq_change.patch      |   75 -
 .../341-mesh-ctrl-iface-channel-switch.patch  |   39 -
 .../patches/350-nl80211_del_beacon_bss.patch  |   54 -
 .../patches/360-ctrl_iface_reload.patch       |  106 --
 .../hostapd/patches/370-ap_sta_support.patch  |  403 -----
 .../patches/380-disable_ctrl_iface_mib.patch  |  193 --
 .../381-hostapd_cli_UNKNOWN-COMMAND.patch     |   11 -
 .../patches/390-wpa_ie_cap_workaround.patch   |   56 -
 .../400-wps_single_auth_enc_type.patch        |   23 -
 .../patches/410-limit_debug_messages.patch    |  210 ---
 .../patches/420-indicate-features.patch       |   62 -
 .../patches/430-hostapd_cli_ifdef.patch       |   56 -
 .../hostapd/patches/431-wpa_cli_ifdef.patch   |   18 -
 .../hostapd/patches/432-missing-typedef.patch |   10 -
 .../hostapd/patches/450-scan_wait.patch       |   73 -
 ...dd-new-config-params-to-be-used-with.patch |  189 --
 ...-use-new-parameters-during-ibss-join.patch |   59 -
 .../patches/463-add-mcast_rate-to-11s.patch   |   68 -
 .../patches/464-fix-mesh-obss-check.patch     |   19 -
 .../patches/470-survey_data_fallback.patch    |   45 -
 .../patches/500-lto-jobserver-support.patch   |   50 -
 .../599-wpa_supplicant-fix-warnings.patch     |   19 -
 .../hostapd/patches/600-ubus_support.patch    |  426 -----
 .../hostapd/patches/700-wifi-reload.patch     |  219 ---
 .../hostapd/patches/710-vlan_no_bridge.patch  |   33 -
 .../patches/711-wds_bridge_force.patch        |   22 -
 .../hostapd/patches/730-ft_iface.patch        |   38 -
 .../hostapd/patches/740-snoop_iface.patch     |   66 -
 ...750-qos_map_set_without_interworking.patch |  112 --
 ...ate-if-no-available-channel-is-found.patch |   37 -
 ...of-secondary-device-types-for-P2P-gr.patch |   33 -
 .../802-wolfssl-init-RNG-with-ECC-key.patch   |   43 -
 .../services/hostapd/src/src/ap/ubus.c        | 1557 -----------------
 .../services/hostapd/src/src/ap/ubus.h        |  103 --
 .../hostapd/src/src/utils/build_features.h    |   59 -
 .../hostapd/src/wpa_supplicant/ubus.c         |  430 -----
 .../hostapd/src/wpa_supplicant/ubus.h         |   66 -
 87 files changed, 14591 deletions(-)
 delete mode 100644 package/network/services/hostapd/Config.in
 delete mode 100644 package/network/services/hostapd/Makefile
 delete mode 100644 package/network/services/hostapd/files/hostapd-basic.config
 delete mode 100644 package/network/services/hostapd/files/hostapd-full.config
 delete mode 100644 package/network/services/hostapd/files/hostapd-mini.config
 delete mode 100644 package/network/services/hostapd/files/hostapd.sh
 delete mode 100644 package/network/services/hostapd/files/multicall.c
 delete mode 100644 package/network/services/hostapd/files/wpa_supplicant-basic.config
 delete mode 100644 package/network/services/hostapd/files/wpa_supplicant-full.config
 delete mode 100644 package/network/services/hostapd/files/wpa_supplicant-mini.config
 delete mode 100644 package/network/services/hostapd/files/wpa_supplicant-p2p.config
 delete mode 100644 package/network/services/hostapd/files/wpad.init
 delete mode 100644 package/network/services/hostapd/files/wpad.json
 delete mode 100644 package/network/services/hostapd/files/wpad_acl.json
 delete mode 100644 package/network/services/hostapd/files/wps-hotplug.sh
 delete mode 100644 package/network/services/hostapd/patches/001-HE-VHT-fix-frequency-setup-with-HE-enabled.patch
 delete mode 100644 package/network/services/hostapd/patches/002-mesh-fix-channel-init-order-disable-pri-sec-channel-.patch
 delete mode 100644 package/network/services/hostapd/patches/003-wpa_supplicant-handle-HT40-and-mode-downgrade-in-AP-.patch
 delete mode 100644 package/network/services/hostapd/patches/004-wpa_supplicant-fix-frequency-config-for-non-p2p-vht-.patch
 delete mode 100644 package/network/services/hostapd/patches/005-wpa_supplicant-enable-vht-and-he-in-default-config-p.patch
 delete mode 100644 package/network/services/hostapd/patches/006-hw_features-better-debug-messages-for-some-error-cas.patch
 delete mode 100644 package/network/services/hostapd/patches/007-dfs-use-helper-functions-for-vht-he-parameters.patch
 delete mode 100644 package/network/services/hostapd/patches/008-mesh-use-setup-completion-callback-to-complete-mesh-.patch
 delete mode 100644 package/network/services/hostapd/patches/009-mesh-update-ssid-frequency-as-pri-sec-channel-switch.patch
 delete mode 100644 package/network/services/hostapd/patches/010-mesh-Allow-DFS-channels-to-be-selected-if-dfs-is-ena.patch
 delete mode 100644 package/network/services/hostapd/patches/011-mesh-do-not-set-offchanok-on-DFS-channels-in-non-ETS.patch
 delete mode 100644 package/network/services/hostapd/patches/012-mesh-fix-channel-switch-error-during-CAC.patch
 delete mode 100644 package/network/services/hostapd/patches/013-mesh-inform-kernel-driver-DFS-handler-in-userspace.patch
 delete mode 100644 package/network/services/hostapd/patches/014-mesh-fixes-for-mesh-init-deinit.patch
 delete mode 100644 package/network/services/hostapd/patches/015-mesh-fix-DFS-deinit-init.patch
 delete mode 100644 package/network/services/hostapd/patches/016-tests-DFS-test-for-wpa_supplicant-mesh.patch
 delete mode 100644 package/network/services/hostapd/patches/017-mesh-fix-mesh_oom-test.patch
 delete mode 100644 package/network/services/hostapd/patches/018-mesh-move-mesh-freq-setting-to-own-function.patch
 delete mode 100644 package/network/services/hostapd/patches/019-mesh-use-deterministic-channel-on-channel-switch.patch
 delete mode 100644 package/network/services/hostapd/patches/020-ignore-4addr-mode-enabling-error.patch
 delete mode 100644 package/network/services/hostapd/patches/023-ndisc_snoop-call-dl_list_del-before-freeing-ipv6-add.patch
 delete mode 100644 package/network/services/hostapd/patches/030-driver_nl80211-rewrite-neigh-code-to-not-depend-on-l.patch
 delete mode 100644 package/network/services/hostapd/patches/040-mesh-allow-processing-authentication-frames-in-block.patch
 delete mode 100644 package/network/services/hostapd/patches/050-mesh-make-forwarding-configurable.patch
 delete mode 100644 package/network/services/hostapd/patches/060-P2P-Fix-a-corner-case-in-peer-addition-based-on-PD-R.patch
 delete mode 100644 package/network/services/hostapd/patches/100-daemonize_fix.patch
 delete mode 100644 package/network/services/hostapd/patches/110-notify-mgmt-frames.patch
 delete mode 100644 package/network/services/hostapd/patches/110-wolfssl-compile-fix.patch
 delete mode 100644 package/network/services/hostapd/patches/120-reconfigure-wps-credentials.patch
 delete mode 100644 package/network/services/hostapd/patches/200-multicall.patch
 delete mode 100644 package/network/services/hostapd/patches/300-noscan.patch
 delete mode 100644 package/network/services/hostapd/patches/301-mesh-noscan.patch
 delete mode 100644 package/network/services/hostapd/patches/310-rescan_immediately.patch
 delete mode 100644 package/network/services/hostapd/patches/320-optional_rfkill.patch
 delete mode 100644 package/network/services/hostapd/patches/330-nl80211_fix_set_freq.patch
 delete mode 100644 package/network/services/hostapd/patches/340-reload_freq_change.patch
 delete mode 100644 package/network/services/hostapd/patches/341-mesh-ctrl-iface-channel-switch.patch
 delete mode 100644 package/network/services/hostapd/patches/350-nl80211_del_beacon_bss.patch
 delete mode 100644 package/network/services/hostapd/patches/360-ctrl_iface_reload.patch
 delete mode 100644 package/network/services/hostapd/patches/370-ap_sta_support.patch
 delete mode 100644 package/network/services/hostapd/patches/380-disable_ctrl_iface_mib.patch
 delete mode 100644 package/network/services/hostapd/patches/381-hostapd_cli_UNKNOWN-COMMAND.patch
 delete mode 100644 package/network/services/hostapd/patches/390-wpa_ie_cap_workaround.patch
 delete mode 100644 package/network/services/hostapd/patches/400-wps_single_auth_enc_type.patch
 delete mode 100644 package/network/services/hostapd/patches/410-limit_debug_messages.patch
 delete mode 100644 package/network/services/hostapd/patches/420-indicate-features.patch
 delete mode 100644 package/network/services/hostapd/patches/430-hostapd_cli_ifdef.patch
 delete mode 100644 package/network/services/hostapd/patches/431-wpa_cli_ifdef.patch
 delete mode 100644 package/network/services/hostapd/patches/432-missing-typedef.patch
 delete mode 100644 package/network/services/hostapd/patches/450-scan_wait.patch
 delete mode 100644 package/network/services/hostapd/patches/460-wpa_supplicant-add-new-config-params-to-be-used-with.patch
 delete mode 100644 package/network/services/hostapd/patches/461-driver_nl80211-use-new-parameters-during-ibss-join.patch
 delete mode 100644 package/network/services/hostapd/patches/463-add-mcast_rate-to-11s.patch
 delete mode 100644 package/network/services/hostapd/patches/464-fix-mesh-obss-check.patch
 delete mode 100644 package/network/services/hostapd/patches/470-survey_data_fallback.patch
 delete mode 100644 package/network/services/hostapd/patches/500-lto-jobserver-support.patch
 delete mode 100644 package/network/services/hostapd/patches/599-wpa_supplicant-fix-warnings.patch
 delete mode 100644 package/network/services/hostapd/patches/600-ubus_support.patch
 delete mode 100644 package/network/services/hostapd/patches/700-wifi-reload.patch
 delete mode 100644 package/network/services/hostapd/patches/710-vlan_no_bridge.patch
 delete mode 100644 package/network/services/hostapd/patches/711-wds_bridge_force.patch
 delete mode 100644 package/network/services/hostapd/patches/730-ft_iface.patch
 delete mode 100644 package/network/services/hostapd/patches/740-snoop_iface.patch
 delete mode 100644 package/network/services/hostapd/patches/750-qos_map_set_without_interworking.patch
 delete mode 100644 package/network/services/hostapd/patches/800-dfs-enter-DFS-state-if-no-available-channel-is-found.patch
 delete mode 100644 package/network/services/hostapd/patches/801-P2P-Fix-copying-of-secondary-device-types-for-P2P-gr.patch
 delete mode 100644 package/network/services/hostapd/patches/802-wolfssl-init-RNG-with-ECC-key.patch
 delete mode 100644 package/network/services/hostapd/src/src/ap/ubus.c
 delete mode 100644 package/network/services/hostapd/src/src/ap/ubus.h
 delete mode 100644 package/network/services/hostapd/src/src/utils/build_features.h
 delete mode 100644 package/network/services/hostapd/src/wpa_supplicant/ubus.c
 delete mode 100644 package/network/services/hostapd/src/wpa_supplicant/ubus.h

diff --git a/package/network/services/hostapd/Config.in b/package/network/services/hostapd/Config.in
deleted file mode 100644
index 5c00f3e24e..0000000000
--- a/package/network/services/hostapd/Config.in
+++ /dev/null
@@ -1,89 +0,0 @@
-# wpa_supplicant config
-config WPA_RFKILL_SUPPORT
-	bool "Add rfkill support"
-	depends on PACKAGE_wpa-supplicant || \
-		   PACKAGE_wpa-supplicant-openssl || \
-		   PACKAGE_wpa-supplicant-wolfssl || \
-		   PACKAGE_wpa-supplicant-mesh-openssl || \
-		   PACKAGE_wpa-supplicant-mesh-wolfssl || \
-		   PACKAGE_wpa-supplicant-basic || \
-		   PACKAGE_wpa-supplicant-mini || \
-		   PACKAGE_wpa-supplicant-p2p || \
-		   PACKAGE_wpad || \
-		   PACKAGE_wpad-openssl || \
-		   PACKAGE_wpad-wolfssl || \
-		   PACKAGE_wpad-basic || \
-		   PACKAGE_wpad-basic-openssl || \
-		   PACKAGE_wpad-basic-wolfssl || \
-		   PACKAGE_wpad-mini || \
-		   PACKAGE_wpad-mesh-openssl || \
-		   PACKAGE_wpad-mesh-wolfssl
-	default n
-
-config WPA_MSG_MIN_PRIORITY
-	int "Minimum debug message priority"
-	depends on PACKAGE_wpa-supplicant || \
-		   PACKAGE_wpa-supplicant-openssl || \
-		   PACKAGE_wpa-supplicant-wolfssl || \
-		   PACKAGE_wpa-supplicant-mesh-openssl || \
-		   PACKAGE_wpa-supplicant-mesh-wolfssl || \
-		   PACKAGE_wpa-supplicant-basic || \
-		   PACKAGE_wpa-supplicant-mini || \
-		   PACKAGE_wpa-supplicant-p2p || \
-		   PACKAGE_wpad || \
-		   PACKAGE_wpad-openssl || \
-		   PACKAGE_wpad-wolfssl || \
-		   PACKAGE_wpad-basic || \
-		   PACKAGE_wpad-basic-openssl || \
-		   PACKAGE_wpad-basic-wolfssl || \
-		   PACKAGE_wpad-mini || \
-		   PACKAGE_wpad-mesh-openssl || \
-		   PACKAGE_wpad-mesh-wolfssl
-	default 3
-	help
-	  Useful values are:
-	    0 = all messages
-		1 = raw message dumps
-		2 = most debugging messages
-		3 = info messages
-		4 = warnings
-		5 = errors
-
-config WPA_WOLFSSL
-	bool
-	default PACKAGE_wpa-supplicant-wolfssl ||\
-	        PACKAGE_wpad-wolfssl ||\
-	        PACKAGE_wpad-basic-wolfssl || \
-	        PACKAGE_wpad-mesh-wolfssl ||\
-	        PACKAGE_eapol-test-wolfssl
-	select WOLFSSL_HAS_AES_CCM
-	select WOLFSSL_HAS_ARC4
-	select WOLFSSL_HAS_DH
-	select WOLFSSL_HAS_OCSP
-	select WOLFSSL_HAS_SESSION_TICKET
-	select WOLFSSL_HAS_WPAS
-
-config DRIVER_WEXT_SUPPORT
-	bool
-	default n
-
-config DRIVER_11N_SUPPORT
-	bool
-	default n
-
-config DRIVER_11AC_SUPPORT
-	bool
-	default n
-
-config DRIVER_11AX_SUPPORT
-	bool
-	default n
-
-config WPA_ENABLE_WEP
-	bool "Enable support for unsecure and obsolete WEP"
-	help
-	  Wired equivalent privacy (WEP) is an obsolete cryptographic data
-	  confidentiality algorithm that is not considered secure. It should not be used
-	  for anything anymore. The functionality needed to use WEP is available in the
-	  current hostapd release under this optional build parameter and completely
-	  removed in a future release.
diff --git a/package/network/services/hostapd/Makefile b/package/network/services/hostapd/Makefile
deleted file mode 100644
index 783c10d587..0000000000
--- a/package/network/services/hostapd/Makefile
+++ /dev/null
@@ -1,710 +0,0 @@
-# Copyright (C) 2006-2014 OpenWrt.org
-#
-# This is free software, licensed under the GNU General Public License v2.
-# See /LICENSE for more information.
-#
-
-include $(TOPDIR)/rules.mk
-
-PKG_NAME:=hostapd
-PKG_RELEASE:=37
-
-PKG_SOURCE_URL:=http://w1.fi/hostap.git
-PKG_SOURCE_PROTO:=git
-PKG_SOURCE_DATE:=2020-06-08
-PKG_SOURCE_VERSION:=5a8b366233f5585e68a4ffbb604fbb4a848eb325
-PKG_MIRROR_HASH:=1b2a4947034142587a3f81eac2ea27dd64650e77f8943d973623b47533be2393
-
-PKG_MAINTAINER:=Felix Fietkau <nbd@nbd.name>
-PKG_LICENSE:=BSD-3-Clause
-PKG_CPE_ID:=cpe:/a:w1.fi:hostapd
-
-PKG_BUILD_PARALLEL:=1
-PKG_ASLR_PIE_REGULAR:=1
-
-PKG_CONFIG_DEPENDS:= \
-	CONFIG_PACKAGE_kmod-ath9k \
-	CONFIG_PACKAGE_kmod-cfg80211 \
-	CONFIG_PACKAGE_hostapd \
-	CONFIG_PACKAGE_hostapd-basic \
-	CONFIG_PACKAGE_hostapd-mini \
-	CONFIG_WPA_RFKILL_SUPPORT \
-	CONFIG_DRIVER_WEXT_SUPPORT \
-	CONFIG_DRIVER_11N_SUPPORT \
-	CONFIG_DRIVER_11AC_SUPPORT \
-	CONFIG_DRIVER_11AX_SUPPORT \
-	CONFIG_WPA_ENABLE_WEP
-
-EAPOL_TEST_PROVIDERS:=eapol-test eapol-test-openssl eapol-test-wolfssl
-
-SUPPLICANT_PROVIDERS:=
-HOSTAPD_PROVIDERS:=
-
-LOCAL_TYPE=$(strip \
-		$(if $(findstring wpad,$(BUILD_VARIANT)),wpad, \
-		$(if $(findstring supplicant,$(BUILD_VARIANT)),supplicant, \
-		hostapd \
-		)))
-
-LOCAL_AND_LIB_VARIANT=$(patsubst hostapd-%,%,\
-		      $(patsubst wpad-%,%,\
-		      $(patsubst supplicant-%,%,\
-		      $(BUILD_VARIANT)\
-		      )))
-
-LOCAL_VARIANT=$(patsubst %-internal,%,\
-	      $(patsubst %-openssl,%,\
-	      $(patsubst %-wolfssl,%,\
-	      $(LOCAL_AND_LIB_VARIANT)\
-	      )))
-
-SSL_VARIANT=$(strip \
-		$(if $(findstring openssl,$(LOCAL_AND_LIB_VARIANT)),openssl,\
-		$(if $(findstring wolfssl,$(LOCAL_AND_LIB_VARIANT)),wolfssl,\
-		internal\
-		)))
-
-CONFIG_VARIANT:=$(LOCAL_VARIANT)
-ifeq ($(LOCAL_VARIANT),mesh)
-  CONFIG_VARIANT:=full
-endif
-
-include $(INCLUDE_DIR)/package.mk
-
-STAMP_CONFIGURED:=$(STAMP_CONFIGURED)_$(CONFIG_WPA_MSG_MIN_PRIORITY)
-
-
-ifneq ($(CONFIG_DRIVER_11N_SUPPORT),)
-  HOSTAPD_IEEE80211N:=y
-endif
-
-ifneq ($(CONFIG_DRIVER_11AC_SUPPORT),)
-  HOSTAPD_IEEE80211AC:=y
-endif
-
-ifneq ($(CONFIG_DRIVER_11AX_SUPPORT),)
-  HOSTAPD_IEEE80211AX:=y
-endif
-
-DRIVER_MAKEOPTS= \
-	CONFIG_ACS=$(CONFIG_PACKAGE_kmod-cfg80211) \
-	CONFIG_DRIVER_NL80211=$(CONFIG_PACKAGE_kmod-cfg80211) \
-	CONFIG_IEEE80211N=$(HOSTAPD_IEEE80211N) \
-	CONFIG_IEEE80211AC=$(HOSTAPD_IEEE80211AC) \
-	CONFIG_IEEE80211AX=$(HOSTAPD_IEEE80211AX) \
-	CONFIG_DRIVER_WEXT=$(CONFIG_DRIVER_WEXT_SUPPORT) \
-
-ifeq ($(SSL_VARIANT),openssl)
-  DRIVER_MAKEOPTS += CONFIG_TLS=openssl CONFIG_SAE=y
-  TARGET_LDFLAGS += -lcrypto -lssl
-
-  ifeq ($(LOCAL_VARIANT),basic)
-    DRIVER_MAKEOPTS += CONFIG_OWE=y
-  endif
-  ifeq ($(LOCAL_VARIANT),mesh)
-    DRIVER_MAKEOPTS += CONFIG_AP=y CONFIG_MESH=y
-  endif
-  ifeq ($(LOCAL_VARIANT),full)
-    DRIVER_MAKEOPTS += CONFIG_OWE=y CONFIG_SUITEB192=y CONFIG_AP=y CONFIG_MESH=y
-  endif
-endif
-
-ifeq ($(SSL_VARIANT),wolfssl)
-  DRIVER_MAKEOPTS += CONFIG_TLS=wolfssl CONFIG_SAE=y
-  TARGET_LDFLAGS += -lwolfssl
-
-  ifeq ($(LOCAL_VARIANT),basic)
-    DRIVER_MAKEOPTS += CONFIG_OWE=y
-  endif
-  ifeq ($(LOCAL_VARIANT),mesh)
-    DRIVER_MAKEOPTS += CONFIG_AP=y CONFIG_MESH=y CONFIG_WPS_NFC=1
-  endif
-  ifeq ($(LOCAL_VARIANT),full)
-    DRIVER_MAKEOPTS += CONFIG_OWE=y CONFIG_SUITEB192=y CONFIG_AP=y CONFIG_MESH=y CONFIG_WPS_NFC=1
-  endif
-endif
-
-ifneq ($(LOCAL_TYPE),hostapd)
-  ifdef CONFIG_WPA_RFKILL_SUPPORT
-    DRIVER_MAKEOPTS += NEED_RFKILL=y
-  endif
-endif
-
-ifdef CONFIG_USE_GLIBC
-  TARGET_LDFLAGS += -lrt
-  TARGET_LDFLAGS_C += -lrt
-endif
-
-DRV_DEPENDS:=+PACKAGE_kmod-cfg80211:libnl-tiny
-
-
-define Package/hostapd/Default
-  SECTION:=net
-  CATEGORY:=Network
-  SUBMENU:=WirelessAPD
-  TITLE:=IEEE 802.1x Authenticator
-  URL:=http://hostap.epitest.fi/
-  DEPENDS:=$(DRV_DEPENDS) +hostapd-common +libubus
-  USERID:=network=101:network=101
-  PROVIDES:=hostapd
-  CONFLICTS:=$(HOSTAPD_PROVIDERS)
-  HOSTAPD_PROVIDERS+=$(1)
-endef
-
-define Package/hostapd
-$(call Package/hostapd/Default,$(1))
-  TITLE+= (built-in full)
-  VARIANT:=full-internal
-endef
-
-define Package/hostapd/description
- This package contains a full featured IEEE 802.1x/WPA/EAP/RADIUS
- Authenticator.
-endef
-
-define Package/hostapd-openssl
-$(call Package/hostapd/Default,$(1))
-  TITLE+= (OpenSSL full)
-  VARIANT:=full-openssl
-  DEPENDS+=+libopenssl
-endef
-
-Package/hostapd-openssl/description = $(Package/hostapd/description)
-
-define Package/hostapd-wolfssl
-$(call Package/hostapd/Default,$(1))
-  TITLE+= (wolfSSL full)
-  VARIANT:=full-wolfssl
-  DEPENDS+=+libwolfssl
-endef
-
-Package/hostapd-wolfssl/description = $(Package/hostapd/description)
-
-define Package/hostapd-basic
-$(call Package/hostapd/Default,$(1))
-  TITLE+= (WPA-PSK, 11r, 11w)
-  VARIANT:=basic
-endef
-
-define Package/hostapd-basic/description
- This package contains a basic IEEE 802.1x/WPA Authenticator with WPA-PSK, 802.11r and 802.11w support.
-endef
-
-define Package/hostapd-basic-openssl
-$(call Package/hostapd/Default,$(1))
-  TITLE+= (WPA-PSK, 11r and 11w)
-  VARIANT:=basic-openssl
-  DEPENDS+=+libopenssl
-endef
-
-define Package/hostapd-basic-openssl/description
- This package contains a basic IEEE 802.1x/WPA Authenticator with WPA-PSK, 802.11r and 802.11w support.
-endef
-
-define Package/hostapd-basic-wolfssl
-$(call Package/hostapd/Default,$(1))
-  TITLE+= (WPA-PSK, 11r and 11w)
-  VARIANT:=basic-wolfssl
-  DEPENDS+=+libwolfssl
-endef
-
-define Package/hostapd-basic-wolfssl/description
- This package contains a basic IEEE 802.1x/WPA Authenticator with WPA-PSK, 802.11r and 802.11w support.
-endef
-
-define Package/hostapd-mini
-$(call Package/hostapd/Default,$(1))
-  TITLE+= (WPA-PSK only)
-  VARIANT:=mini
-endef
-
-define Package/hostapd-mini/description
- This package contains a minimal IEEE 802.1x/WPA Authenticator (WPA-PSK only).
-endef
-
-
-define Package/wpad/Default
-  SECTION:=net
-  CATEGORY:=Network
-  SUBMENU:=WirelessAPD
-  TITLE:=IEEE 802.1x Auth/Supplicant
-  DEPENDS:=$(DRV_DEPENDS) +hostapd-common +libubus
-  USERID:=network=101:network=101
-  URL:=http://hostap.epitest.fi/
-  PROVIDES:=hostapd wpa-supplicant
-  CONFLICTS:=$(HOSTAPD_PROVIDERS) $(SUPPLICANT_PROVIDERS)
-  HOSTAPD_PROVIDERS+=$(1)
-  SUPPLICANT_PROVIDERS+=$(1)
-endef
-
-define Package/wpad
-$(call Package/wpad/Default,$(1))
-  TITLE+= (built-in full)
-  VARIANT:=wpad-full-internal
-endef
-
-define Package/wpad/description
- This package contains a full featured IEEE 802.1x/WPA/EAP/RADIUS
- Authenticator and Supplicant
-endef
-
-define Package/wpad-openssl
-$(call Package/wpad/Default,$(1))
-  TITLE+= (OpenSSL full)
-  VARIANT:=wpad-full-openssl
-  DEPENDS+=+libopenssl
-endef
-
-Package/wpad-openssl/description = $(Package/wpad/description)
-
-define Package/wpad-wolfssl
-$(call Package/wpad/Default,$(1))
-  TITLE+= (wolfSSL full)
-  VARIANT:=wpad-full-wolfssl
-  DEPENDS+=+libwolfssl
-endef
-
-Package/wpad-wolfssl/description = $(Package/wpad/description)
-
-define Package/wpad-basic
-$(call Package/wpad/Default,$(1))
-  TITLE+= (WPA-PSK, 11r, 11w)
-  VARIANT:=wpad-basic
-endef
-
-define Package/wpad-basic/description
- This package contains a basic IEEE 802.1x/WPA Authenticator and Supplicant with WPA-PSK, 802.11r and 802.11w support.
-endef
-
-define Package/wpad-basic-openssl
-$(call Package/wpad/Default,$(1))
-  TITLE+= (OpenSSL, 11r, 11w)
-  VARIANT:=wpad-basic-openssl
-  DEPENDS+=+libopenssl
-endef
-
-define Package/wpad-basic-openssl/description
- This package contains a basic IEEE 802.1x/WPA Authenticator and Supplicant with WPA-PSK, SAE (WPA3-Personal), 802.11r and 802.11w support.
-endef
-
-define Package/wpad-basic-wolfssl
-$(call Package/wpad/Default,$(1))
-  TITLE+= (wolfSSL, 11r, 11w)
-  VARIANT:=wpad-basic-wolfssl
-  DEPENDS+=+libwolfssl
-endef
-
-define Package/wpad-basic-wolfssl/description
- This package contains a basic IEEE 802.1x/WPA Authenticator and Supplicant with WPA-PSK, SAE (WPA3-Personal), 802.11r and 802.11w support.
-endef
-
-define Package/wpad-mini
-$(call Package/wpad/Default,$(1))
-  TITLE+= (WPA-PSK only)
-  VARIANT:=wpad-mini
-endef
-
-define Package/wpad-mini/description
- This package contains a minimal IEEE 802.1x/WPA Authenticator and Supplicant (WPA-PSK only).
-endef
-
-define Package/wpad-mesh
-$(call Package/wpad/Default,$(1))
-  DEPENDS+=@PACKAGE_kmod-cfg80211 @(!TARGET_uml||BROKEN)
-  PROVIDES+=wpa-supplicant-mesh wpad-mesh
-endef
-
-define Package/wpad-mesh/description
- This package contains a minimal IEEE 802.1x/WPA Authenticator and Supplicant (with 802.11s mesh and SAE support).
-endef
-
-define Package/wpad-mesh-openssl
-$(call Package/wpad-mesh,$(1))
-  TITLE+= (OpenSSL, 11s, SAE)
-  DEPENDS+=+libopenssl
-  VARIANT:=wpad-mesh-openssl
-endef
-
-Package/wpad-mesh-openssl/description = $(Package/wpad-mesh/description)
-
-define Package/wpad-mesh-wolfssl
-$(call Package/wpad-mesh,$(1))
-  TITLE+= (wolfSSL, 11s, SAE)
-  DEPENDS+=+libwolfssl
-  VARIANT:=wpad-mesh-wolfssl
-endef
-
-Package/wpad-mesh-wolfssl/description = $(Package/wpad-mesh/description)
-
-
-define Package/wpa-supplicant/Default
-  SECTION:=net
-  CATEGORY:=Network
-  SUBMENU:=WirelessAPD
-  TITLE:=WPA Supplicant
-  URL:=http://hostap.epitest.fi/wpa_supplicant/
-  DEPENDS:=$(DRV_DEPENDS) +hostapd-common +libubus
-  USERID:=network=101:network=101
-  PROVIDES:=wpa-supplicant
-  CONFLICTS:=$(SUPPLICANT_PROVIDERS)
-  SUPPLICANT_PROVIDERS+=$(1)
-endef
-
-define Package/wpa-supplicant
-$(call Package/wpa-supplicant/Default,$(1))
-  TITLE+= (built-in full)
-  VARIANT:=supplicant-full-internal
-endef
-
-define Package/wpa-supplicant-openssl
-$(call Package/wpa-supplicant/Default,$(1))
-  TITLE+= (OpenSSL full)
-  VARIANT:=supplicant-full-openssl
-  DEPENDS+=+libopenssl
-endef
-
-define Package/wpa-supplicant-wolfssl
-$(call Package/wpa-supplicant/Default,$(1))
-  TITLE+= (wolfSSL full)
-  VARIANT:=supplicant-full-wolfssl
-  DEPENDS+=+libwolfssl
-endef
-
-define Package/wpa-supplicant/config
-	source "$(SOURCE)/Config.in"
-endef
-
-define Package/wpa-supplicant-p2p
-$(call Package/wpa-supplicant/Default,$(1))
-  TITLE+= (Wi-Fi P2P support)
-  DEPENDS+=@PACKAGE_kmod-cfg80211
-  VARIANT:=supplicant-p2p-internal
-endef
-
-define Package/wpa-supplicant-mesh/Default
-$(call Package/wpa-supplicant/Default,$(1))
-  DEPENDS+=@PACKAGE_kmod-cfg80211 @(!TARGET_uml||BROKEN)
-  PROVIDES+=wpa-supplicant-mesh
-endef
-
-define Package/wpa-supplicant-mesh-openssl
-$(call Package/wpa-supplicant-mesh/Default,$(1))
-  TITLE+= (OpenSSL, 11s, SAE)
-  VARIANT:=supplicant-mesh-openssl
-  DEPENDS+=+libopenssl
-endef
-
-define Package/wpa-supplicant-mesh-wolfssl
-$(call Package/wpa-supplicant-mesh/Default,$(1))
-  TITLE+= (wolfSSL, 11s, SAE)
-  VARIANT:=supplicant-mesh-wolfssl
-  DEPENDS+=+libwolfssl
-endef
-
-define Package/wpa-supplicant-basic
-$(call Package/wpa-supplicant/Default,$(1))
-  TITLE+= (11r, 11w)
-  VARIANT:=supplicant-basic
-endef
-
-define Package/wpa-supplicant-mini
-$(call Package/wpa-supplicant/Default,$(1))
-  TITLE+= (minimal)
-  VARIANT:=supplicant-mini
-endef
-
-
-define Package/hostapd-common
-  TITLE:=hostapd/wpa_supplicant common support files
-  SECTION:=net
-  CATEGORY:=Network
-  SUBMENU:=WirelessAPD
-endef
-
-define Package/hostapd-utils
-  SECTION:=net
-  CATEGORY:=Network
-  SUBMENU:=WirelessAPD
-  TITLE:=IEEE 802.1x Authenticator (utils)
-  URL:=http://hostap.epitest.fi/
-  DEPENDS:=@$(subst $(space),||,$(foreach pkg,$(HOSTAPD_PROVIDERS),PACKAGE_$(pkg)))
-endef
-
-define Package/hostapd-utils/description
- This package contains a command line utility to control the
- IEEE 802.1x/WPA/EAP/RADIUS Authenticator.
-endef
-
-define Package/wpa-cli
-  SECTION:=net
-  CATEGORY:=Network
-  SUBMENU:=WirelessAPD
-  DEPENDS:=@$(subst $(space),||,$(foreach pkg,$(SUPPLICANT_PROVIDERS),PACKAGE_$(pkg)))
-  TITLE:=WPA Supplicant command line control utility
-endef
-
-define Package/eapol-test/Default
-  TITLE:=802.1x auth test utility
-  SECTION:=net
-  SUBMENU:=WirelessAPD
-  CATEGORY:=Network
-  DEPENDS:=$(DRV_DEPENDS) +libubus
-endef
-
-define Package/eapol-test
-  $(call Package/eapol-test/Default,$(1))
-  TITLE+= (built-in full)
-  VARIANT:=supplicant-full-internal
-endef
-
-define Package/eapol-test-openssl
-  $(call Package/eapol-test/Default,$(1))
-  TITLE+= (OpenSSL full)
-  VARIANT:=supplicant-full-openssl
-  CONFLICTS:=$(filter-out eapol-test-openssl ,$(EAPOL_TEST_PROVIDERS))
-  DEPENDS+=+libopenssl
-  PROVIDES:=eapol-test
-endef
-
-define Package/eapol-test-wolfssl
-  $(call Package/eapol-test/Default,$(1))
-  TITLE+= (wolfSSL full)
-  VARIANT:=supplicant-full-wolfssl
-  CONFLICTS:=$(filter-out eapol-test-openssl ,$(filter-out eapol-test-wolfssl ,$(EAPOL_TEST_PROVIDERS)))
-  DEPENDS+=+libwolfssl
-  PROVIDES:=eapol-test
-endef
-
-
-ifneq ($(wildcard $(PKG_BUILD_DIR)/.config_*),$(subst .configured_,.config_,$(STAMP_CONFIGURED)))
-  define Build/Configure/rebuild
-	$(FIND) $(PKG_BUILD_DIR) -name \*.o -or -name \*.a | $(XARGS) rm -f
-	rm -f $(PKG_BUILD_DIR)/hostapd/hostapd
-	rm -f $(PKG_BUILD_DIR)/wpa_supplicant/wpa_supplicant
-	rm -f $(PKG_BUILD_DIR)/.config_*
-	touch $(subst .configured_,.config_,$(STAMP_CONFIGURED))
-  endef
-endif
-
-define Build/Configure
-	$(Build/Configure/rebuild)
-	$(if $(wildcard ./files/hostapd-$(CONFIG_VARIANT).config), \
-		$(CP) ./files/hostapd-$(CONFIG_VARIANT).config $(PKG_BUILD_DIR)/hostapd/.config \
-	)
-	$(if $(wildcard ./files/wpa_supplicant-$(CONFIG_VARIANT).config), \
-		$(CP) ./files/wpa_supplicant-$(CONFIG_VARIANT).config $(PKG_BUILD_DIR)/wpa_supplicant/.config
-	)
-endef
-
-TARGET_CPPFLAGS := \
-	-I$(STAGING_DIR)/usr/include/libnl-tiny \
-	-I$(PKG_BUILD_DIR)/src/crypto \
-	$(TARGET_CPPFLAGS) \
-	-DCONFIG_LIBNL20 \
-	-D_GNU_SOURCE \
-	$(if $(CONFIG_WPA_MSG_MIN_PRIORITY),-DCONFIG_MSG_MIN_PRIORITY=$(CONFIG_WPA_MSG_MIN_PRIORITY))
-
-TARGET_CFLAGS += -ffunction-sections -fdata-sections -flto
-TARGET_LDFLAGS += -Wl,--gc-sections -flto=jobserver -fuse-linker-plugin -lubox -lubus
-
-ifdef CONFIG_PACKAGE_kmod-cfg80211
-  TARGET_LDFLAGS += -lm -lnl-tiny
-endif
-
-ifdef CONFIG_WPA_ENABLE_WEP
-    DRIVER_MAKEOPTS += CONFIG_WEP=y
-endif
-
-define Build/RunMake
-	CFLAGS="$(TARGET_CPPFLAGS) $(TARGET_CFLAGS)" \
-	$(MAKE) $(PKG_JOBS) -C $(PKG_BUILD_DIR)/$(1) \
-		$(TARGET_CONFIGURE_OPTS) \
-		$(DRIVER_MAKEOPTS) \
-		LIBS="$(TARGET_LDFLAGS)" \
-		LIBS_c="$(TARGET_LDFLAGS_C)" \
-		AR="$(TARGET_CROSS)gcc-ar" \
-		BCHECK= \
-		$(2)
-endef
-
-define Build/Compile/wpad
-	echo ` \
-		$(call Build/RunMake,hostapd,-s MULTICALL=1 dump_cflags); \
-		$(call Build/RunMake,wpa_supplicant,-s MULTICALL=1 dump_cflags) | \
-		sed -e 's,-n ,,g' -e 's^$(TARGET_CFLAGS)^^' \
-	` > $(PKG_BUILD_DIR)/.cflags
-	sed -i 's/"/\\"/g' $(PKG_BUILD_DIR)/.cflags
-	+$(call Build/RunMake,hostapd, \
-		CFLAGS="$$$$(cat $(PKG_BUILD_DIR)/.cflags)" \
-		MULTICALL=1 \
-		hostapd_cli hostapd_multi.a \
-	)
-	+$(call Build/RunMake,wpa_supplicant, \
-		CFLAGS="$$$$(cat $(PKG_BUILD_DIR)/.cflags)" \
-		MULTICALL=1 \
-		wpa_cli wpa_supplicant_multi.a \
-	)
-	+export MAKEFLAGS="$(MAKE_JOBSERVER)"; $(TARGET_CC) -o $(PKG_BUILD_DIR)/wpad \
-		$(TARGET_CFLAGS) \
-		./files/multicall.c \
-		$(PKG_BUILD_DIR)/hostapd/hostapd_multi.a \
-		$(PKG_BUILD_DIR)/wpa_supplicant/wpa_supplicant_multi.a \
-		$(TARGET_LDFLAGS)
-endef
-
-define Build/Compile/hostapd
-	+$(call Build/RunMake,hostapd, \
-		hostapd hostapd_cli \
-	)
-endef
-
-define Build/Compile/supplicant
-	+$(call Build/RunMake,wpa_supplicant, \
-		wpa_cli wpa_supplicant \
-	)
-endef
-
-define Build/Compile/supplicant-full-internal
-	+$(call Build/RunMake,wpa_supplicant, \
-		eapol_test \
-	)
-endef
-
-define Build/Compile/supplicant-full-openssl
-	+$(call Build/RunMake,wpa_supplicant, \
-		eapol_test \
-	)
-endef
-
-define Build/Compile/supplicant-full-wolfssl
-	+$(call Build/RunMake,wpa_supplicant, \
-		eapol_test \
-	)
-endef
-
-define Build/Compile
-	$(Build/Compile/$(LOCAL_TYPE))
-	$(Build/Compile/$(BUILD_VARIANT))
-endef
-
-define Install/hostapd
-	$(INSTALL_DIR) $(1)/usr/sbin
-endef
-
-define Install/supplicant
-	$(INSTALL_DIR) $(1)/usr/sbin
-endef
-
-define Package/hostapd-common/install
-	$(INSTALL_DIR) $(1)/etc/capabilities $(1)/etc/rc.button $(1)/etc/hotplug.d/ieee80211 $(1)/etc/init.d $(1)/lib/netifd  $(1)/usr/share/acl.d
-	$(INSTALL_DATA) ./files/hostapd.sh $(1)/lib/netifd/hostapd.sh
-	$(INSTALL_BIN) ./files/wpad.init $(1)/etc/init.d/wpad
-	$(INSTALL_BIN) ./files/wps-hotplug.sh $(1)/etc/rc.button/wps
-	$(INSTALL_DATA) ./files/wpad_acl.json $(1)/usr/share/acl.d
-	$(INSTALL_DATA) ./files/wpad.json $(1)/etc/capabilities
-endef
-
-define Package/hostapd/install
-	$(call Install/hostapd,$(1))
-	$(INSTALL_BIN) $(PKG_BUILD_DIR)/hostapd/hostapd $(1)/usr/sbin/
-endef
-Package/hostapd-basic/install = $(Package/hostapd/install)
-Package/hostapd-basic-openssl/install = $(Package/hostapd/install)
-Package/hostapd-basic-wolfssl/install = $(Package/hostapd/install)
-Package/hostapd-mini/install = $(Package/hostapd/install)
-Package/hostapd-openssl/install = $(Package/hostapd/install)
-Package/hostapd-wolfssl/install = $(Package/hostapd/install)
-
-ifneq ($(LOCAL_TYPE),supplicant)
-  define Package/hostapd-utils/install
-	$(INSTALL_DIR) $(1)/usr/sbin
-	$(INSTALL_BIN) $(PKG_BUILD_DIR)/hostapd/hostapd_cli $(1)/usr/sbin/
-  endef
-endif
-
-define Package/wpad/install
-	$(call Install/hostapd,$(1))
-	$(call Install/supplicant,$(1))
-	$(INSTALL_BIN) $(PKG_BUILD_DIR)/wpad $(1)/usr/sbin/
-	$(LN) wpad $(1)/usr/sbin/hostapd
-	$(LN) wpad $(1)/usr/sbin/wpa_supplicant
-endef
-Package/wpad-basic/install = $(Package/wpad/install)
-Package/wpad-basic-openssl/install = $(Package/wpad/install)
-Package/wpad-basic-wolfssl/install = $(Package/wpad/install)
-Package/wpad-mini/install = $(Package/wpad/install)
-Package/wpad-openssl/install = $(Package/wpad/install)
-Package/wpad-wolfssl/install = $(Package/wpad/install)
-Package/wpad-mesh-openssl/install = $(Package/wpad/install)
-Package/wpad-mesh-wolfssl/install = $(Package/wpad/install)
-
-define Package/wpa-supplicant/install
-	$(call Install/supplicant,$(1))
-	$(INSTALL_BIN) $(PKG_BUILD_DIR)/wpa_supplicant/wpa_supplicant $(1)/usr/sbin/
-endef
-Package/wpa-supplicant-basic/install = $(Package/wpa-supplicant/install)
-Package/wpa-supplicant-mini/install = $(Package/wpa-supplicant/install)
-Package/wpa-supplicant-p2p/install = $(Package/wpa-supplicant/install)
-Package/wpa-supplicant-openssl/install = $(Package/wpa-supplicant/install)
-Package/wpa-supplicant-wolfssl/install = $(Package/wpa-supplicant/install)
-Package/wpa-supplicant-mesh-openssl/install = $(Package/wpa-supplicant/install)
-Package/wpa-supplicant-mesh-wolfssl/install = $(Package/wpa-supplicant/install)
-
-ifneq ($(LOCAL_TYPE),hostapd)
-  define Package/wpa-cli/install
-	$(INSTALL_DIR) $(1)/usr/sbin
-	$(CP) $(PKG_BUILD_DIR)/wpa_supplicant/wpa_cli $(1)/usr/sbin/
-  endef
-endif
-
-ifeq ($(BUILD_VARIANT),supplicant-full-internal)
-  define Package/eapol-test/install
-	$(INSTALL_DIR) $(1)/usr/sbin
-	$(CP) $(PKG_BUILD_DIR)/wpa_supplicant/eapol_test $(1)/usr/sbin/
-  endef
-endif
-
-ifeq ($(BUILD_VARIANT),supplicant-full-openssl)
-  define Package/eapol-test-openssl/install
-	$(INSTALL_DIR) $(1)/usr/sbin
-	$(CP) $(PKG_BUILD_DIR)/wpa_supplicant/eapol_test $(1)/usr/sbin/
-  endef
-endif
-
-ifeq ($(BUILD_VARIANT),supplicant-full-wolfssl)
-  define Package/eapol-test-wolfssl/install
-	$(INSTALL_DIR) $(1)/usr/sbin
-	$(CP) $(PKG_BUILD_DIR)/wpa_supplicant/eapol_test $(1)/usr/sbin/
-  endef
-endif
-
-$(eval $(call BuildPackage,hostapd))
-$(eval $(call BuildPackage,hostapd-basic))
-$(eval $(call BuildPackage,hostapd-basic-openssl))
-$(eval $(call BuildPackage,hostapd-basic-wolfssl))
-$(eval $(call BuildPackage,hostapd-mini))
-$(eval $(call BuildPackage,hostapd-openssl))
-$(eval $(call BuildPackage,hostapd-wolfssl))
-$(eval $(call BuildPackage,wpad))
-$(eval $(call BuildPackage,wpad-mesh-openssl))
-$(eval $(call BuildPackage,wpad-mesh-wolfssl))
-$(eval $(call BuildPackage,wpad-basic))
-$(eval $(call BuildPackage,wpad-basic-openssl))
-$(eval $(call BuildPackage,wpad-basic-wolfssl))
-$(eval $(call BuildPackage,wpad-mini))
-$(eval $(call BuildPackage,wpad-openssl))
-$(eval $(call BuildPackage,wpad-wolfssl))
-$(eval $(call BuildPackage,wpa-supplicant))
-$(eval $(call BuildPackage,wpa-supplicant-mesh-openssl))
-$(eval $(call BuildPackage,wpa-supplicant-mesh-wolfssl))
-$(eval $(call BuildPackage,wpa-supplicant-basic))
-$(eval $(call BuildPackage,wpa-supplicant-mini))
-$(eval $(call BuildPackage,wpa-supplicant-p2p))
-$(eval $(call BuildPackage,wpa-supplicant-openssl))
-$(eval $(call BuildPackage,wpa-supplicant-wolfssl))
-$(eval $(call BuildPackage,wpa-cli))
-$(eval $(call BuildPackage,hostapd-utils))
-$(eval $(call BuildPackage,hostapd-common))
-$(eval $(call BuildPackage,eapol-test))
-$(eval $(call BuildPackage,eapol-test-openssl))
-$(eval $(call BuildPackage,eapol-test-wolfssl))
diff --git a/package/network/services/hostapd/files/hostapd-basic.config b/package/network/services/hostapd/files/hostapd-basic.config
deleted file mode 100644
index 33c38192b1..0000000000
--- a/package/network/services/hostapd/files/hostapd-basic.config
+++ /dev/null
@@ -1,401 +0,0 @@
-# Example hostapd build time configuration
-#
-# This file lists the configuration options that are used when building the
-# hostapd binary. All lines starting with # are ignored. Configuration option
-# lines must be commented out complete, if they are not to be included, i.e.,
-# just setting VARIABLE=n is not disabling that variable.
-#
-# This file is included in Makefile, so variables like CFLAGS and LIBS can also
-# be modified from here. In most cass, these lines should use += in order not
-# to override previous values of the variables.
-
-# Driver interface for Host AP driver
-#CONFIG_DRIVER_HOSTAP=y
-
-# Driver interface for wired authenticator
-CONFIG_DRIVER_WIRED=y
-
-# Driver interface for drivers using the nl80211 kernel interface
-CONFIG_DRIVER_NL80211=y
-
-# QCA vendor extensions to nl80211
-#CONFIG_DRIVER_NL80211_QCA=y
-
-# driver_nl80211.c requires libnl. If you are compiling it yourself
-# you may need to point hostapd to your version of libnl.
-#
-#CFLAGS += -I$<path to libnl include files>
-#LIBS += -L$<path to libnl library files>
-
-# Use libnl v2.0 (or 3.0) libraries.
-#CONFIG_LIBNL20=y
-
-# Use libnl 3.2 libraries (if this is selected, CONFIG_LIBNL20 is ignored)
-#CONFIG_LIBNL32=y
-
-
-# Driver interface for FreeBSD net80211 layer (e.g., Atheros driver)
-#CONFIG_DRIVER_BSD=y
-#CFLAGS += -I/usr/local/include
-#LIBS += -L/usr/local/lib
-#LIBS_p += -L/usr/local/lib
-#LIBS_c += -L/usr/local/lib
-
-# Driver interface for no driver (e.g., RADIUS server only)
-#CONFIG_DRIVER_NONE=y
-
-# IEEE 802.11F/IAPP
-#CONFIG_IAPP=y
-
-# WPA2/IEEE 802.11i RSN pre-authentication
-CONFIG_RSN_PREAUTH=y
-
-# IEEE 802.11w (management frame protection)
-#CONFIG_IEEE80211W=y
-
-# Support Operating Channel Validation
-#CONFIG_OCV=y
-
-# Integrated EAP server
-#CONFIG_EAP=y
-
-# EAP Re-authentication Protocol (ERP) in integrated EAP server
-#CONFIG_ERP=y
-
-# EAP-MD5 for the integrated EAP server
-#CONFIG_EAP_MD5=y
-
-# EAP-TLS for the integrated EAP server
-#CONFIG_EAP_TLS=y
-
-# EAP-MSCHAPv2 for the integrated EAP server
-#CONFIG_EAP_MSCHAPV2=y
-
-# EAP-PEAP for the integrated EAP server
-#CONFIG_EAP_PEAP=y
-
-# EAP-GTC for the integrated EAP server
-#CONFIG_EAP_GTC=y
-
-# EAP-TTLS for the integrated EAP server
-#CONFIG_EAP_TTLS=y
-
-# EAP-SIM for the integrated EAP server
-#CONFIG_EAP_SIM=y
-
-# EAP-AKA for the integrated EAP server
-#CONFIG_EAP_AKA=y
-
-# EAP-AKA' for the integrated EAP server
-# This requires CONFIG_EAP_AKA to be enabled, too.
-#CONFIG_EAP_AKA_PRIME=y
-
-# EAP-PAX for the integrated EAP server
-#CONFIG_EAP_PAX=y
-
-# EAP-PSK for the integrated EAP server (this is _not_ needed for WPA-PSK)
-#CONFIG_EAP_PSK=y
-
-# EAP-pwd for the integrated EAP server (secure authentication with a password)
-#CONFIG_EAP_PWD=y
-
-# EAP-SAKE for the integrated EAP server
-#CONFIG_EAP_SAKE=y
-
-# EAP-GPSK for the integrated EAP server
-#CONFIG_EAP_GPSK=y
-# Include support for optional SHA256 cipher suite in EAP-GPSK
-#CONFIG_EAP_GPSK_SHA256=y
-
-# EAP-FAST for the integrated EAP server
-#CONFIG_EAP_FAST=y
-
-# EAP-TEAP for the integrated EAP server
-# Note: The current EAP-TEAP implementation is experimental and should not be
-# enabled for production use. The IETF RFC 7170 that defines EAP-TEAP has number
-# of conflicting statements and missing details and the implementation has
-# vendor specific workarounds for those and as such, may not interoperate with
-# any other implementation. This should not be used for anything else than
-# experimentation and interoperability testing until those issues has been
-# resolved.
-#CONFIG_EAP_TEAP=y
-
-# Wi-Fi Protected Setup (WPS)
-#CONFIG_WPS=y
-# Enable UPnP support for external WPS Registrars
-#CONFIG_WPS_UPNP=y
-# Enable WPS support with NFC config method
-#CONFIG_WPS_NFC=y
-
-# EAP-IKEv2
-#CONFIG_EAP_IKEV2=y
-
-# Trusted Network Connect (EAP-TNC)
-#CONFIG_EAP_TNC=y
-
-# EAP-EKE for the integrated EAP server
-#CONFIG_EAP_EKE=y
-
-# PKCS#12 (PFX) support (used to read private key and certificate file from
-# a file that usually has extension .p12 or .pfx)
-#CONFIG_PKCS12=y
-
-# RADIUS authentication server. This provides access to the integrated EAP
-# server from external hosts using RADIUS.
-#CONFIG_RADIUS_SERVER=y
-
-# Build IPv6 support for RADIUS operations
-#CONFIG_IPV6=y
-
-# IEEE Std 802.11r-2008 (Fast BSS Transition)
-CONFIG_IEEE80211R=y
-
-# Use the hostapd's IEEE 802.11 authentication (ACL), but without
-# the IEEE 802.11 Management capability (e.g., FreeBSD/net80211)
-#CONFIG_DRIVER_RADIUS_ACL=y
-
-# IEEE 802.11n (High Throughput) support
-CONFIG_IEEE80211N=y
-
-# Wireless Network Management (IEEE Std 802.11v-2011)
-# Note: This is experimental and not complete implementation.
-#CONFIG_WNM=y
-
-# IEEE 802.11ac (Very High Throughput) support
-CONFIG_IEEE80211AC=y
-
-# IEEE 802.11ax HE support
-# Note: This is experimental and work in progress. The definitions are still
-# subject to change and this should not be expected to interoperate with the
-# final IEEE 802.11ax version.
-#CONFIG_IEEE80211AX=y
-
-# Remove debugging code that is printing out debug messages to stdout.
-# This can be used to reduce the size of the hostapd considerably if debugging
-# code is not needed.
-#CONFIG_NO_STDOUT_DEBUG=y
-
-# Add support for writing debug log to a file: -f /tmp/hostapd.log
-# Disabled by default.
-#CONFIG_DEBUG_FILE=y
-
-# Send debug messages to syslog instead of stdout
-CONFIG_DEBUG_SYSLOG=y
-
-# Add support for sending all debug messages (regardless of debug verbosity)
-# to the Linux kernel tracing facility. This helps debug the entire stack by
-# making it easy to record everything happening from the driver up into the
-# same file, e.g., using trace-cmd.
-#CONFIG_DEBUG_LINUX_TRACING=y
-
-# Remove support for RADIUS accounting
-CONFIG_NO_ACCOUNTING=y
-
-# Remove support for RADIUS
-CONFIG_NO_RADIUS=y
-
-# Remove support for VLANs
-#CONFIG_NO_VLAN=y
-
-# Enable support for fully dynamic VLANs. This enables hostapd to
-# automatically create bridge and VLAN interfaces if necessary.
-#CONFIG_FULL_DYNAMIC_VLAN=y
-
-# Use netlink-based kernel API for VLAN operations instead of ioctl()
-# Note: This requires libnl 3.1 or newer.
-#CONFIG_VLAN_NETLINK=y
-
-# Remove support for dumping internal state through control interface commands
-# This can be used to reduce binary size at the cost of disabling a debugging
-# option.
-CONFIG_NO_DUMP_STATE=y
-
-# Enable tracing code for developer debugging
-# This tracks use of memory allocations and other registrations and reports
-# incorrect use with a backtrace of call (or allocation) location.
-#CONFIG_WPA_TRACE=y
-# For BSD, comment out these.
-#LIBS += -lexecinfo
-#LIBS_p += -lexecinfo
-#LIBS_c += -lexecinfo
-
-# Use libbfd to get more details for developer debugging
-# This enables use of libbfd to get more detailed symbols for the backtraces
-# generated by CONFIG_WPA_TRACE=y.
-#CONFIG_WPA_TRACE_BFD=y
-# For BSD, comment out these.
-#LIBS += -lbfd -liberty -lz
-#LIBS_p += -lbfd -liberty -lz
-#LIBS_c += -lbfd -liberty -lz
-
-# hostapd depends on strong random number generation being available from the
-# operating system. os_get_random() function is used to fetch random data when
-# needed, e.g., for key generation. On Linux and BSD systems, this works by
-# reading /dev/urandom. It should be noted that the OS entropy pool needs to be
-# properly initialized before hostapd is started. This is important especially
-# on embedded devices that do not have a hardware random number generator and
-# may by default start up with minimal entropy available for random number
-# generation.
-#
-# As a safety net, hostapd is by default trying to internally collect
-# additional entropy for generating random data to mix in with the data
-# fetched from the OS. This by itself is not considered to be very strong, but
-# it may help in cases where the system pool is not initialized properly.
-# However, it is very strongly recommended that the system pool is initialized
-# with enough entropy either by using hardware assisted random number
-# generator or by storing state over device reboots.
-#
-# hostapd can be configured to maintain its own entropy store over restarts to
-# enhance random number generation. This is not perfect, but it is much more
-# secure than using the same sequence of random numbers after every reboot.
-# This can be enabled with -e<entropy file> command line option. The specified
-# file needs to be readable and writable by hostapd.
-#
-# If the os_get_random() is known to provide strong random data (e.g., on
-# Linux/BSD, the board in question is known to have reliable source of random
-# data from /dev/urandom), the internal hostapd random pool can be disabled.
-# This will save some in binary size and CPU use. However, this should only be
-# considered for builds that are known to be used on devices that meet the
-# requirements described above.
-CONFIG_NO_RANDOM_POOL=y
-
-# Should we attempt to use the getrandom(2) call that provides more reliable
-# yet secure randomness source than /dev/random on Linux 3.17 and newer.
-# Requires glibc 2.25 to build, falls back to /dev/random if unavailable.
-CONFIG_GETRANDOM=y
-
-# Should we use poll instead of select? Select is used by default.
-#CONFIG_ELOOP_POLL=y
-
-# Should we use epoll instead of select? Select is used by default.
-CONFIG_ELOOP_EPOLL=y
-
-# Should we use kqueue instead of select? Select is used by default.
-#CONFIG_ELOOP_KQUEUE=y
-
-# Select TLS implementation
-# openssl = OpenSSL (default)
-# gnutls = GnuTLS
-# internal = Internal TLSv1 implementation (experimental)
-# linux = Linux kernel AF_ALG and internal TLSv1 implementation (experimental)
-# none = Empty template
-CONFIG_TLS=internal
-
-# TLS-based EAP methods require at least TLS v1.0. Newer version of TLS (v1.1)
-# can be enabled to get a stronger construction of messages when block ciphers
-# are used.
-#CONFIG_TLSV11=y
-
-# TLS-based EAP methods require at least TLS v1.0. Newer version of TLS (v1.2)
-# can be enabled to enable use of stronger crypto algorithms.
-#CONFIG_TLSV12=y
-
-# Select which ciphers to use by default with OpenSSL if the user does not
-# specify them.
-#CONFIG_TLS_DEFAULT_CIPHERS="DEFAULT:!EXP:!LOW"
-
-# If CONFIG_TLS=internal is used, additional library and include paths are
-# needed for LibTomMath. Alternatively, an integrated, minimal version of
-# LibTomMath can be used. See beginning of libtommath.c for details on benefits
-# and drawbacks of this option.
-#CONFIG_INTERNAL_LIBTOMMATH=y
-#ifndef CONFIG_INTERNAL_LIBTOMMATH
-#LTM_PATH=/usr/src/libtommath-0.39
-#CFLAGS += -I$(LTM_PATH)
-#LIBS += -L$(LTM_PATH)
-#LIBS_p += -L$(LTM_PATH)
-#endif
-# At the cost of about 4 kB of additional binary size, the internal LibTomMath
-# can be configured to include faster routines for exptmod, sqr, and div to
-# speed up DH and RSA calculation considerably
-#CONFIG_INTERNAL_LIBTOMMATH_FAST=y
-
-# Interworking (IEEE 802.11u)
-# This can be used to enable functionality to improve interworking with
-# external networks.
-#CONFIG_INTERWORKING=y
-
-# Hotspot 2.0
-#CONFIG_HS20=y
-
-# Enable SQLite database support in hlr_auc_gw, EAP-SIM DB, and eap_user_file
-#CONFIG_SQLITE=y
-
-# Enable Fast Session Transfer (FST)
-#CONFIG_FST=y
-
-# Enable CLI commands for FST testing
-#CONFIG_FST_TEST=y
-
-# Testing options
-# This can be used to enable some testing options (see also the example
-# configuration file) that are really useful only for testing clients that
-# connect to this hostapd. These options allow, for example, to drop a
-# certain percentage of probe requests or auth/(re)assoc frames.
-#
-#CONFIG_TESTING_OPTIONS=y
-
-# Automatic Channel Selection
-# This will allow hostapd to pick the channel automatically when channel is set
-# to "acs_survey" or "0". Eventually, other ACS algorithms can be added in
-# similar way.
-#
-# Automatic selection is currently only done through initialization, later on
-# we hope to do background checks to keep us moving to more ideal channels as
-# time goes by. ACS is currently only supported through the nl80211 driver and
-# your driver must have survey dump capability that is filled by the driver
-# during scanning.
-#
-# You can customize the ACS survey algorithm with the hostapd.conf variable
-# acs_num_scans.
-#
-# Supported ACS drivers:
-# * ath9k
-# * ath5k
-# * ath10k
-#
-# For more details refer to:
-# http://wireless.kernel.org/en/users/Documentation/acs
-#
-#CONFIG_ACS=y
-
-# Multiband Operation support
-# These extentions facilitate efficient use of multiple frequency bands
-# available to the AP and the devices that may associate with it.
-#CONFIG_MBO=y
-
-# Client Taxonomy
-# Has the AP retain the Probe Request and (Re)Association Request frames from
-# a client, from which a signature can be produced which can identify the model
-# of client device like "Nexus 6P" or "iPhone 5s".
-#CONFIG_TAXONOMY=y
-
-# Fast Initial Link Setup (FILS) (IEEE 802.11ai)
-#CONFIG_FILS=y
-# FILS shared key authentication with PFS
-#CONFIG_FILS_SK_PFS=y
-
-# Include internal line edit mode in hostapd_cli. This can be used to provide
-# limited command line editing and history support.
-#CONFIG_WPA_CLI_EDIT=y
-
-# Opportunistic Wireless Encryption (OWE)
-# Experimental implementation of draft-harkins-owe-07.txt
-#CONFIG_OWE=y
-
-# Airtime policy support
-CONFIG_AIRTIME_POLICY=y
-
-# Override default value for the wpa_disable_eapol_key_retries configuration
-# parameter. See that parameter in hostapd.conf for more details.
-#CFLAGS += -DDEFAULT_WPA_DISABLE_EAPOL_KEY_RETRIES=1
-
-# uBus IPC/RPC System
-# Services can connect to the bus and provide methods
-# that can be called by other services or clients.
-CONFIG_UBUS=y
-
-# OpenWrt patch 380-disable-ctrl-iface-mib.patch
-# leads to the MIB only being compiled in if
-# CONFIG_CTRL_IFACE_MIB is enabled.
-#CONFIG_CTRL_IFACE_MIB=y
diff --git a/package/network/services/hostapd/files/hostapd-full.config b/package/network/services/hostapd/files/hostapd-full.config
deleted file mode 100644
index df272e443a..0000000000
--- a/package/network/services/hostapd/files/hostapd-full.config
+++ /dev/null
@@ -1,401 +0,0 @@
-# Example hostapd build time configuration
-#
-# This file lists the configuration options that are used when building the
-# hostapd binary. All lines starting with # are ignored. Configuration option
-# lines must be commented out complete, if they are not to be included, i.e.,
-# just setting VARIABLE=n is not disabling that variable.
-#
-# This file is included in Makefile, so variables like CFLAGS and LIBS can also
-# be modified from here. In most cass, these lines should use += in order not
-# to override previous values of the variables.
-
-# Driver interface for Host AP driver
-#CONFIG_DRIVER_HOSTAP=y
-
-# Driver interface for wired authenticator
-CONFIG_DRIVER_WIRED=y
-
-# Driver interface for drivers using the nl80211 kernel interface
-CONFIG_DRIVER_NL80211=y
-
-# QCA vendor extensions to nl80211
-#CONFIG_DRIVER_NL80211_QCA=y
-
-# driver_nl80211.c requires libnl. If you are compiling it yourself
-# you may need to point hostapd to your version of libnl.
-#
-#CFLAGS += -I$<path to libnl include files>
-#LIBS += -L$<path to libnl library files>
-
-# Use libnl v2.0 (or 3.0) libraries.
-#CONFIG_LIBNL20=y
-
-# Use libnl 3.2 libraries (if this is selected, CONFIG_LIBNL20 is ignored)
-#CONFIG_LIBNL32=y
-
-
-# Driver interface for FreeBSD net80211 layer (e.g., Atheros driver)
-#CONFIG_DRIVER_BSD=y
-#CFLAGS += -I/usr/local/include
-#LIBS += -L/usr/local/lib
-#LIBS_p += -L/usr/local/lib
-#LIBS_c += -L/usr/local/lib
-
-# Driver interface for no driver (e.g., RADIUS server only)
-#CONFIG_DRIVER_NONE=y
-
-# IEEE 802.11F/IAPP
-CONFIG_IAPP=y
-
-# WPA2/IEEE 802.11i RSN pre-authentication
-CONFIG_RSN_PREAUTH=y
-
-# IEEE 802.11w (management frame protection)
-#CONFIG_IEEE80211W=y
-
-# Support Operating Channel Validation
-#CONFIG_OCV=y
-
-# Integrated EAP server
-CONFIG_EAP=y
-
-# EAP Re-authentication Protocol (ERP) in integrated EAP server
-#CONFIG_ERP=y
-
-# EAP-MD5 for the integrated EAP server
-CONFIG_EAP_MD5=y
-
-# EAP-TLS for the integrated EAP server
-CONFIG_EAP_TLS=y
-
-# EAP-MSCHAPv2 for the integrated EAP server
-CONFIG_EAP_MSCHAPV2=y
-
-# EAP-PEAP for the integrated EAP server
-CONFIG_EAP_PEAP=y
-
-# EAP-GTC for the integrated EAP server
-CONFIG_EAP_GTC=y
-
-# EAP-TTLS for the integrated EAP server
-CONFIG_EAP_TTLS=y
-
-# EAP-SIM for the integrated EAP server
-#CONFIG_EAP_SIM=y
-
-# EAP-AKA for the integrated EAP server
-#CONFIG_EAP_AKA=y
-
-# EAP-AKA' for the integrated EAP server
-# This requires CONFIG_EAP_AKA to be enabled, too.
-#CONFIG_EAP_AKA_PRIME=y
-
-# EAP-PAX for the integrated EAP server
-#CONFIG_EAP_PAX=y
-
-# EAP-PSK for the integrated EAP server (this is _not_ needed for WPA-PSK)
-#CONFIG_EAP_PSK=y
-
-# EAP-pwd for the integrated EAP server (secure authentication with a password)
-#CONFIG_EAP_PWD=y
-
-# EAP-SAKE for the integrated EAP server
-#CONFIG_EAP_SAKE=y
-
-# EAP-GPSK for the integrated EAP server
-#CONFIG_EAP_GPSK=y
-# Include support for optional SHA256 cipher suite in EAP-GPSK
-#CONFIG_EAP_GPSK_SHA256=y
-
-# EAP-FAST for the integrated EAP server
-CONFIG_EAP_FAST=y
-
-# EAP-TEAP for the integrated EAP server
-# Note: The current EAP-TEAP implementation is experimental and should not be
-# enabled for production use. The IETF RFC 7170 that defines EAP-TEAP has number
-# of conflicting statements and missing details and the implementation has
-# vendor specific workarounds for those and as such, may not interoperate with
-# any other implementation. This should not be used for anything else than
-# experimentation and interoperability testing until those issues has been
-# resolved.
-#CONFIG_EAP_TEAP=y
-
-# Wi-Fi Protected Setup (WPS)
-CONFIG_WPS=y
-# Enable UPnP support for external WPS Registrars
-#CONFIG_WPS_UPNP=y
-# Enable WPS support with NFC config method
-#CONFIG_WPS_NFC=y
-
-# EAP-IKEv2
-#CONFIG_EAP_IKEV2=y
-
-# Trusted Network Connect (EAP-TNC)
-#CONFIG_EAP_TNC=y
-
-# EAP-EKE for the integrated EAP server
-#CONFIG_EAP_EKE=y
-
-# PKCS#12 (PFX) support (used to read private key and certificate file from
-# a file that usually has extension .p12 or .pfx)
-CONFIG_PKCS12=y
-
-# RADIUS authentication server. This provides access to the integrated EAP
-# server from external hosts using RADIUS.
-#CONFIG_RADIUS_SERVER=y
-
-# Build IPv6 support for RADIUS operations
-CONFIG_IPV6=y
-
-# IEEE Std 802.11r-2008 (Fast BSS Transition)
-CONFIG_IEEE80211R=y
-
-# Use the hostapd's IEEE 802.11 authentication (ACL), but without
-# the IEEE 802.11 Management capability (e.g., FreeBSD/net80211)
-#CONFIG_DRIVER_RADIUS_ACL=y
-
-# IEEE 802.11n (High Throughput) support
-CONFIG_IEEE80211N=y
-
-# Wireless Network Management (IEEE Std 802.11v-2011)
-# Note: This is experimental and not complete implementation.
-CONFIG_WNM=y
-
-# IEEE 802.11ac (Very High Throughput) support
-CONFIG_IEEE80211AC=y
-
-# IEEE 802.11ax HE support
-# Note: This is experimental and work in progress. The definitions are still
-# subject to change and this should not be expected to interoperate with the
-# final IEEE 802.11ax version.
-#CONFIG_IEEE80211AX=y
-
-# Remove debugging code that is printing out debug messages to stdout.
-# This can be used to reduce the size of the hostapd considerably if debugging
-# code is not needed.
-#CONFIG_NO_STDOUT_DEBUG=y
-
-# Add support for writing debug log to a file: -f /tmp/hostapd.log
-# Disabled by default.
-#CONFIG_DEBUG_FILE=y
-
-# Send debug messages to syslog instead of stdout
-CONFIG_DEBUG_SYSLOG=y
-
-# Add support for sending all debug messages (regardless of debug verbosity)
-# to the Linux kernel tracing facility. This helps debug the entire stack by
-# making it easy to record everything happening from the driver up into the
-# same file, e.g., using trace-cmd.
-#CONFIG_DEBUG_LINUX_TRACING=y
-
-# Remove support for RADIUS accounting
-#CONFIG_NO_ACCOUNTING=y
-
-# Remove support for RADIUS
-#CONFIG_NO_RADIUS=y
-
-# Remove support for VLANs
-#CONFIG_NO_VLAN=y
-
-# Enable support for fully dynamic VLANs. This enables hostapd to
-# automatically create bridge and VLAN interfaces if necessary.
-CONFIG_FULL_DYNAMIC_VLAN=y
-
-# Use netlink-based kernel API for VLAN operations instead of ioctl()
-# Note: This requires libnl 3.1 or newer.
-#CONFIG_VLAN_NETLINK=y
-
-# Remove support for dumping internal state through control interface commands
-# This can be used to reduce binary size at the cost of disabling a debugging
-# option.
-CONFIG_NO_DUMP_STATE=y
-
-# Enable tracing code for developer debugging
-# This tracks use of memory allocations and other registrations and reports
-# incorrect use with a backtrace of call (or allocation) location.
-#CONFIG_WPA_TRACE=y
-# For BSD, comment out these.
-#LIBS += -lexecinfo
-#LIBS_p += -lexecinfo
-#LIBS_c += -lexecinfo
-
-# Use libbfd to get more details for developer debugging
-# This enables use of libbfd to get more detailed symbols for the backtraces
-# generated by CONFIG_WPA_TRACE=y.
-#CONFIG_WPA_TRACE_BFD=y
-# For BSD, comment out these.
-#LIBS += -lbfd -liberty -lz
-#LIBS_p += -lbfd -liberty -lz
-#LIBS_c += -lbfd -liberty -lz
-
-# hostapd depends on strong random number generation being available from the
-# operating system. os_get_random() function is used to fetch random data when
-# needed, e.g., for key generation. On Linux and BSD systems, this works by
-# reading /dev/urandom. It should be noted that the OS entropy pool needs to be
-# properly initialized before hostapd is started. This is important especially
-# on embedded devices that do not have a hardware random number generator and
-# may by default start up with minimal entropy available for random number
-# generation.
-#
-# As a safety net, hostapd is by default trying to internally collect
-# additional entropy for generating random data to mix in with the data
-# fetched from the OS. This by itself is not considered to be very strong, but
-# it may help in cases where the system pool is not initialized properly.
-# However, it is very strongly recommended that the system pool is initialized
-# with enough entropy either by using hardware assisted random number
-# generator or by storing state over device reboots.
-#
-# hostapd can be configured to maintain its own entropy store over restarts to
-# enhance random number generation. This is not perfect, but it is much more
-# secure than using the same sequence of random numbers after every reboot.
-# This can be enabled with -e<entropy file> command line option. The specified
-# file needs to be readable and writable by hostapd.
-#
-# If the os_get_random() is known to provide strong random data (e.g., on
-# Linux/BSD, the board in question is known to have reliable source of random
-# data from /dev/urandom), the internal hostapd random pool can be disabled.
-# This will save some in binary size and CPU use. However, this should only be
-# considered for builds that are known to be used on devices that meet the
-# requirements described above.
-CONFIG_NO_RANDOM_POOL=y
-
-# Should we attempt to use the getrandom(2) call that provides more reliable
-# yet secure randomness source than /dev/random on Linux 3.17 and newer.
-# Requires glibc 2.25 to build, falls back to /dev/random if unavailable.
-CONFIG_GETRANDOM=y
-
-# Should we use poll instead of select? Select is used by default.
-#CONFIG_ELOOP_POLL=y
-
-# Should we use epoll instead of select? Select is used by default.
-CONFIG_ELOOP_EPOLL=y
-
-# Should we use kqueue instead of select? Select is used by default.
-#CONFIG_ELOOP_KQUEUE=y
-
-# Select TLS implementation
-# openssl = OpenSSL (default)
-# gnutls = GnuTLS
-# internal = Internal TLSv1 implementation (experimental)
-# linux = Linux kernel AF_ALG and internal TLSv1 implementation (experimental)
-# none = Empty template
-CONFIG_TLS=internal
-
-# TLS-based EAP methods require at least TLS v1.0. Newer version of TLS (v1.1)
-# can be enabled to get a stronger construction of messages when block ciphers
-# are used.
-#CONFIG_TLSV11=y
-
-# TLS-based EAP methods require at least TLS v1.0. Newer version of TLS (v1.2)
-# can be enabled to enable use of stronger crypto algorithms.
-#CONFIG_TLSV12=y
-
-# Select which ciphers to use by default with OpenSSL if the user does not
-# specify them.
-#CONFIG_TLS_DEFAULT_CIPHERS="DEFAULT:!EXP:!LOW"
-
-# If CONFIG_TLS=internal is used, additional library and include paths are
-# needed for LibTomMath. Alternatively, an integrated, minimal version of
-# LibTomMath can be used. See beginning of libtommath.c for details on benefits
-# and drawbacks of this option.
-CONFIG_INTERNAL_LIBTOMMATH=y
-#ifndef CONFIG_INTERNAL_LIBTOMMATH
-#LTM_PATH=/usr/src/libtommath-0.39
-#CFLAGS += -I$(LTM_PATH)
-#LIBS += -L$(LTM_PATH)
-#LIBS_p += -L$(LTM_PATH)
-#endif
-# At the cost of about 4 kB of additional binary size, the internal LibTomMath
-# can be configured to include faster routines for exptmod, sqr, and div to
-# speed up DH and RSA calculation considerably
-#CONFIG_INTERNAL_LIBTOMMATH_FAST=y
-
-# Interworking (IEEE 802.11u)
-# This can be used to enable functionality to improve interworking with
-# external networks.
-CONFIG_INTERWORKING=y
-
-# Hotspot 2.0
-#CONFIG_HS20=y
-
-# Enable SQLite database support in hlr_auc_gw, EAP-SIM DB, and eap_user_file
-#CONFIG_SQLITE=y
-
-# Enable Fast Session Transfer (FST)
-#CONFIG_FST=y
-
-# Enable CLI commands for FST testing
-#CONFIG_FST_TEST=y
-
-# Testing options
-# This can be used to enable some testing options (see also the example
-# configuration file) that are really useful only for testing clients that
-# connect to this hostapd. These options allow, for example, to drop a
-# certain percentage of probe requests or auth/(re)assoc frames.
-#
-#CONFIG_TESTING_OPTIONS=y
-
-# Automatic Channel Selection
-# This will allow hostapd to pick the channel automatically when channel is set
-# to "acs_survey" or "0". Eventually, other ACS algorithms can be added in
-# similar way.
-#
-# Automatic selection is currently only done through initialization, later on
-# we hope to do background checks to keep us moving to more ideal channels as
-# time goes by. ACS is currently only supported through the nl80211 driver and
-# your driver must have survey dump capability that is filled by the driver
-# during scanning.
-#
-# You can customize the ACS survey algorithm with the hostapd.conf variable
-# acs_num_scans.
-#
-# Supported ACS drivers:
-# * ath9k
-# * ath5k
-# * ath10k
-#
-# For more details refer to:
-# http://wireless.kernel.org/en/users/Documentation/acs
-#
-#CONFIG_ACS=y
-
-# Multiband Operation support
-# These extentions facilitate efficient use of multiple frequency bands
-# available to the AP and the devices that may associate with it.
-#CONFIG_MBO=y
-
-# Client Taxonomy
-# Has the AP retain the Probe Request and (Re)Association Request frames from
-# a client, from which a signature can be produced which can identify the model
-# of client device like "Nexus 6P" or "iPhone 5s".
-CONFIG_TAXONOMY=y
-
-# Fast Initial Link Setup (FILS) (IEEE 802.11ai)
-#CONFIG_FILS=y
-# FILS shared key authentication with PFS
-#CONFIG_FILS_SK_PFS=y
-
-# Include internal line edit mode in hostapd_cli. This can be used to provide
-# limited command line editing and history support.
-#CONFIG_WPA_CLI_EDIT=y
-
-# Opportunistic Wireless Encryption (OWE)
-# Experimental implementation of draft-harkins-owe-07.txt
-#CONFIG_OWE=y
-
-# Airtime policy support
-CONFIG_AIRTIME_POLICY=y
-
-# Override default value for the wpa_disable_eapol_key_retries configuration
-# parameter. See that parameter in hostapd.conf for more details.
-#CFLAGS += -DDEFAULT_WPA_DISABLE_EAPOL_KEY_RETRIES=1
-
-# uBus IPC/RPC System
-# Services can connect to the bus and provide methods
-# that can be called by other services or clients.
-CONFIG_UBUS=y
-
-# OpenWrt patch 380-disable-ctrl-iface-mib.patch
-# leads to the MIB only being compiled in if
-# CONFIG_CTRL_IFACE_MIB is enabled.
-CONFIG_CTRL_IFACE_MIB=y
diff --git a/package/network/services/hostapd/files/hostapd-mini.config b/package/network/services/hostapd/files/hostapd-mini.config
deleted file mode 100644
index b3050f7bbc..0000000000
--- a/package/network/services/hostapd/files/hostapd-mini.config
+++ /dev/null
@@ -1,401 +0,0 @@
-# Example hostapd build time configuration
-#
-# This file lists the configuration options that are used when building the
-# hostapd binary. All lines starting with # are ignored. Configuration option
-# lines must be commented out complete, if they are not to be included, i.e.,
-# just setting VARIABLE=n is not disabling that variable.
-#
-# This file is included in Makefile, so variables like CFLAGS and LIBS can also
-# be modified from here. In most cass, these lines should use += in order not
-# to override previous values of the variables.
-
-# Driver interface for Host AP driver
-#CONFIG_DRIVER_HOSTAP=y
-
-# Driver interface for wired authenticator
-CONFIG_DRIVER_WIRED=y
-
-# Driver interface for drivers using the nl80211 kernel interface
-CONFIG_DRIVER_NL80211=y
-
-# QCA vendor extensions to nl80211
-#CONFIG_DRIVER_NL80211_QCA=y
-
-# driver_nl80211.c requires libnl. If you are compiling it yourself
-# you may need to point hostapd to your version of libnl.
-#
-#CFLAGS += -I$<path to libnl include files>
-#LIBS += -L$<path to libnl library files>
-
-# Use libnl v2.0 (or 3.0) libraries.
-#CONFIG_LIBNL20=y
-
-# Use libnl 3.2 libraries (if this is selected, CONFIG_LIBNL20 is ignored)
-#CONFIG_LIBNL32=y
-
-
-# Driver interface for FreeBSD net80211 layer (e.g., Atheros driver)
-#CONFIG_DRIVER_BSD=y
-#CFLAGS += -I/usr/local/include
-#LIBS += -L/usr/local/lib
-#LIBS_p += -L/usr/local/lib
-#LIBS_c += -L/usr/local/lib
-
-# Driver interface for no driver (e.g., RADIUS server only)
-#CONFIG_DRIVER_NONE=y
-
-# IEEE 802.11F/IAPP
-#CONFIG_IAPP=y
-
-# WPA2/IEEE 802.11i RSN pre-authentication
-CONFIG_RSN_PREAUTH=y
-
-# IEEE 802.11w (management frame protection)
-#CONFIG_IEEE80211W=y
-
-# Support Operating Channel Validation
-#CONFIG_OCV=y
-
-# Integrated EAP server
-#CONFIG_EAP=y
-
-# EAP Re-authentication Protocol (ERP) in integrated EAP server
-#CONFIG_ERP=y
-
-# EAP-MD5 for the integrated EAP server
-#CONFIG_EAP_MD5=y
-
-# EAP-TLS for the integrated EAP server
-#CONFIG_EAP_TLS=y
-
-# EAP-MSCHAPv2 for the integrated EAP server
-#CONFIG_EAP_MSCHAPV2=y
-
-# EAP-PEAP for the integrated EAP server
-#CONFIG_EAP_PEAP=y
-
-# EAP-GTC for the integrated EAP server
-#CONFIG_EAP_GTC=y
-
-# EAP-TTLS for the integrated EAP server
-#CONFIG_EAP_TTLS=y
-
-# EAP-SIM for the integrated EAP server
-#CONFIG_EAP_SIM=y
-
-# EAP-AKA for the integrated EAP server
-#CONFIG_EAP_AKA=y
-
-# EAP-AKA' for the integrated EAP server
-# This requires CONFIG_EAP_AKA to be enabled, too.
-#CONFIG_EAP_AKA_PRIME=y
-
-# EAP-PAX for the integrated EAP server
-#CONFIG_EAP_PAX=y
-
-# EAP-PSK for the integrated EAP server (this is _not_ needed for WPA-PSK)
-#CONFIG_EAP_PSK=y
-
-# EAP-pwd for the integrated EAP server (secure authentication with a password)
-#CONFIG_EAP_PWD=y
-
-# EAP-SAKE for the integrated EAP server
-#CONFIG_EAP_SAKE=y
-
-# EAP-GPSK for the integrated EAP server
-#CONFIG_EAP_GPSK=y
-# Include support for optional SHA256 cipher suite in EAP-GPSK
-#CONFIG_EAP_GPSK_SHA256=y
-
-# EAP-FAST for the integrated EAP server
-#CONFIG_EAP_FAST=y
-
-# EAP-TEAP for the integrated EAP server
-# Note: The current EAP-TEAP implementation is experimental and should not be
-# enabled for production use. The IETF RFC 7170 that defines EAP-TEAP has number
-# of conflicting statements and missing details and the implementation has
-# vendor specific workarounds for those and as such, may not interoperate with
-# any other implementation. This should not be used for anything else than
-# experimentation and interoperability testing until those issues has been
-# resolved.
-#CONFIG_EAP_TEAP=y
-
-# Wi-Fi Protected Setup (WPS)
-#CONFIG_WPS=y
-# Enable UPnP support for external WPS Registrars
-#CONFIG_WPS_UPNP=y
-# Enable WPS support with NFC config method
-#CONFIG_WPS_NFC=y
-
-# EAP-IKEv2
-#CONFIG_EAP_IKEV2=y
-
-# Trusted Network Connect (EAP-TNC)
-#CONFIG_EAP_TNC=y
-
-# EAP-EKE for the integrated EAP server
-#CONFIG_EAP_EKE=y
-
-# PKCS#12 (PFX) support (used to read private key and certificate file from
-# a file that usually has extension .p12 or .pfx)
-#CONFIG_PKCS12=y
-
-# RADIUS authentication server. This provides access to the integrated EAP
-# server from external hosts using RADIUS.
-#CONFIG_RADIUS_SERVER=y
-
-# Build IPv6 support for RADIUS operations
-#CONFIG_IPV6=y
-
-# IEEE Std 802.11r-2008 (Fast BSS Transition)
-#CONFIG_IEEE80211R=y
-
-# Use the hostapd's IEEE 802.11 authentication (ACL), but without
-# the IEEE 802.11 Management capability (e.g., FreeBSD/net80211)
-#CONFIG_DRIVER_RADIUS_ACL=y
-
-# IEEE 802.11n (High Throughput) support
-CONFIG_IEEE80211N=y
-
-# Wireless Network Management (IEEE Std 802.11v-2011)
-# Note: This is experimental and not complete implementation.
-#CONFIG_WNM=y
-
-# IEEE 802.11ac (Very High Throughput) support
-CONFIG_IEEE80211AC=y
-
-# IEEE 802.11ax HE support
-# Note: This is experimental and work in progress. The definitions are still
-# subject to change and this should not be expected to interoperate with the
-# final IEEE 802.11ax version.
-#CONFIG_IEEE80211AX=y
-
-# Remove debugging code that is printing out debug messages to stdout.
-# This can be used to reduce the size of the hostapd considerably if debugging
-# code is not needed.
-#CONFIG_NO_STDOUT_DEBUG=y
-
-# Add support for writing debug log to a file: -f /tmp/hostapd.log
-# Disabled by default.
-#CONFIG_DEBUG_FILE=y
-
-# Send debug messages to syslog instead of stdout
-CONFIG_DEBUG_SYSLOG=y
-
-# Add support for sending all debug messages (regardless of debug verbosity)
-# to the Linux kernel tracing facility. This helps debug the entire stack by
-# making it easy to record everything happening from the driver up into the
-# same file, e.g., using trace-cmd.
-#CONFIG_DEBUG_LINUX_TRACING=y
-
-# Remove support for RADIUS accounting
-CONFIG_NO_ACCOUNTING=y
-
-# Remove support for RADIUS
-CONFIG_NO_RADIUS=y
-
-# Remove support for VLANs
-#CONFIG_NO_VLAN=y
-
-# Enable support for fully dynamic VLANs. This enables hostapd to
-# automatically create bridge and VLAN interfaces if necessary.
-#CONFIG_FULL_DYNAMIC_VLAN=y
-
-# Use netlink-based kernel API for VLAN operations instead of ioctl()
-# Note: This requires libnl 3.1 or newer.
-#CONFIG_VLAN_NETLINK=y
-
-# Remove support for dumping internal state through control interface commands
-# This can be used to reduce binary size at the cost of disabling a debugging
-# option.
-CONFIG_NO_DUMP_STATE=y
-
-# Enable tracing code for developer debugging
-# This tracks use of memory allocations and other registrations and reports
-# incorrect use with a backtrace of call (or allocation) location.
-#CONFIG_WPA_TRACE=y
-# For BSD, comment out these.
-#LIBS += -lexecinfo
-#LIBS_p += -lexecinfo
-#LIBS_c += -lexecinfo
-
-# Use libbfd to get more details for developer debugging
-# This enables use of libbfd to get more detailed symbols for the backtraces
-# generated by CONFIG_WPA_TRACE=y.
-#CONFIG_WPA_TRACE_BFD=y
-# For BSD, comment out these.
-#LIBS += -lbfd -liberty -lz
-#LIBS_p += -lbfd -liberty -lz
-#LIBS_c += -lbfd -liberty -lz
-
-# hostapd depends on strong random number generation being available from the
-# operating system. os_get_random() function is used to fetch random data when
-# needed, e.g., for key generation. On Linux and BSD systems, this works by
-# reading /dev/urandom. It should be noted that the OS entropy pool needs to be
-# properly initialized before hostapd is started. This is important especially
-# on embedded devices that do not have a hardware random number generator and
-# may by default start up with minimal entropy available for random number
-# generation.
-#
-# As a safety net, hostapd is by default trying to internally collect
-# additional entropy for generating random data to mix in with the data
-# fetched from the OS. This by itself is not considered to be very strong, but
-# it may help in cases where the system pool is not initialized properly.
-# However, it is very strongly recommended that the system pool is initialized
-# with enough entropy either by using hardware assisted random number
-# generator or by storing state over device reboots.
-#
-# hostapd can be configured to maintain its own entropy store over restarts to
-# enhance random number generation. This is not perfect, but it is much more
-# secure than using the same sequence of random numbers after every reboot.
-# This can be enabled with -e<entropy file> command line option. The specified
-# file needs to be readable and writable by hostapd.
-#
-# If the os_get_random() is known to provide strong random data (e.g., on
-# Linux/BSD, the board in question is known to have reliable source of random
-# data from /dev/urandom), the internal hostapd random pool can be disabled.
-# This will save some in binary size and CPU use. However, this should only be
-# considered for builds that are known to be used on devices that meet the
-# requirements described above.
-CONFIG_NO_RANDOM_POOL=y
-
-# Should we attempt to use the getrandom(2) call that provides more reliable
-# yet secure randomness source than /dev/random on Linux 3.17 and newer.
-# Requires glibc 2.25 to build, falls back to /dev/random if unavailable.
-CONFIG_GETRANDOM=y
-
-# Should we use poll instead of select? Select is used by default.
-#CONFIG_ELOOP_POLL=y
-
-# Should we use epoll instead of select? Select is used by default.
-CONFIG_ELOOP_EPOLL=y
-
-# Should we use kqueue instead of select? Select is used by default.
-#CONFIG_ELOOP_KQUEUE=y
-
-# Select TLS implementation
-# openssl = OpenSSL (default)
-# gnutls = GnuTLS
-# internal = Internal TLSv1 implementation (experimental)
-# linux = Linux kernel AF_ALG and internal TLSv1 implementation (experimental)
-# none = Empty template
-CONFIG_TLS=internal
-
-# TLS-based EAP methods require at least TLS v1.0. Newer version of TLS (v1.1)
-# can be enabled to get a stronger construction of messages when block ciphers
-# are used.
-#CONFIG_TLSV11=y
-
-# TLS-based EAP methods require at least TLS v1.0. Newer version of TLS (v1.2)
-# can be enabled to enable use of stronger crypto algorithms.
-#CONFIG_TLSV12=y
-
-# Select which ciphers to use by default with OpenSSL if the user does not
-# specify them.
-#CONFIG_TLS_DEFAULT_CIPHERS="DEFAULT:!EXP:!LOW"
-
-# If CONFIG_TLS=internal is used, additional library and include paths are
-# needed for LibTomMath. Alternatively, an integrated, minimal version of
-# LibTomMath can be used. See beginning of libtommath.c for details on benefits
-# and drawbacks of this option.
-#CONFIG_INTERNAL_LIBTOMMATH=y
-#ifndef CONFIG_INTERNAL_LIBTOMMATH
-#LTM_PATH=/usr/src/libtommath-0.39
-#CFLAGS += -I$(LTM_PATH)
-#LIBS += -L$(LTM_PATH)
-#LIBS_p += -L$(LTM_PATH)
-#endif
-# At the cost of about 4 kB of additional binary size, the internal LibTomMath
-# can be configured to include faster routines for exptmod, sqr, and div to
-# speed up DH and RSA calculation considerably
-#CONFIG_INTERNAL_LIBTOMMATH_FAST=y
-
-# Interworking (IEEE 802.11u)
-# This can be used to enable functionality to improve interworking with
-# external networks.
-#CONFIG_INTERWORKING=y
-
-# Hotspot 2.0
-#CONFIG_HS20=y
-
-# Enable SQLite database support in hlr_auc_gw, EAP-SIM DB, and eap_user_file
-#CONFIG_SQLITE=y
-
-# Enable Fast Session Transfer (FST)
-#CONFIG_FST=y
-
-# Enable CLI commands for FST testing
-#CONFIG_FST_TEST=y
-
-# Testing options
-# This can be used to enable some testing options (see also the example
-# configuration file) that are really useful only for testing clients that
-# connect to this hostapd. These options allow, for example, to drop a
-# certain percentage of probe requests or auth/(re)assoc frames.
-#
-#CONFIG_TESTING_OPTIONS=y
-
-# Automatic Channel Selection
-# This will allow hostapd to pick the channel automatically when channel is set
-# to "acs_survey" or "0". Eventually, other ACS algorithms can be added in
-# similar way.
-#
-# Automatic selection is currently only done through initialization, later on
-# we hope to do background checks to keep us moving to more ideal channels as
-# time goes by. ACS is currently only supported through the nl80211 driver and
-# your driver must have survey dump capability that is filled by the driver
-# during scanning.
-#
-# You can customize the ACS survey algorithm with the hostapd.conf variable
-# acs_num_scans.
-#
-# Supported ACS drivers:
-# * ath9k
-# * ath5k
-# * ath10k
-#
-# For more details refer to:
-# http://wireless.kernel.org/en/users/Documentation/acs
-#
-#CONFIG_ACS=y
-
-# Multiband Operation support
-# These extentions facilitate efficient use of multiple frequency bands
-# available to the AP and the devices that may associate with it.
-#CONFIG_MBO=y
-
-# Client Taxonomy
-# Has the AP retain the Probe Request and (Re)Association Request frames from
-# a client, from which a signature can be produced which can identify the model
-# of client device like "Nexus 6P" or "iPhone 5s".
-#CONFIG_TAXONOMY=y
-
-# Fast Initial Link Setup (FILS) (IEEE 802.11ai)
-#CONFIG_FILS=y
-# FILS shared key authentication with PFS
-#CONFIG_FILS_SK_PFS=y
-
-# Include internal line edit mode in hostapd_cli. This can be used to provide
-# limited command line editing and history support.
-#CONFIG_WPA_CLI_EDIT=y
-
-# Opportunistic Wireless Encryption (OWE)
-# Experimental implementation of draft-harkins-owe-07.txt
-#CONFIG_OWE=y
-
-# Airtime policy support
-#CONFIG_AIRTIME_POLICY=y
-
-# Override default value for the wpa_disable_eapol_key_retries configuration
-# parameter. See that parameter in hostapd.conf for more details.
-#CFLAGS += -DDEFAULT_WPA_DISABLE_EAPOL_KEY_RETRIES=1
-
-# uBus IPC/RPC System
-# Services can connect to the bus and provide methods
-# that can be called by other services or clients.
-CONFIG_UBUS=y
-
-# OpenWrt patch 380-disable-ctrl-iface-mib.patch
-# leads to the MIB only being compiled in if
-# CONFIG_CTRL_IFACE_MIB is enabled.
-#CONFIG_CTRL_IFACE_MIB=y
diff --git a/package/network/services/hostapd/files/hostapd.sh b/package/network/services/hostapd/files/hostapd.sh
deleted file mode 100644
index 216d9b14fa..0000000000
--- a/package/network/services/hostapd/files/hostapd.sh
+++ /dev/null
@@ -1,1499 +0,0 @@
-. /lib/functions/network.sh
-. /lib/functions.sh
-
-wpa_supplicant_add_rate() {
-	local var="$1"
-	local val="$(($2 / 1000))"
-	local sub="$((($2 / 100) % 10))"
-	append $var "$val" ","
-	[ $sub -gt 0 ] && append $var "."
-}
-
-hostapd_add_rate() {
-	local var="$1"
-	local val="$(($2 / 100))"
-	append $var "$val" " "
-}
-
-hostapd_append_wep_key() {
-	local var="$1"
-
-	wep_keyidx=0
-	set_default key 1
-	case "$key" in
-		[1234])
-			for idx in 1 2 3 4; do
-				local zidx
-				zidx=$(($idx - 1))
-				json_get_var ckey "key${idx}"
-				[ -n "$ckey" ] && \
-					append $var "wep_key${zidx}=$(prepare_key_wep "$ckey")" "$N$T"
-			done
-			wep_keyidx=$((key - 1))
-		;;
-		*)
-			append $var "wep_key0=$(prepare_key_wep "$key")" "$N$T"
-		;;
-	esac
-}
-
-hostapd_append_wpa_key_mgmt() {
-	local auth_type_l="$(echo $auth_type | tr 'a-z' 'A-Z')"
-
-	case "$auth_type" in
-		psk|eap)
-			append wpa_key_mgmt "WPA-$auth_type_l"
-			[ "${ieee80211r:-0}" -gt 0 ] && append wpa_key_mgmt "FT-${auth_type_l}"
-			[ "${ieee80211w:-0}" -gt 0 ] && append wpa_key_mgmt "WPA-${auth_type_l}-SHA256"
-		;;
-		eap192)
-			append wpa_key_mgmt "WPA-EAP-SUITE-B-192"
-			[ "${ieee80211r:-0}" -gt 0 ] && append wpa_key_mgmt "FT-EAP"
-		;;
-		eap-eap192)
-			append wpa_key_mgmt "WPA-EAP-SUITE-B-192"
-			append wpa_key_mgmt "WPA-EAP"
-			[ "${ieee80211r:-0}" -gt 0 ] && append wpa_key_mgmt "FT-EAP"
-			[ "${ieee80211w:-0}" -gt 0 ] && append wpa_key_mgmt "WPA-EAP-SHA256"
-		;;
-		sae)
-			append wpa_key_mgmt "SAE"
-			[ "${ieee80211r:-0}" -gt 0 ] && append wpa_key_mgmt "FT-SAE"
-		;;
-		psk-sae)
-			append wpa_key_mgmt "WPA-PSK"
-			[ "${ieee80211r:-0}" -gt 0 ] && append wpa_key_mgmt "FT-PSK"
-			[ "${ieee80211w:-0}" -gt 0 ] && append wpa_key_mgmt "WPA-PSK-SHA256"
-			append wpa_key_mgmt "SAE"
-			[ "${ieee80211r:-0}" -gt 0 ] && append wpa_key_mgmt "FT-SAE"
-		;;
-		owe)
-			append wpa_key_mgmt "OWE"
-		;;
-	esac
-
-	[ "$auth_osen" = "1" ] && append wpa_key_mgmt "OSEN"
-}
-
-hostapd_add_log_config() {
-	config_add_boolean \
-		log_80211 \
-		log_8021x \
-		log_radius \
-		log_wpa \
-		log_driver \
-		log_iapp \
-		log_mlme
-
-	config_add_int log_level
-}
-
-hostapd_common_add_device_config() {
-	config_add_array basic_rate
-	config_add_array supported_rates
-	config_add_string beacon_rate
-
-	config_add_string country country3
-	config_add_boolean country_ie doth
-	config_add_boolean spectrum_mgmt_required
-	config_add_int local_pwr_constraint
-	config_add_string require_mode
-	config_add_boolean legacy_rates
-	config_add_int cell_density
-	config_add_int rts_threshold
-
-	config_add_string acs_chan_bias
-	config_add_array hostapd_options
-
-	config_add_int airtime_mode
-
-	hostapd_add_log_config
-}
-
-hostapd_prepare_device_config() {
-	local config="$1"
-	local driver="$2"
-
-	local base_cfg=
-
-	json_get_vars country country3 country_ie beacon_int:100 dtim_period:2 doth require_mode legacy_rates \
-		acs_chan_bias local_pwr_constraint spectrum_mgmt_required airtime_mode cell_density \
-		rts_threshold beacon_rate
-
-	hostapd_set_log_options base_cfg
-
-	set_default country_ie 1
-	set_default spectrum_mgmt_required 0
-	set_default doth 1
-	set_default legacy_rates 0
-	set_default airtime_mode 0
-	set_default cell_density 0
-
-	[ -n "$country" ] && {
-		append base_cfg "country_code=$country" "$N"
-		[ -n "$country3" ] && append base_cfg "country3=$country3" "$N"
-
-		[ "$country_ie" -gt 0 ] && {
-			append base_cfg "ieee80211d=1" "$N"
-			[ -n "$local_pwr_constraint" ] && append base_cfg "local_pwr_constraint=$local_pwr_constraint" "$N"
-			[ "$spectrum_mgmt_required" -gt 0 ] && append base_cfg "spectrum_mgmt_required=$spectrum_mgmt_required" "$N"
-		}
-		[ "$hwmode" = "a" -a "$doth" -gt 0 ] && append base_cfg "ieee80211h=1" "$N"
-	}
-
-	[ -n "$acs_chan_bias" ] && append base_cfg "acs_chan_bias=$acs_chan_bias" "$N"
-
-	local brlist= br
-	json_get_values basic_rate_list basic_rate
-	local rlist= r
-	json_get_values rate_list supported_rates
-
-	[ -n "$hwmode" ] && append base_cfg "hw_mode=$hwmode" "$N"
-	if [ "$hwmode" = "g" ] || [ "$hwmode" = "a" ]; then
-		[ -n "$require_mode" ] && legacy_rates=0
-		case "$require_mode" in
-			n) append base_cfg "require_ht=1" "$N";;
-			ac) append base_cfg "require_vht=1" "$N";;
-		esac
-	fi
-	case "$hwmode" in
-		b)
-			if [ "$cell_density" -eq 1 ]; then
-				set_default rate_list "5500 11000"
-				set_default basic_rate_list "5500 11000"
-			elif [ "$cell_density" -ge 2 ]; then
-				set_default rate_list "11000"
-				set_default basic_rate_list "11000"
-			fi
-		;;
-		g)
-			if [ "$cell_density" -eq 0 ] || [ "$cell_density" -eq 1 ]; then
-				if [ "$legacy_rates" -eq 0 ]; then
-					set_default rate_list "6000 9000 12000 18000 24000 36000 48000 54000"
-					set_default basic_rate_list "6000 12000 24000"
-				elif [ "$cell_density" -eq 1 ]; then
-					set_default rate_list "5500 6000 9000 11000 12000 18000 24000 36000 48000 54000"
-					set_default basic_rate_list "5500 11000"
-				fi
-			elif [ "$cell_density" -ge 3 ] && [ "$legacy_rates" -ne 0 ] || [ "$cell_density" -eq 2 ]; then
-				if [ "$legacy_rates" -eq 0 ]; then
-					set_default rate_list "12000 18000 24000 36000 48000 54000"
-					set_default basic_rate_list "12000 24000"
-				else
-					set_default rate_list "11000 12000 18000 24000 36000 48000 54000"
-					set_default basic_rate_list "11000"
-				fi
-			elif [ "$cell_density" -ge 3 ]; then
-				set_default rate_list "24000 36000 48000 54000"
-				set_default basic_rate_list "24000"
-			fi
-		;;
-		a)
-			if [ "$cell_density" -eq 1 ]; then
-				set_default rate_list "6000 9000 12000 18000 24000 36000 48000 54000"
-				set_default basic_rate_list "6000 12000 24000"
-			elif [ "$cell_density" -eq 2 ]; then
-				set_default rate_list "12000 18000 24000 36000 48000 54000"
-				set_default basic_rate_list "12000 24000"
-			elif [ "$cell_density" -ge 3 ]; then
-				set_default rate_list "24000 36000 48000 54000"
-				set_default basic_rate_list "24000"
-			fi
-		;;
-	esac
-
-	for r in $rate_list; do
-		hostapd_add_rate rlist "$r"
-	done
-
-	for br in $basic_rate_list; do
-		hostapd_add_rate brlist "$br"
-	done
-
-	[ -n "$beacon_rate" ] && append base_cfg "beacon_rate=$beacon_rate" "$N"
-	[ -n "$rlist" ] && append base_cfg "supported_rates=$rlist" "$N"
-	[ -n "$brlist" ] && append base_cfg "basic_rates=$brlist" "$N"
-	append base_cfg "beacon_int=$beacon_int" "$N"
-	[ -n "$rts_threshold" ] && append base_cfg "rts_threshold=$rts_threshold" "$N"
-	append base_cfg "dtim_period=$dtim_period" "$N"
-	[ "$airtime_mode" -gt 0 ] && append base_cfg "airtime_mode=$airtime_mode" "$N"
-
-	json_get_values opts hostapd_options
-	for val in $opts; do
-		append base_cfg "$val" "$N"
-	done
-
-	cat > "$config" <<EOF
-driver=$driver
-$base_cfg
-EOF
-}
-
-hostapd_common_add_bss_config() {
-	config_add_string 'bssid:macaddr' 'ssid:string'
-	config_add_boolean wds wmm uapsd hidden utf8_ssid
-
-	config_add_int maxassoc max_inactivity
-	config_add_boolean disassoc_low_ack isolate short_preamble skip_inactivity_poll
-
-	config_add_int \
-		wep_rekey eap_reauth_period \
-		wpa_group_rekey wpa_pair_rekey wpa_master_rekey
-	config_add_boolean wpa_strict_rekey
-	config_add_boolean wpa_disable_eapol_key_retries
-
-	config_add_boolean tdls_prohibit
-
-	config_add_boolean rsn_preauth auth_cache
-	config_add_int ieee80211w
-	config_add_int eapol_version
-
-	config_add_string 'auth_server:host' 'server:host'
-	config_add_string auth_secret key
-	config_add_int 'auth_port:port' 'port:port'
-
-	config_add_string acct_server
-	config_add_string acct_secret
-	config_add_int acct_port
-	config_add_int acct_interval
-
-	config_add_int bss_load_update_period chan_util_avg_period
-
-	config_add_string dae_client
-	config_add_string dae_secret
-	config_add_int dae_port
-
-	config_add_string nasid
-	config_add_string ownip
-	config_add_string radius_client_addr
-	config_add_string iapp_interface
-	config_add_string eap_type ca_cert client_cert identity anonymous_identity auth priv_key priv_key_pwd
-	config_add_boolean ca_cert_usesystem ca_cert2_usesystem
-	config_add_string subject_match subject_match2
-	config_add_array altsubject_match altsubject_match2
-	config_add_array domain_match domain_match2 domain_suffix_match domain_suffix_match2
-	config_add_string ieee80211w_mgmt_cipher
-
-	config_add_int dynamic_vlan vlan_naming vlan_no_bridge
-	config_add_string vlan_tagged_interface vlan_bridge
-	config_add_string vlan_file
-
-	config_add_string 'key1:wepkey' 'key2:wepkey' 'key3:wepkey' 'key4:wepkey' 'password:wpakey'
-
-	config_add_string wpa_psk_file
-
-	config_add_int multi_ap
-
-	config_add_boolean wps_pushbutton wps_label ext_registrar wps_pbc_in_m1
-	config_add_int wps_ap_setup_locked wps_independent
-	config_add_string wps_device_type wps_device_name wps_manufacturer wps_pin
-	config_add_string multi_ap_backhaul_ssid multi_ap_backhaul_key
-
-	config_add_boolean wnm_sleep_mode wnm_sleep_mode_no_keys bss_transition
-	config_add_int time_advertisement
-	config_add_string time_zone
-	config_add_string vendor_elements
-
-	config_add_boolean ieee80211k rrm_neighbor_report rrm_beacon_report
-
-	config_add_boolean ftm_responder stationary_ap
-	config_add_string lci civic
-
-	config_add_boolean ieee80211r pmk_r1_push ft_psk_generate_local ft_over_ds
-	config_add_int r0_key_lifetime reassociation_deadline
-	config_add_string mobility_domain r1_key_holder
-	config_add_array r0kh r1kh
-
-	config_add_int ieee80211w_max_timeout ieee80211w_retry_timeout
-
-	config_add_string macfilter 'macfile:file'
-	config_add_array 'maclist:list(macaddr)'
-
-	config_add_array bssid_blacklist
-	config_add_array bssid_whitelist
-
-	config_add_int mcast_rate
-	config_add_array basic_rate
-	config_add_array supported_rates
-
-	config_add_boolean sae_require_mfp
-
-	config_add_string 'owe_transition_bssid:macaddr' 'owe_transition_ssid:string'
-	config_add_string owe_transition_ifname
-
-	config_add_boolean iw_enabled iw_internet iw_asra iw_esr iw_uesa
-	config_add_int iw_access_network_type iw_venue_group iw_venue_type
-	config_add_int iw_ipaddr_type_availability iw_gas_address3
-	config_add_string iw_hessid iw_network_auth_type iw_qos_map_set
-	config_add_array iw_roaming_consortium iw_domain_name iw_anqp_3gpp_cell_net iw_nai_realm
-	config_add_array iw_anqp_elem iw_venue_name iw_venue_url
-
-	config_add_boolean hs20 disable_dgaf osen
-	config_add_int anqp_domain_id
-	config_add_int hs20_deauth_req_timeout
-	config_add_array hs20_oper_friendly_name
-	config_add_array osu_provider
-	config_add_array operator_icon
-	config_add_array hs20_conn_capab
-	config_add_string osu_ssid hs20_wan_metrics hs20_operating_class hs20_t_c_filename hs20_t_c_timestamp
-
-	config_add_string hs20_t_c_server_url
-
-	config_add_array airtime_sta_weight
-	config_add_int airtime_bss_weight airtime_bss_limit
-
-	config_add_boolean multicast_to_unicast per_sta_vif
-
-	config_add_array hostapd_bss_options
-
-	config_add_boolean request_cui
-	config_add_array radius_auth_req_attr
-	config_add_array radius_acct_req_attr
-
-	config_add_int eap_server
-	config_add_string eap_user_file ca_cert server_cert private_key private_key_passwd server_id
-}
-
-hostapd_set_vlan_file() {
-	local ifname="$1"
-	local vlan="$2"
-	json_get_vars name vid
-	echo "${vid} ${ifname}-${name}" >> /var/run/hostapd-${ifname}.vlan
-	wireless_add_vlan "${vlan}" "${ifname}-${name}"
-}
-
-hostapd_set_vlan() {
-	local ifname="$1"
-
-	rm -f /var/run/hostapd-${ifname}.vlan
-	for_each_vlan hostapd_set_vlan_file ${ifname}
-}
-
-hostapd_set_psk_file() {
-	local ifname="$1"
-	local vlan="$2"
-	local vlan_id=""
-
-	json_get_vars mac vid key
-	set_default mac "00:00:00:00:00:00"
-	[ -n "$vid" ] && vlan_id="vlanid=$vid "
-	echo "${vlan_id} ${mac} ${key}" >> /var/run/hostapd-${ifname}.psk
-}
-
-hostapd_set_psk() {
-	local ifname="$1"
-
-	rm -f /var/run/hostapd-${ifname}.psk
-	for_each_station hostapd_set_psk_file ${ifname}
-}
-
-append_iw_roaming_consortium() {
-	[ -n "$1" ] && append bss_conf "roaming_consortium=$1" "$N"
-}
-
-append_iw_domain_name() {
-	if [ -z "$iw_domain_name_conf" ]; then
-		iw_domain_name_conf="$1"
-	else
-		iw_domain_name_conf="$iw_domain_name_conf,$1"
-	fi
-}
-
-append_iw_anqp_3gpp_cell_net() {
-	if [ -z "$iw_anqp_3gpp_cell_net_conf" ]; then
-		iw_anqp_3gpp_cell_net_conf="$1"
-	else
-		iw_anqp_3gpp_cell_net_conf="$iw_anqp_3gpp_cell_net_conf:$1"
-	fi
-}
-
-append_iw_anqp_elem() {
-	[ -n "$1" ] && append bss_conf "anqp_elem=$1" "$N"
-}
-
-append_iw_nai_realm() {
-	[ -n "$1" ] && append bss_conf "nai_realm=$1" "$N"
-}
-
-append_iw_venue_name() {
-	append bss_conf "venue_name=$1" "$N"
-}
-
-append_iw_venue_url() {
-	append bss_conf "venue_url=$1" "$N"
-}
-
-append_hs20_oper_friendly_name() {
-	append bss_conf "hs20_oper_friendly_name=$1" "$N"
-}
-
-append_osu_provider_friendly_name() {
-	append bss_conf "osu_friendly_name=$1" "$N"
-}
-
-append_osu_provider_service_desc() {
-	append bss_conf "osu_service_desc=$1" "$N"
-}
-
-append_hs20_icon() {
-	local width height lang type path
-	config_get width "$1" width
-	config_get height "$1" height
-	config_get lang "$1" lang
-	config_get type "$1" type
-	config_get path "$1" path
-
-	append bss_conf "hs20_icon=$width:$height:$lang:$type:$1:$path" "$N"
-}
-
-append_hs20_icons() {
-	config_load wireless
-	config_foreach append_hs20_icon hs20-icon
-}
-
-append_operator_icon() {
-	append bss_conf "operator_icon=$1" "$N"
-}
-
-append_osu_icon() {
-	append bss_conf "osu_icon=$1" "$N"
-}
-
-append_osu_provider() {
-	local cfgtype osu_server_uri osu_friendly_name osu_nai osu_nai2 osu_method_list
-
-	config_load wireless
-	config_get cfgtype "$1" TYPE
-	[ "$cfgtype" != "osu-provider" ] && return
-
-	append bss_conf "# provider $1" "$N"
-	config_get osu_server_uri "$1" osu_server_uri
-	config_get osu_nai "$1" osu_nai
-	config_get osu_nai2 "$1" osu_nai2
-	config_get osu_method_list "$1" osu_method
-
-	append bss_conf "osu_server_uri=$osu_server_uri" "$N"
-	append bss_conf "osu_nai=$osu_nai" "$N"
-	append bss_conf "osu_nai2=$osu_nai2" "$N"
-	append bss_conf "osu_method_list=$osu_method_list" "$N"
-
-	config_list_foreach "$1" osu_service_desc append_osu_provider_service_desc
-	config_list_foreach "$1" osu_friendly_name append_osu_friendly_name
-	config_list_foreach "$1" osu_icon append_osu_icon
-
-	append bss_conf "$N"
-}
-
-append_hs20_conn_capab() {
-	[ -n "$1" ] && append bss_conf "hs20_conn_capab=$1" "$N"
-}
-
-append_radius_acct_req_attr() {
-	append bss_conf "radius_acct_req_attr=$1" "$N"
-}
-
-append_radius_auth_req_attr() {
-	append bss_conf "radius_auth_req_attr=$1" "$N"
-}
-
-append_airtime_sta_weight() {
-	[ -n "$1" ] && append bss_conf "airtime_sta_weight=$1" "$N"
-}
-
-hostapd_set_bss_options() {
-	local var="$1"
-	local phy="$2"
-	local vif="$3"
-
-	wireless_vif_parse_encryption
-
-	local bss_conf bss_md5sum
-	local wep_rekey wpa_group_rekey wpa_pair_rekey wpa_master_rekey wpa_key_mgmt
-
-	json_get_vars \
-		wep_rekey wpa_group_rekey wpa_pair_rekey wpa_master_rekey wpa_strict_rekey \
-		wpa_disable_eapol_key_retries tdls_prohibit \
-		maxassoc max_inactivity disassoc_low_ack isolate auth_cache \
-		wps_pushbutton wps_label ext_registrar wps_pbc_in_m1 wps_ap_setup_locked \
-		wps_independent wps_device_type wps_device_name wps_manufacturer wps_pin \
-		macfilter ssid utf8_ssid wmm uapsd hidden short_preamble rsn_preauth \
-		iapp_interface eapol_version dynamic_vlan ieee80211w nasid \
-		acct_server acct_secret acct_port acct_interval \
-		bss_load_update_period chan_util_avg_period sae_require_mfp \
-		multi_ap multi_ap_backhaul_ssid multi_ap_backhaul_key skip_inactivity_poll \
-		airtime_bss_weight airtime_bss_limit airtime_sta_weight \
-		multicast_to_unicast per_sta_vif \
-		eap_server eap_user_file ca_cert server_cert private_key private_key_passwd server_id \
-		vendor_elements
-
-	set_default isolate 0
-	set_default maxassoc 0
-	set_default max_inactivity 0
-	set_default short_preamble 1
-	set_default disassoc_low_ack 1
-	set_default skip_inactivity_poll 0
-	set_default hidden 0
-	set_default wmm 1
-	set_default uapsd 1
-	set_default wpa_disable_eapol_key_retries 0
-	set_default tdls_prohibit 0
-	set_default eapol_version $((wpa & 1))
-	set_default acct_port 1813
-	set_default bss_load_update_period 60
-	set_default chan_util_avg_period 600
-	set_default utf8_ssid 1
-	set_default multi_ap 0
-	set_default airtime_bss_weight 0
-	set_default airtime_bss_limit 0
-	set_default eap_server 0
-
-	append bss_conf "ctrl_interface=/var/run/hostapd"
-	if [ "$isolate" -gt 0 ]; then
-		append bss_conf "ap_isolate=$isolate" "$N"
-	fi
-	if [ "$maxassoc" -gt 0 ]; then
-		append bss_conf "max_num_sta=$maxassoc" "$N"
-	fi
-	if [ "$max_inactivity" -gt 0 ]; then
-		append bss_conf "ap_max_inactivity=$max_inactivity" "$N"
-	fi
-
-	[ "$airtime_bss_weight" -gt 0 ] && append bss_conf "airtime_bss_weight=$airtime_bss_weight" "$N"
-	[ "$airtime_bss_limit" -gt 0 ] && append bss_conf "airtime_bss_limit=$airtime_bss_limit" "$N"
-	json_for_each_item append_airtime_sta_weight airtime_sta_weight
-
-	append bss_conf "bss_load_update_period=$bss_load_update_period" "$N"
-	append bss_conf "chan_util_avg_period=$chan_util_avg_period" "$N"
-	append bss_conf "disassoc_low_ack=$disassoc_low_ack" "$N"
-	append bss_conf "skip_inactivity_poll=$skip_inactivity_poll" "$N"
-	append bss_conf "preamble=$short_preamble" "$N"
-	append bss_conf "wmm_enabled=$wmm" "$N"
-	append bss_conf "ignore_broadcast_ssid=$hidden" "$N"
-	append bss_conf "uapsd_advertisement_enabled=$uapsd" "$N"
-	append bss_conf "utf8_ssid=$utf8_ssid" "$N"
-	append bss_conf "multi_ap=$multi_ap" "$N"
-	[ -n "$vendor_elements" ] && append bss_conf "vendor_elements=$vendor_elements" "$N"
-
-	[ "$tdls_prohibit" -gt 0 ] && append bss_conf "tdls_prohibit=$tdls_prohibit" "$N"
-
-	[ "$wpa" -gt 0 ] && {
-		[ -n "$wpa_group_rekey"  ] && append bss_conf "wpa_group_rekey=$wpa_group_rekey" "$N"
-		[ -n "$wpa_pair_rekey"   ] && append bss_conf "wpa_ptk_rekey=$wpa_pair_rekey"    "$N"
-		[ -n "$wpa_master_rekey" ] && append bss_conf "wpa_gmk_rekey=$wpa_master_rekey"  "$N"
-		[ -n "$wpa_strict_rekey" ] && append bss_conf "wpa_strict_rekey=$wpa_strict_rekey" "$N"
-	}
-
-	[ -n "$nasid" ] && append bss_conf "nas_identifier=$nasid" "$N"
-	[ -n "$acct_server" ] && {
-		append bss_conf "acct_server_addr=$acct_server" "$N"
-		append bss_conf "acct_server_port=$acct_port" "$N"
-		[ -n "$acct_secret" ] && \
-			append bss_conf "acct_server_shared_secret=$acct_secret" "$N"
-		[ -n "$acct_interval" ] && \
-			append bss_conf "radius_acct_interim_interval=$acct_interval" "$N"
-		json_for_each_item append_radius_acct_req_attr radius_acct_req_attr
-	}
-
-	case "$auth_type" in
-		sae|owe|eap192|eap-eap192)
-			set_default ieee80211w 2
-			set_default sae_require_mfp 1
-		;;
-		psk-sae)
-			set_default ieee80211w 1
-			set_default sae_require_mfp 1
-		;;
-	esac
-	[ -n "$sae_require_mfp" ] && append bss_conf "sae_require_mfp=$sae_require_mfp" "$N"
-
-	local vlan_possible=""
-
-	case "$auth_type" in
-		none|owe)
-			json_get_vars owe_transition_bssid owe_transition_ssid owe_transition_ifname
-
-			[ -n "$owe_transition_ssid" ] && append bss_conf "owe_transition_ssid=\"$owe_transition_ssid\"" "$N"
-			[ -n "$owe_transition_bssid" ] && append bss_conf "owe_transition_bssid=$owe_transition_bssid" "$N"
-			[ -n "$owe_transition_ifname" ] && append bss_conf "owe_transition_ifname=$owe_transition_ifname" "$N"
-
-			wps_possible=1
-			# Here we make the assumption that if we're in open mode
-			# with WPS enabled, we got to be in unconfigured state.
-			wps_not_configured=1
-		;;
-		psk|sae|psk-sae)
-			json_get_vars key wpa_psk_file
-			if [ ${#key} -eq 64 ]; then
-				append bss_conf "wpa_psk=$key" "$N"
-			elif [ ${#key} -ge 8 ] && [ ${#key} -le 63 ]; then
-				append bss_conf "wpa_passphrase=$key" "$N"
-			elif [ -n "$key" ] || [ -z "$wpa_psk_file" ]; then
-				wireless_setup_vif_failed INVALID_WPA_PSK
-				return 1
-			fi
-			[ -z "$wpa_psk_file" ] && set_default wpa_psk_file /var/run/hostapd-$ifname.psk
-			[ -n "$wpa_psk_file" ] && {
-				[ -e "$wpa_psk_file" ] || touch "$wpa_psk_file"
-				append bss_conf "wpa_psk_file=$wpa_psk_file" "$N"
-			}
-			[ "$eapol_version" -ge "1" -a "$eapol_version" -le "2" ] && append bss_conf "eapol_version=$eapol_version" "$N"
-
-			set_default dynamic_vlan 0
-			vlan_possible=1
-			wps_possible=1
-		;;
-		eap|eap192|eap-eap192)
-			json_get_vars \
-				auth_server auth_secret auth_port \
-				dae_client dae_secret dae_port \
-				ownip radius_client_addr \
-				eap_reauth_period request_cui
-
-			# radius can provide VLAN ID for clients
-			vlan_possible=1
-
-			# legacy compatibility
-			[ -n "$auth_server" ] || json_get_var auth_server server
-			[ -n "$auth_port" ] || json_get_var auth_port port
-			[ -n "$auth_secret" ] || json_get_var auth_secret key
-
-			set_default auth_port 1812
-			set_default dae_port 3799
-			set_default request_cui 0
-
-			[ "$eap_server" -eq 0 ] && {
-				append bss_conf "auth_server_addr=$auth_server" "$N"
-				append bss_conf "auth_server_port=$auth_port" "$N"
-				append bss_conf "auth_server_shared_secret=$auth_secret" "$N"
-			}
-
-			[ "$request_cui" -gt 0 ] && append bss_conf "radius_request_cui=$request_cui" "$N"
-			[ -n "$eap_reauth_period" ] && append bss_conf "eap_reauth_period=$eap_reauth_period" "$N"
-
-			[ -n "$dae_client" -a -n "$dae_secret" ] && {
-				append bss_conf "radius_das_port=$dae_port" "$N"
-				append bss_conf "radius_das_client=$dae_client $dae_secret" "$N"
-			}
-			json_for_each_item append_radius_auth_req_attr radius_auth_req_attr
-
-			[ -n "$ownip" ] && append bss_conf "own_ip_addr=$ownip" "$N"
-			[ -n "$radius_client_addr" ] && append bss_conf "radius_client_addr=$radius_client_addr" "$N"
-			append bss_conf "eapol_key_index_workaround=1" "$N"
-			append bss_conf "ieee8021x=1" "$N"
-
-			[ "$eapol_version" -ge "1" -a "$eapol_version" -le "2" ] && append bss_conf "eapol_version=$eapol_version" "$N"
-		;;
-		wep)
-			local wep_keyidx=0
-			json_get_vars key
-			hostapd_append_wep_key bss_conf
-			append bss_conf "wep_default_key=$wep_keyidx" "$N"
-			[ -n "$wep_rekey" ] && append bss_conf "wep_rekey_period=$wep_rekey" "$N"
-		;;
-	esac
-
-	local auth_algs=$((($auth_mode_shared << 1) | $auth_mode_open))
-	append bss_conf "auth_algs=${auth_algs:-1}" "$N"
-	append bss_conf "wpa=$wpa" "$N"
-	[ -n "$wpa_pairwise" ] && append bss_conf "wpa_pairwise=$wpa_pairwise" "$N"
-
-	set_default wps_pushbutton 0
-	set_default wps_label 0
-	set_default wps_pbc_in_m1 0
-
-	config_methods=
-	[ "$wps_pushbutton" -gt 0 ] && append config_methods push_button
-	[ "$wps_label" -gt 0 ] && append config_methods label
-
-	# WPS not possible on Multi-AP backhaul-only SSID
-	[ "$multi_ap" = 1 ] && wps_possible=
-
-	[ -n "$wps_possible" -a -n "$config_methods" ] && {
-		set_default ext_registrar 0
-		set_default wps_device_type "6-0050F204-1"
-		set_default wps_device_name "OpenWrt AP"
-		set_default wps_manufacturer "www.openwrt.org"
-		set_default wps_independent 1
-
-		wps_state=2
-		[ -n "$wps_not_configured" ] && wps_state=1
-
-		[ "$ext_registrar" -gt 0 -a -n "$network_bridge" ] && append bss_conf "upnp_iface=$network_bridge" "$N"
-
-		append bss_conf "eap_server=1" "$N"
-		[ -n "$wps_pin" ] && append bss_conf "ap_pin=$wps_pin" "$N"
-		append bss_conf "wps_state=$wps_state" "$N"
-		append bss_conf "device_type=$wps_device_type" "$N"
-		append bss_conf "device_name=$wps_device_name" "$N"
-		append bss_conf "manufacturer=$wps_manufacturer" "$N"
-		append bss_conf "config_methods=$config_methods" "$N"
-		append bss_conf "wps_independent=$wps_independent" "$N"
-		[ -n "$wps_ap_setup_locked" ] && append bss_conf "ap_setup_locked=$wps_ap_setup_locked" "$N"
-		[ "$wps_pbc_in_m1" -gt 0 ] && append bss_conf "pbc_in_m1=$wps_pbc_in_m1" "$N"
-		[ "$multi_ap" -gt 0 ] && [ -n "$multi_ap_backhaul_ssid" ] && {
-			append bss_conf "multi_ap_backhaul_ssid=\"$multi_ap_backhaul_ssid\"" "$N"
-			if [ -z "$multi_ap_backhaul_key" ]; then
-				:
-			elif [ ${#multi_ap_backhaul_key} -lt 8 ]; then
-				wireless_setup_vif_failed INVALID_WPA_PSK
-				return 1
-			elif [ ${#multi_ap_backhaul_key} -eq 64 ]; then
-				append bss_conf "multi_ap_backhaul_wpa_psk=$multi_ap_backhaul_key" "$N"
-			else
-				append bss_conf "multi_ap_backhaul_wpa_passphrase=$multi_ap_backhaul_key" "$N"
-			fi
-		}
-	}
-
-	append bss_conf "ssid=$ssid" "$N"
-	[ -n "$network_bridge" ] && append bss_conf "bridge=$network_bridge${N}wds_bridge=" "$N"
-	[ -n "$network_ifname" ] && append bss_conf "snoop_iface=$network_ifname" "$N"
-	[ -n "$iapp_interface" ] && {
-		local ifname
-		network_get_device ifname "$iapp_interface" || ifname="$iapp_interface"
-		append bss_conf "iapp_interface=$ifname" "$N"
-	}
-
-	json_get_vars time_advertisement time_zone wnm_sleep_mode wnm_sleep_mode_no_keys bss_transition
-	set_default bss_transition 0
-	set_default wnm_sleep_mode 0
-	set_default wnm_sleep_mode_no_keys 0
-
-	[ -n "$time_advertisement" ] && append bss_conf "time_advertisement=$time_advertisement" "$N"
-	[ -n "$time_zone" ] && append bss_conf "time_zone=$time_zone" "$N"
-	if [ "$wnm_sleep_mode" -eq "1" ]; then
-		append bss_conf "wnm_sleep_mode=1" "$N"
-		[ "$wnm_sleep_mode_no_keys" -eq "1" ] && append bss_conf "wnm_sleep_mode_no_keys=1" "$N"
-	fi
-	[ "$bss_transition" -eq "1" ] && append bss_conf "bss_transition=1" "$N"
-
-	json_get_vars ieee80211k rrm_neighbor_report rrm_beacon_report
-	set_default ieee80211k 0
-	if [ "$ieee80211k" -eq "1" ]; then
-		set_default rrm_neighbor_report 1
-		set_default rrm_beacon_report 1
-	else
-		set_default rrm_neighbor_report 0
-		set_default rrm_beacon_report 0
-	fi
-
-	[ "$rrm_neighbor_report" -eq "1" ] && append bss_conf "rrm_neighbor_report=1" "$N"
-	[ "$rrm_beacon_report" -eq "1" ] && append bss_conf "rrm_beacon_report=1" "$N"
-
-	json_get_vars ftm_responder stationary_ap lci civic
-	set_default ftm_responder 0
-	if [ "$ftm_responder" -eq "1" ]; then
-		set_default stationary_ap 0
-		iw phy "$phy" info | grep -q "ENABLE_FTM_RESPONDER" && {
-			append bss_conf "ftm_responder=1" "$N"
-			[ "$stationary_ap" -eq "1" ] && append bss_conf "stationary_ap=1" "$N"
-			[ -n "$lci" ] && append bss_conf "lci=$lci" "$N"
-			[ -n "$civic" ] && append bss_conf "civic=$civic" "$N"
-		}
-	fi
-
-	if [ "$wpa" -ge "1" ]; then
-		json_get_vars ieee80211r
-		set_default ieee80211r 0
-
-		if [ "$ieee80211r" -gt "0" ]; then
-			json_get_vars mobility_domain ft_psk_generate_local ft_over_ds reassociation_deadline
-
-			set_default mobility_domain "$(echo "$ssid" | md5sum | head -c 4)"
-			set_default ft_over_ds 1
-			set_default reassociation_deadline 1000
-
-			case "$auth_type" in
-				psk|sae|psk-sae)
-					set_default ft_psk_generate_local 1
-				;;
-				*)
-					set_default ft_psk_generate_local 0
-				;;
-			esac
-
-			[ -n "$network_ifname" ] && append bss_conf "ft_iface=$network_ifname" "$N"
-			append bss_conf "mobility_domain=$mobility_domain" "$N"
-			append bss_conf "ft_psk_generate_local=$ft_psk_generate_local" "$N"
-			append bss_conf "ft_over_ds=$ft_over_ds" "$N"
-			append bss_conf "reassociation_deadline=$reassociation_deadline" "$N"
-			[ -n "$nasid" ] || append bss_conf "nas_identifier=${macaddr//\:}" "$N"
-
-			if [ "$ft_psk_generate_local" -eq "0" ]; then
-				json_get_vars r0_key_lifetime r1_key_holder pmk_r1_push
-				json_get_values r0kh r0kh
-				json_get_values r1kh r1kh
-
-				set_default r0_key_lifetime 10000
-				set_default pmk_r1_push 0
-
-				[ -n "$r0kh" -a -n "$r1kh" ] || {
-					key=`echo -n "$mobility_domain/$auth_secret" | md5sum | awk '{print $1}'`
-
-					set_default r0kh "ff:ff:ff:ff:ff:ff,*,$key"
-					set_default r1kh "00:00:00:00:00:00,00:00:00:00:00:00,$key"
-				}
-
-				[ -n "$r1_key_holder" ] && append bss_conf "r1_key_holder=$r1_key_holder" "$N"
-				append bss_conf "r0_key_lifetime=$r0_key_lifetime" "$N"
-				append bss_conf "pmk_r1_push=$pmk_r1_push" "$N"
-
-				for kh in $r0kh; do
-					append bss_conf "r0kh=${kh//,/ }" "$N"
-				done
-				for kh in $r1kh; do
-					append bss_conf "r1kh=${kh//,/ }" "$N"
-				done
-			fi
-		fi
-
-		append bss_conf "wpa_disable_eapol_key_retries=$wpa_disable_eapol_key_retries" "$N"
-
-		hostapd_append_wpa_key_mgmt
-		[ -n "$wpa_key_mgmt" ] && append bss_conf "wpa_key_mgmt=$wpa_key_mgmt" "$N"
-	fi
-
-	if [ "$wpa" -ge "2" ]; then
-		if [ -n "$network_bridge" -a "$rsn_preauth" = 1 ]; then
-			set_default auth_cache 1
-			append bss_conf "rsn_preauth=1" "$N"
-			append bss_conf "rsn_preauth_interfaces=$network_bridge" "$N"
-		else
-			case "$auth_type" in
-			sae|psk-sae|owe)
-				set_default auth_cache 1
-			;;
-			*)
-				set_default auth_cache 0
-			;;
-			esac
-		fi
-
-		append bss_conf "okc=$auth_cache" "$N"
-		[ "$auth_cache" = 0 ] && append bss_conf "disable_pmksa_caching=1" "$N"
-
-		# RSN -> allow management frame protection
-		case "$ieee80211w" in
-			[012])
-				json_get_vars ieee80211w_mgmt_cipher ieee80211w_max_timeout ieee80211w_retry_timeout
-				append bss_conf "ieee80211w=$ieee80211w" "$N"
-				[ "$ieee80211w" -gt "0" ] && {
-					append bss_conf "group_mgmt_cipher=${ieee80211w_mgmt_cipher:-AES-128-CMAC}" "$N"
-					[ -n "$ieee80211w_max_timeout" ] && \
-						append bss_conf "assoc_sa_query_max_timeout=$ieee80211w_max_timeout" "$N"
-					[ -n "$ieee80211w_retry_timeout" ] && \
-						append bss_conf "assoc_sa_query_retry_timeout=$ieee80211w_retry_timeout" "$N"
-				}
-			;;
-		esac
-	fi
-
-	_macfile="/var/run/hostapd-$ifname.maclist"
-	case "$macfilter" in
-		allow)
-			append bss_conf "macaddr_acl=1" "$N"
-			append bss_conf "accept_mac_file=$_macfile" "$N"
-			# accept_mac_file can be used to set MAC to VLAN ID mapping
-			vlan_possible=1
-		;;
-		deny)
-			append bss_conf "macaddr_acl=0" "$N"
-			append bss_conf "deny_mac_file=$_macfile" "$N"
-		;;
-		*)
-			_macfile=""
-		;;
-	esac
-
-	[ -n "$_macfile" ] && {
-		json_get_vars macfile
-		json_get_values maclist maclist
-
-		rm -f "$_macfile"
-		(
-			for mac in $maclist; do
-				echo "$mac"
-			done
-			[ -n "$macfile" -a -f "$macfile" ] && cat "$macfile"
-		) > "$_macfile"
-	}
-
-	[ -n "$vlan_possible" -a -n "$dynamic_vlan" ] && {
-		json_get_vars vlan_naming vlan_tagged_interface vlan_bridge vlan_file vlan_no_bridge
-		set_default vlan_naming 1
-		[ -z "$vlan_file" ] && set_default vlan_file /var/run/hostapd-$ifname.vlan
-		append bss_conf "dynamic_vlan=$dynamic_vlan" "$N"
-		append bss_conf "vlan_naming=$vlan_naming" "$N"
-		if [ -n "$vlan_bridge" ]; then
-			append bss_conf "vlan_bridge=$vlan_bridge" "$N"
-		else
-			set_default vlan_no_bridge 1
-		fi
-		append bss_conf "vlan_no_bridge=$vlan_no_bridge" "$N"
-		[ -n "$vlan_tagged_interface" ] && \
-			append bss_conf "vlan_tagged_interface=$vlan_tagged_interface" "$N"
-		[ -n "$vlan_file" ] && {
-			[ -e "$vlan_file" ] || touch "$vlan_file"
-			append bss_conf "vlan_file=$vlan_file" "$N"
-		}
-	}
-
-	json_get_vars iw_enabled iw_internet iw_asra iw_esr iw_uesa iw_access_network_type
-	json_get_vars iw_hessid iw_venue_group iw_venue_type iw_network_auth_type
-	json_get_vars iw_roaming_consortium iw_domain_name iw_anqp_3gpp_cell_net iw_nai_realm
-	json_get_vars iw_anqp_elem iw_qos_map_set iw_ipaddr_type_availability iw_gas_address3
-	json_get_vars iw_venue_name iw_venue_url
-
-	set_default iw_enabled 0
-	if [ "$iw_enabled" = "1" ]; then
-		append bss_conf "interworking=1" "$N"
-		set_default iw_internet 1
-		set_default iw_asra 0
-		set_default iw_esr 0
-		set_default iw_uesa 0
-
-		append bss_conf "internet=$iw_internet" "$N"
-		append bss_conf "asra=$iw_asra" "$N"
-		append bss_conf "esr=$iw_esr" "$N"
-		append bss_conf "uesa=$iw_uesa" "$N"
-
-		[ -n "$iw_access_network_type" ] && \
-			append bss_conf "access_network_type=$iw_access_network_type" "$N"
-		[ -n "$iw_hessid" ] && append bss_conf "hessid=$iw_hessid" "$N"
-		[ -n "$iw_venue_group" ] && \
-			append bss_conf "venue_group=$iw_venue_group" "$N"
-		[ -n "$iw_venue_type" ] && append bss_conf "venue_type=$iw_venue_type" "$N"
-		[ -n "$iw_network_auth_type" ] && \
-			append bss_conf "network_auth_type=$iw_network_auth_type" "$N"
-		[ -n "$iw_gas_address3" ] && append bss_conf "gas_address3=$iw_gas_address3" "$N"
-
-		json_for_each_item append_iw_roaming_consortium iw_roaming_consortium
-		json_for_each_item append_iw_anqp_elem iw_anqp_elem
-		json_for_each_item append_iw_nai_realm iw_nai_realm
-		json_for_each_item append_iw_venue_name iw_venue_name
-		json_for_each_item append_iw_venue_url iw_venue_url
-
-		iw_domain_name_conf=
-		json_for_each_item append_iw_domain_name iw_domain_name
-		[ -n "$iw_domain_name_conf" ] && \
-			append bss_conf "domain_name=$iw_domain_name_conf" "$N"
-
-		iw_anqp_3gpp_cell_net_conf=
-		json_for_each_item append_iw_anqp_3gpp_cell_net iw_anqp_3gpp_cell_net
-		[ -n "$iw_anqp_3gpp_cell_net_conf" ] && \
-			append bss_conf "anqp_3gpp_cell_net=$iw_anqp_3gpp_cell_net_conf" "$N"
-	fi
-
-	set_default iw_qos_map_set 0,0,2,16,1,1,255,255,18,22,24,38,40,40,44,46,48,56
-	case "$iw_qos_map_set" in
-		*,*);;
-		*) iw_qos_map_set="";;
-	esac
-	[ -n "$iw_qos_map_set" ] && append bss_conf "qos_map_set=$iw_qos_map_set" "$N"
-
-	local hs20 disable_dgaf osen anqp_domain_id hs20_deauth_req_timeout \
-		osu_ssid hs20_wan_metrics hs20_operating_class hs20_t_c_filename hs20_t_c_timestamp \
-		hs20_t_c_server_url
-	json_get_vars hs20 disable_dgaf osen anqp_domain_id hs20_deauth_req_timeout \
-		osu_ssid hs20_wan_metrics hs20_operating_class hs20_t_c_filename hs20_t_c_timestamp \
-		hs20_t_c_server_url
-
-	set_default hs20 0
-	set_default disable_dgaf $hs20
-	set_default osen 0
-	set_default anqp_domain_id 0
-	set_default hs20_deauth_req_timeout 60
-	if [ "$hs20" = "1" ]; then
-		append bss_conf "hs20=1" "$N"
-		append_hs20_icons
-		append bss_conf "disable_dgaf=$disable_dgaf" "$N"
-		append bss_conf "osen=$osen" "$N"
-		append bss_conf "anqp_domain_id=$anqp_domain_id" "$N"
-		append bss_conf "hs20_deauth_req_timeout=$hs20_deauth_req_timeout" "$N"
-		[ -n "$osu_ssid" ] && append bss_conf "osu_ssid=$osu_ssid" "$N"
-		[ -n "$hs20_wan_metrics" ] && append bss_conf "hs20_wan_metrics=$hs20_wan_metrics" "$N"
-		[ -n "$hs20_operating_class" ] && append bss_conf "hs20_operating_class=$hs20_operating_class" "$N"
-		[ -n "$hs20_t_c_filename" ] && append bss_conf "hs20_t_c_filename=$hs20_t_c_filename" "$N"
-		[ -n "$hs20_t_c_timestamp" ] && append bss_conf "hs20_t_c_timestamp=$hs20_t_c_timestamp" "$N"
-		[ -n "$hs20_t_c_server_url" ] && append bss_conf "hs20_t_c_server_url=$hs20_t_c_server_url" "$N"
-		json_for_each_item append_hs20_oper_friendly_name hs20_oper_friendly_name
-		json_for_each_item append_hs20_conn_capab hs20_conn_capab
-		json_for_each_item append_osu_provider osu_provider
-		json_for_each_item append_operator_icon operator_icon
-	fi
-
-	if [ "$eap_server" = "1" ]; then
-		append bss_conf "eap_server=1" "$N"
-		[ -n "$eap_user_file" ] && append bss_conf "eap_user_file=$eap_user_file" "$N"
-		[ -n "$ca_cert" ] && append bss_conf "ca_cert=$ca_cert" "$N"
-		[ -n "$server_cert" ] && append bss_conf "server_cert=$server_cert" "$N"
-		[ -n "$private_key" ] && append bss_conf "private_key=$private_key" "$N"
-		[ -n "$private_key_passwd" ] && append bss_conf "private_key_passwd=$private_key_passwd" "$N"
-		[ -n "$server_id" ] && append bss_conf "server_id=$server_id" "$N"
-	fi
-
-	set_default multicast_to_unicast 0
-	if [ "$multicast_to_unicast" -gt 0 ]; then
-		append bss_conf "multicast_to_unicast=$multicast_to_unicast" "$N"
-	fi
-
-	set_default per_sta_vif 0
-	if [ "$per_sta_vif" -gt 0 ]; then
-		append bss_conf "per_sta_vif=$per_sta_vif" "$N"
-	fi
-
-	json_get_values opts hostapd_bss_options
-	for val in $opts; do
-		append bss_conf "$val" "$N"
-	done
-
-	bss_md5sum=$(echo $bss_conf | md5sum | cut -d" " -f1)
-	append bss_conf "config_id=$bss_md5sum" "$N"
-
-	append "$var" "$bss_conf" "$N"
-	return 0
-}
-
-hostapd_set_log_options() {
-	local var="$1"
-
-	local log_level log_80211 log_8021x log_radius log_wpa log_driver log_iapp log_mlme
-	json_get_vars log_level log_80211 log_8021x log_radius log_wpa log_driver log_iapp log_mlme
-
-	set_default log_level 2
-	set_default log_80211  1
-	set_default log_8021x  1
-	set_default log_radius 1
-	set_default log_wpa    1
-	set_default log_driver 1
-	set_default log_iapp   1
-	set_default log_mlme   1
-
-	local log_mask=$(( \
-		($log_80211  << 0) | \
-		($log_8021x  << 1) | \
-		($log_radius << 2) | \
-		($log_wpa    << 3) | \
-		($log_driver << 4) | \
-		($log_iapp   << 5) | \
-		($log_mlme   << 6)   \
-	))
-
-	append "$var" "logger_syslog=$log_mask" "$N"
-	append "$var" "logger_syslog_level=$log_level" "$N"
-	append "$var" "logger_stdout=$log_mask" "$N"
-	append "$var" "logger_stdout_level=$log_level" "$N"
-
-	return 0
-}
-
-_wpa_supplicant_common() {
-	local ifname="$1"
-
-	_rpath="/var/run/wpa_supplicant"
-	_config="${_rpath}-$ifname.conf"
-}
-
-wpa_supplicant_teardown_interface() {
-	_wpa_supplicant_common "$1"
-	rm -rf "$_rpath/$1" "$_config"
-}
-
-wpa_supplicant_prepare_interface() {
-	local ifname="$1"
-	_w_driver="$2"
-
-	_wpa_supplicant_common "$1"
-
-	json_get_vars mode wds multi_ap
-
-	[ -n "$network_bridge" ] && {
-		fail=
-		case "$mode" in
-			adhoc)
-				fail=1
-			;;
-			sta)
-				[ "$wds" = 1 -o "$multi_ap" = 1 ] || fail=1
-			;;
-		esac
-
-		[ -n "$fail" ] && {
-			wireless_setup_vif_failed BRIDGE_NOT_ALLOWED
-			return 1
-		}
-	}
-
-	local ap_scan=
-
-	_w_mode="$mode"
-
-	[ "$mode" = adhoc ] && {
-		ap_scan="ap_scan=2"
-	}
-
-	local country_str=
-	[ -n "$country" ] && {
-		country_str="country=$country"
-	}
-
-	multiap_flag_file="${_config}.is_multiap"
-	if [ "$multi_ap" = "1" ]; then
-		touch "$multiap_flag_file"
-	else
-		[ -e "$multiap_flag_file" ] && rm "$multiap_flag_file"
-	fi
-	wpa_supplicant_teardown_interface "$ifname"
-	cat > "$_config" <<EOF
-${scan_list:+freq_list=$scan_list}
-$ap_scan
-$country_str
-EOF
-	return 0
-}
-
-wpa_supplicant_set_fixed_freq() {
-	local freq="$1"
-	local htmode="$2"
-
-	append network_data "fixed_freq=1" "$N$T"
-	append network_data "frequency=$freq" "$N$T"
-	case "$htmode" in
-		NOHT) append network_data "disable_ht=1" "$N$T";;
-		HE20|HT20|VHT20) append network_data "disable_ht40=1" "$N$T";;
-		HT40*|VHT40|VHT80|VHT160|HE40|HE80|HE160) append network_data "ht40=1" "$N$T";;
-	esac
-	case "$htmode" in
-		VHT*) append network_data "vht=1" "$N$T";;
-	esac
-	case "$htmode" in
-		HE80|VHT80) append network_data "max_oper_chwidth=1" "$N$T";;
-		HE160|VHT160) append network_data "max_oper_chwidth=2" "$N$T";;
-		HE20|HE40|VHT20|VHT40) append network_data "max_oper_chwidth=0" "$N$T";;
-		*) append network_data "disable_vht=1" "$N$T";;
-	esac
-}
-
-wpa_supplicant_add_network() {
-	local ifname="$1"
-	local freq="$2"
-	local htmode="$3"
-	local noscan="$4"
-
-	_wpa_supplicant_common "$1"
-	wireless_vif_parse_encryption
-
-	json_get_vars \
-		ssid bssid key \
-		basic_rate mcast_rate \
-		ieee80211w ieee80211r \
-		multi_ap
-
-	case "$auth_type" in
-		sae|owe|eap192|eap-eap192)
-			set_default ieee80211w 2
-		;;
-		psk-sae)
-			set_default ieee80211w 1
-		;;
-	esac
-
-	set_default ieee80211r 0
-	set_default multi_ap 0
-
-	local key_mgmt='NONE'
-	local network_data=
-	local T="	"
-
-	local scan_ssid="scan_ssid=1"
-	local freq wpa_key_mgmt
-
-	[ "$_w_mode" = "adhoc" ] && {
-		append network_data "mode=1" "$N$T"
-		[ -n "$freq" ] && wpa_supplicant_set_fixed_freq "$freq" "$htmode"
-		[ "$noscan" = "1" ] && append network_data "noscan=1" "$N$T"
-
-		scan_ssid="scan_ssid=0"
-
-		[ "$_w_driver" = "nl80211" ] ||	append wpa_key_mgmt "WPA-NONE"
-	}
-
-	[ "$_w_mode" = "mesh" ] && {
-		json_get_vars mesh_id mesh_fwding mesh_rssi_threshold
-		[ -n "$mesh_id" ] && ssid="${mesh_id}"
-
-		append network_data "mode=5" "$N$T"
-		[ -n "$mesh_fwding" ] && append network_data "mesh_fwding=${mesh_fwding}" "$N$T"
-		[ -n "$mesh_rssi_threshold" ] && append network_data "mesh_rssi_threshold=${mesh_rssi_threshold}" "$N$T"
-		[ -n "$freq" ] && wpa_supplicant_set_fixed_freq "$freq" "$htmode"
-		[ "$noscan" = "1" ] && append network_data "noscan=1" "$N$T"
-		append wpa_key_mgmt "SAE"
-		scan_ssid=""
-	}
-
-	[ "$multi_ap" = 1 -a "$_w_mode" = "sta" ] && append network_data "multi_ap_backhaul_sta=1" "$N$T"
-
-	case "$auth_type" in
-		none) ;;
-		owe)
-			hostapd_append_wpa_key_mgmt
-			key_mgmt="$wpa_key_mgmt"
-		;;
-		wep)
-			local wep_keyidx=0
-			hostapd_append_wep_key network_data
-			append network_data "wep_tx_keyidx=$wep_keyidx" "$N$T"
-		;;
-		wps)
-			key_mgmt='WPS'
-		;;
-		psk|sae|psk-sae)
-			local passphrase
-
-			if [ "$_w_mode" != "mesh" ]; then
-				hostapd_append_wpa_key_mgmt
-			fi
-
-			key_mgmt="$wpa_key_mgmt"
-
-			if [ ${#key} -eq 64 ]; then
-				passphrase="psk=${key}"
-			else
-				if [ "$_w_mode" = "mesh" ]; then
-					passphrase="sae_password=\"${key}\""
-				else
-					passphrase="psk=\"${key}\""
-				fi
-			fi
-			append network_data "$passphrase" "$N$T"
-		;;
-		eap|eap192|eap-eap192)
-			hostapd_append_wpa_key_mgmt
-			key_mgmt="$wpa_key_mgmt"
-
-			json_get_vars eap_type identity anonymous_identity ca_cert ca_cert_usesystem
-
-			if [ "$ca_cert_usesystem" -eq "1" -a -f "/etc/ssl/certs/ca-certificates.crt" ]; then
-				append network_data "ca_cert=\"/etc/ssl/certs/ca-certificates.crt\"" "$N$T"
-			else
-				[ -n "$ca_cert" ] && append network_data "ca_cert=\"$ca_cert\"" "$N$T"
-			fi
-			[ -n "$identity" ] && append network_data "identity=\"$identity\"" "$N$T"
-			[ -n "$anonymous_identity" ] && append network_data "anonymous_identity=\"$anonymous_identity\"" "$N$T"
-			case "$eap_type" in
-				tls)
-					json_get_vars client_cert priv_key priv_key_pwd
-					append network_data "client_cert=\"$client_cert\"" "$N$T"
-					append network_data "private_key=\"$priv_key\"" "$N$T"
-					append network_data "private_key_passwd=\"$priv_key_pwd\"" "$N$T"
-
-					json_get_vars subject_match
-					[ -n "$subject_match" ] && append network_data "subject_match=\"$subject_match\"" "$N$T"
-
-					json_get_values altsubject_match altsubject_match
-					if [ -n "$altsubject_match" ]; then
-						local list=
-						for x in $altsubject_match; do
-							append list "$x" ";"
-						done
-						append network_data "altsubject_match=\"$list\"" "$N$T"
-					fi
-
-					json_get_values domain_match domain_match
-					if [ -n "$domain_match" ]; then
-						local list=
-						for x in $domain_match; do
-							append list "$x" ";"
-						done
-						append network_data "domain_match=\"$list\"" "$N$T"
-					fi
-
-					json_get_values domain_suffix_match domain_suffix_match
-					if [ -n "$domain_suffix_match" ]; then
-						local list=
-						for x in $domain_suffix_match; do
-							append list "$x" ";"
-						done
-						append network_data "domain_suffix_match=\"$list\"" "$N$T"
-					fi
-				;;
-				fast|peap|ttls)
-					json_get_vars auth password ca_cert2 ca_cert2_usesystem client_cert2 priv_key2 priv_key2_pwd
-					set_default auth MSCHAPV2
-
-					if [ "$auth" = "EAP-TLS" ]; then
-						if [ "$ca_cert2_usesystem" -eq "1" -a -f "/etc/ssl/certs/ca-certificates.crt" ]; then
-							append network_data "ca_cert2=\"/etc/ssl/certs/ca-certificates.crt\"" "$N$T"
-						else
-							[ -n "$ca_cert2" ] && append network_data "ca_cert2=\"$ca_cert2\"" "$N$T"
-						fi
-						append network_data "client_cert2=\"$client_cert2\"" "$N$T"
-						append network_data "private_key2=\"$priv_key2\"" "$N$T"
-						append network_data "private_key2_passwd=\"$priv_key2_pwd\"" "$N$T"
-					else
-						append network_data "password=\"$password\"" "$N$T"
-					fi
-
-					json_get_vars subject_match
-					[ -n "$subject_match" ] && append network_data "subject_match=\"$subject_match\"" "$N$T"
-
-					json_get_values altsubject_match altsubject_match
-					if [ -n "$altsubject_match" ]; then
-						local list=
-						for x in $altsubject_match; do
-							append list "$x" ";"
-						done
-						append network_data "altsubject_match=\"$list\"" "$N$T"
-					fi
-
-					json_get_values domain_match domain_match
-					if [ -n "$domain_match" ]; then
-						local list=
-						for x in $domain_match; do
-							append list "$x" ";"
-						done
-						append network_data "domain_match=\"$list\"" "$N$T"
-					fi
-
-					json_get_values domain_suffix_match domain_suffix_match
-					if [ -n "$domain_suffix_match" ]; then
-						local list=
-						for x in $domain_suffix_match; do
-							append list "$x" ";"
-						done
-						append network_data "domain_suffix_match=\"$list\"" "$N$T"
-					fi
-
-					phase2proto="auth="
-					case "$auth" in
-						"auth"*)
-							phase2proto=""
-						;;
-						"EAP-"*)
-							auth="$(echo $auth | cut -b 5- )"
-							[ "$eap_type" = "ttls" ] &&
-								phase2proto="autheap="
-							json_get_vars subject_match2
-							[ -n "$subject_match2" ] && append network_data "subject_match2=\"$subject_match2\"" "$N$T"
-
-							json_get_values altsubject_match2 altsubject_match2
-							if [ -n "$altsubject_match2" ]; then
-								local list=
-								for x in $altsubject_match2; do
-									append list "$x" ";"
-								done
-								append network_data "altsubject_match2=\"$list\"" "$N$T"
-							fi
-
-							json_get_values domain_match2 domain_match2
-							if [ -n "$domain_match2" ]; then
-								local list=
-								for x in $domain_match2; do
-									append list "$x" ";"
-								done
-								append network_data "domain_match2=\"$list\"" "$N$T"
-							fi
-
-							json_get_values domain_suffix_match2 domain_suffix_match2
-							if [ -n "$domain_suffix_match2" ]; then
-								local list=
-								for x in $domain_suffix_match2; do
-									append list "$x" ";"
-								done
-								append network_data "domain_suffix_match2=\"$list\"" "$N$T"
-							fi
-						;;
-					esac
-					append network_data "phase2=\"$phase2proto$auth\"" "$N$T"
-				;;
-			esac
-			append network_data "eap=$(echo $eap_type | tr 'a-z' 'A-Z')" "$N$T"
-		;;
-	esac
-
-	[ "$wpa_cipher" = GCMP ] && {
-		append network_data "pairwise=GCMP" "$N$T"
-		append network_data "group=GCMP" "$N$T"
-	}
-
-	[ "$mode" = mesh ] || {
-		case "$wpa" in
-			1)
-				append network_data "proto=WPA" "$N$T"
-			;;
-			2)
-				append network_data "proto=RSN" "$N$T"
-			;;
-		esac
-
-		case "$ieee80211w" in
-			[012])
-				[ "$wpa" -ge 2 ] && append network_data "ieee80211w=$ieee80211w" "$N$T"
-			;;
-		esac
-	}
-	[ -n "$bssid" ] && append network_data "bssid=$bssid" "$N$T"
-	[ -n "$beacon_int" ] && append network_data "beacon_int=$beacon_int" "$N$T"
-
-	local bssid_blacklist bssid_whitelist
-	json_get_values bssid_blacklist bssid_blacklist
-	json_get_values bssid_whitelist bssid_whitelist
-
-	[ -n "$bssid_blacklist" ] && append network_data "bssid_blacklist=$bssid_blacklist" "$N$T"
-	[ -n "$bssid_whitelist" ] && append network_data "bssid_whitelist=$bssid_whitelist" "$N$T"
-
-	[ -n "$basic_rate" ] && {
-		local br rate_list=
-		for br in $basic_rate; do
-			wpa_supplicant_add_rate rate_list "$br"
-		done
-		[ -n "$rate_list" ] && append network_data "rates=$rate_list" "$N$T"
-	}
-
-	[ -n "$mcast_rate" ] && {
-		local mc_rate=
-		wpa_supplicant_add_rate mc_rate "$mcast_rate"
-		append network_data "mcast_rate=$mc_rate" "$N$T"
-	}
-
-	if [ "$key_mgmt" = "WPS" ]; then
-		echo "wps_cred_processing=1" >> "$_config"
-	else
-		cat >> "$_config" <<EOF
-network={
-	$scan_ssid
-	ssid="$ssid"
-	key_mgmt=$key_mgmt
-	$network_data
-}
-EOF
-	fi
-	return 0
-}
-
-wpa_supplicant_run() {
-	local ifname="$1"
-	local hostapd_ctrl="$2"
-
-	_wpa_supplicant_common "$ifname"
-
-	ubus wait_for wpa_supplicant
-	local supplicant_res="$(ubus call wpa_supplicant config_add "{ \
-		\"driver\": \"${_w_driver:-wext}\", \"ctrl\": \"$_rpath\", \
-		\"iface\": \"$ifname\", \"config\": \"$_config\" \
-		${network_bridge:+, \"bridge\": \"$network_bridge\"} \
-		${hostapd_ctrl:+, \"hostapd_ctrl\": \"$hostapd_ctrl\"} \
-		}")"
-
-	ret="$?"
-
-	[ "$ret" != 0 -o -z "$supplicant_res" ] && wireless_setup_vif_failed WPA_SUPPLICANT_FAILED
-
-	wireless_add_process "$(jsonfilter -s "$supplicant_res" -l 1 -e @.pid)" "/usr/sbin/wpa_supplicant" 1 1
-
-	return $ret
-}
-
-hostapd_common_cleanup() {
-	killall meshd-nl80211
-}
diff --git a/package/network/services/hostapd/files/multicall.c b/package/network/services/hostapd/files/multicall.c
deleted file mode 100644
index c8e814bb5c..0000000000
--- a/package/network/services/hostapd/files/multicall.c
+++ /dev/null
@@ -1,28 +0,0 @@
-#include <stdio.h>
-#include <string.h>
-#include <stdbool.h>
-
-extern int hostapd_main(int argc, char **argv);
-extern int wpa_supplicant_main(int argc, char **argv);
-
-int main(int argc, char **argv)
-{
-	bool restart = false;
-	const char *prog = argv[0];
-
-restart:
-	if (strstr(argv[0], "hostapd"))
-		return hostapd_main(argc, argv);
-	else if (strstr(argv[0], "wpa_supplicant"))
-		return wpa_supplicant_main(argc, argv);
-
-	if (!restart && argc > 1) {
-		argv++;
-		argc--;
-		restart = true;
-		goto restart;
-	}
-
-	fprintf(stderr, "Invalid command.\nUsage: %s wpa_supplicant|hostapd [<arguments>]\n", prog);
-	return 255;
-}
diff --git a/package/network/services/hostapd/files/wpa_supplicant-basic.config b/package/network/services/hostapd/files/wpa_supplicant-basic.config
deleted file mode 100644
index c550b37b21..0000000000
--- a/package/network/services/hostapd/files/wpa_supplicant-basic.config
+++ /dev/null
@@ -1,625 +0,0 @@
-# Example wpa_supplicant build time configuration
-#
-# This file lists the configuration options that are used when building the
-# wpa_supplicant binary. All lines starting with # are ignored. Configuration
-# option lines must be commented out complete, if they are not to be included,
-# i.e., just setting VARIABLE=n is not disabling that variable.
-#
-# This file is included in Makefile, so variables like CFLAGS and LIBS can also
-# be modified from here. In most cases, these lines should use += in order not
-# to override previous values of the variables.
-
-
-# Uncomment following two lines and fix the paths if you have installed OpenSSL
-# or GnuTLS in non-default location
-#CFLAGS += -I/usr/local/openssl/include
-#LIBS += -L/usr/local/openssl/lib
-
-# Some Red Hat versions seem to include kerberos header files from OpenSSL, but
-# the kerberos files are not in the default include path. Following line can be
-# used to fix build issues on such systems (krb5.h not found).
-#CFLAGS += -I/usr/include/kerberos
-
-# Driver interface for generic Linux wireless extensions
-# Note: WEXT is deprecated in the current Linux kernel version and no new
-# functionality is added to it. nl80211-based interface is the new
-# replacement for WEXT and its use allows wpa_supplicant to properly control
-# the driver to improve existing functionality like roaming and to support new
-# functionality.
-CONFIG_DRIVER_WEXT=y
-
-# Driver interface for Linux drivers using the nl80211 kernel interface
-CONFIG_DRIVER_NL80211=y
-
-# QCA vendor extensions to nl80211
-#CONFIG_DRIVER_NL80211_QCA=y
-
-# driver_nl80211.c requires libnl. If you are compiling it yourself
-# you may need to point hostapd to your version of libnl.
-#
-#CFLAGS += -I$<path to libnl include files>
-#LIBS += -L$<path to libnl library files>
-
-# Use libnl v2.0 (or 3.0) libraries.
-#CONFIG_LIBNL20=y
-
-# Use libnl 3.2 libraries (if this is selected, CONFIG_LIBNL20 is ignored)
-#CONFIG_LIBNL32=y
-
-
-# Driver interface for FreeBSD net80211 layer (e.g., Atheros driver)
-#CONFIG_DRIVER_BSD=y
-#CFLAGS += -I/usr/local/include
-#LIBS += -L/usr/local/lib
-#LIBS_p += -L/usr/local/lib
-#LIBS_c += -L/usr/local/lib
-
-# Driver interface for Windows NDIS
-#CONFIG_DRIVER_NDIS=y
-#CFLAGS += -I/usr/include/w32api/ddk
-#LIBS += -L/usr/local/lib
-# For native build using mingw
-#CONFIG_NATIVE_WINDOWS=y
-# Additional directories for cross-compilation on Linux host for mingw target
-#CFLAGS += -I/opt/mingw/mingw32/include/ddk
-#LIBS += -L/opt/mingw/mingw32/lib
-#CC=mingw32-gcc
-# By default, driver_ndis uses WinPcap for low-level operations. This can be
-# replaced with the following option which replaces WinPcap calls with NDISUIO.
-# However, this requires that WZC is disabled (net stop wzcsvc) before starting
-# wpa_supplicant.
-# CONFIG_USE_NDISUIO=y
-
-# Driver interface for wired Ethernet drivers
-CONFIG_DRIVER_WIRED=y
-
-# Driver interface for MACsec capable Qualcomm Atheros drivers
-#CONFIG_DRIVER_MACSEC_QCA=y
-
-# Driver interface for Linux MACsec drivers
-#CONFIG_DRIVER_MACSEC_LINUX=y
-
-# Driver interface for the Broadcom RoboSwitch family
-#CONFIG_DRIVER_ROBOSWITCH=y
-
-# Driver interface for no driver (e.g., WPS ER only)
-#CONFIG_DRIVER_NONE=y
-
-# Solaris libraries
-#LIBS += -lsocket -ldlpi -lnsl
-#LIBS_c += -lsocket
-
-# Enable IEEE 802.1X Supplicant (automatically included if any EAP method or
-# MACsec is included)
-#CONFIG_IEEE8021X_EAPOL=y
-
-# EAP-MD5
-#CONFIG_EAP_MD5=y
-
-# EAP-MSCHAPv2
-#CONFIG_EAP_MSCHAPV2=y
-
-# EAP-TLS
-#CONFIG_EAP_TLS=y
-
-# EAL-PEAP
-#CONFIG_EAP_PEAP=y
-
-# EAP-TTLS
-#CONFIG_EAP_TTLS=y
-
-# EAP-FAST
-#CONFIG_EAP_FAST=y
-
-# EAP-TEAP
-# Note: The current EAP-TEAP implementation is experimental and should not be
-# enabled for production use. The IETF RFC 7170 that defines EAP-TEAP has number
-# of conflicting statements and missing details and the implementation has
-# vendor specific workarounds for those and as such, may not interoperate with
-# any other implementation. This should not be used for anything else than
-# experimentation and interoperability testing until those issues has been
-# resolved.
-#CONFIG_EAP_TEAP=y
-
-# EAP-GTC
-#CONFIG_EAP_GTC=y
-
-# EAP-OTP
-#CONFIG_EAP_OTP=y
-
-# EAP-SIM (enable CONFIG_PCSC, if EAP-SIM is used)
-#CONFIG_EAP_SIM=y
-
-# Enable SIM simulator (Milenage) for EAP-SIM
-#CONFIG_SIM_SIMULATOR=y
-
-# EAP-PSK (experimental; this is _not_ needed for WPA-PSK)
-#CONFIG_EAP_PSK=y
-
-# EAP-pwd (secure authentication using only a password)
-#CONFIG_EAP_PWD=y
-
-# EAP-PAX
-#CONFIG_EAP_PAX=y
-
-# LEAP
-#CONFIG_EAP_LEAP=y
-
-# EAP-AKA (enable CONFIG_PCSC, if EAP-AKA is used)
-#CONFIG_EAP_AKA=y
-
-# EAP-AKA' (enable CONFIG_PCSC, if EAP-AKA' is used).
-# This requires CONFIG_EAP_AKA to be enabled, too.
-#CONFIG_EAP_AKA_PRIME=y
-
-# Enable USIM simulator (Milenage) for EAP-AKA
-#CONFIG_USIM_SIMULATOR=y
-
-# EAP-SAKE
-#CONFIG_EAP_SAKE=y
-
-# EAP-GPSK
-#CONFIG_EAP_GPSK=y
-# Include support for optional SHA256 cipher suite in EAP-GPSK
-#CONFIG_EAP_GPSK_SHA256=y
-
-# EAP-TNC and related Trusted Network Connect support (experimental)
-#CONFIG_EAP_TNC=y
-
-# Wi-Fi Protected Setup (WPS)
-#CONFIG_WPS=y
-# Enable WPS external registrar functionality
-#CONFIG_WPS_ER=y
-# Disable credentials for an open network by default when acting as a WPS
-# registrar.
-#CONFIG_WPS_REG_DISABLE_OPEN=y
-# Enable WPS support with NFC config method
-#CONFIG_WPS_NFC=y
-
-# EAP-IKEv2
-#CONFIG_EAP_IKEV2=y
-
-# EAP-EKE
-#CONFIG_EAP_EKE=y
-
-# MACsec
-#CONFIG_MACSEC=y
-
-# PKCS#12 (PFX) support (used to read private key and certificate file from
-# a file that usually has extension .p12 or .pfx)
-#CONFIG_PKCS12=y
-
-# Smartcard support (i.e., private key on a smartcard), e.g., with openssl
-# engine.
-#CONFIG_SMARTCARD=y
-
-# PC/SC interface for smartcards (USIM, GSM SIM)
-# Enable this if EAP-SIM or EAP-AKA is included
-#CONFIG_PCSC=y
-
-# Support HT overrides (disable HT/HT40, mask MCS rates, etc.)
-CONFIG_HT_OVERRIDES=y
-
-# Support VHT overrides (disable VHT, mask MCS rates, etc.)
-CONFIG_VHT_OVERRIDES=y
-
-# Development testing
-#CONFIG_EAPOL_TEST=y
-
-# Select control interface backend for external programs, e.g, wpa_cli:
-# unix = UNIX domain sockets (default for Linux/*BSD)
-# udp = UDP sockets using localhost (127.0.0.1)
-# udp6 = UDP IPv6 sockets using localhost (::1)
-# named_pipe = Windows Named Pipe (default for Windows)
-# udp-remote = UDP sockets with remote access (only for tests systems/purpose)
-# udp6-remote = UDP IPv6 sockets with remote access (only for tests purpose)
-# y = use default (backwards compatibility)
-# If this option is commented out, control interface is not included in the
-# build.
-CONFIG_CTRL_IFACE=y
-
-# Include support for GNU Readline and History Libraries in wpa_cli.
-# When building a wpa_cli binary for distribution, please note that these
-# libraries are licensed under GPL and as such, BSD license may not apply for
-# the resulting binary.
-#CONFIG_READLINE=y
-
-# Include internal line edit mode in wpa_cli. This can be used as a replacement
-# for GNU Readline to provide limited command line editing and history support.
-#CONFIG_WPA_CLI_EDIT=y
-
-# Remove debugging code that is printing out debug message to stdout.
-# This can be used to reduce the size of the wpa_supplicant considerably
-# if debugging code is not needed. The size reduction can be around 35%
-# (e.g., 90 kB).
-#CONFIG_NO_STDOUT_DEBUG=y
-
-# Remove WPA support, e.g., for wired-only IEEE 802.1X supplicant, to save
-# 35-50 kB in code size.
-#CONFIG_NO_WPA=y
-
-# Remove IEEE 802.11i/WPA-Personal ASCII passphrase support
-# This option can be used to reduce code size by removing support for
-# converting ASCII passphrases into PSK. If this functionality is removed, the
-# PSK can only be configured as the 64-octet hexstring (e.g., from
-# wpa_passphrase). This saves about 0.5 kB in code size.
-#CONFIG_NO_WPA_PASSPHRASE=y
-
-# Simultaneous Authentication of Equals (SAE), WPA3-Personal
-#CONFIG_SAE=y
-
-# Disable scan result processing (ap_mode=1) to save code size by about 1 kB.
-# This can be used if ap_scan=1 mode is never enabled.
-#CONFIG_NO_SCAN_PROCESSING=y
-
-# Select configuration backend:
-# file = text file (e.g., wpa_supplicant.conf; note: the configuration file
-#	path is given on command line, not here; this option is just used to
-#	select the backend that allows configuration files to be used)
-# winreg = Windows registry (see win_example.reg for an example)
-CONFIG_BACKEND=file
-
-# Remove configuration write functionality (i.e., to allow the configuration
-# file to be updated based on runtime configuration changes). The runtime
-# configuration can still be changed, the changes are just not going to be
-# persistent over restarts. This option can be used to reduce code size by
-# about 3.5 kB.
-CONFIG_NO_CONFIG_WRITE=y
-
-# Remove support for configuration blobs to reduce code size by about 1.5 kB.
-#CONFIG_NO_CONFIG_BLOBS=y
-
-# Select program entry point implementation:
-# main = UNIX/POSIX like main() function (default)
-# main_winsvc = Windows service (read parameters from registry)
-# main_none = Very basic example (development use only)
-#CONFIG_MAIN=main
-
-# Select wrapper for operating system and C library specific functions
-# unix = UNIX/POSIX like systems (default)
-# win32 = Windows systems
-# none = Empty template
-#CONFIG_OS=unix
-
-# Select event loop implementation
-# eloop = select() loop (default)
-# eloop_win = Windows events and WaitForMultipleObject() loop
-#CONFIG_ELOOP=eloop
-
-# Should we use poll instead of select? Select is used by default.
-#CONFIG_ELOOP_POLL=y
-
-# Should we use epoll instead of select? Select is used by default.
-CONFIG_ELOOP_EPOLL=y
-
-# Should we use kqueue instead of select? Select is used by default.
-#CONFIG_ELOOP_KQUEUE=y
-
-# Select layer 2 packet implementation
-# linux = Linux packet socket (default)
-# pcap = libpcap/libdnet/WinPcap
-# freebsd = FreeBSD libpcap
-# winpcap = WinPcap with receive thread
-# ndis = Windows NDISUIO (note: requires CONFIG_USE_NDISUIO=y)
-# none = Empty template
-#CONFIG_L2_PACKET=linux
-
-# Disable Linux packet socket workaround applicable for station interface
-# in a bridge for EAPOL frames. This should be uncommented only if the kernel
-# is known to not have the regression issue in packet socket behavior with
-# bridge interfaces (commit 'bridge: respect RFC2863 operational state')').
-CONFIG_NO_LINUX_PACKET_SOCKET_WAR=y
-
-# IEEE 802.11w (management frame protection), also known as PMF
-# Driver support is also needed for IEEE 802.11w.
-#CONFIG_IEEE80211W=y
-
-# Support Operating Channel Validation
-#CONFIG_OCV=y
-
-# Select TLS implementation
-# openssl = OpenSSL (default)
-# gnutls = GnuTLS
-# internal = Internal TLSv1 implementation (experimental)
-# linux = Linux kernel AF_ALG and internal TLSv1 implementation (experimental)
-# none = Empty template
-CONFIG_TLS=internal
-
-# TLS-based EAP methods require at least TLS v1.0. Newer version of TLS (v1.1)
-# can be enabled to get a stronger construction of messages when block ciphers
-# are used. It should be noted that some existing TLS v1.0 -based
-# implementation may not be compatible with TLS v1.1 message (ClientHello is
-# sent prior to negotiating which version will be used)
-#CONFIG_TLSV11=y
-
-# TLS-based EAP methods require at least TLS v1.0. Newer version of TLS (v1.2)
-# can be enabled to enable use of stronger crypto algorithms. It should be
-# noted that some existing TLS v1.0 -based implementation may not be compatible
-# with TLS v1.2 message (ClientHello is sent prior to negotiating which version
-# will be used)
-#CONFIG_TLSV12=y
-
-# Select which ciphers to use by default with OpenSSL if the user does not
-# specify them.
-#CONFIG_TLS_DEFAULT_CIPHERS="DEFAULT:!EXP:!LOW"
-
-# If CONFIG_TLS=internal is used, additional library and include paths are
-# needed for LibTomMath. Alternatively, an integrated, minimal version of
-# LibTomMath can be used. See beginning of libtommath.c for details on benefits
-# and drawbacks of this option.
-#CONFIG_INTERNAL_LIBTOMMATH=y
-#ifndef CONFIG_INTERNAL_LIBTOMMATH
-#LTM_PATH=/usr/src/libtommath-0.39
-#CFLAGS += -I$(LTM_PATH)
-#LIBS += -L$(LTM_PATH)
-#LIBS_p += -L$(LTM_PATH)
-#endif
-# At the cost of about 4 kB of additional binary size, the internal LibTomMath
-# can be configured to include faster routines for exptmod, sqr, and div to
-# speed up DH and RSA calculation considerably
-#CONFIG_INTERNAL_LIBTOMMATH_FAST=y
-
-# Include NDIS event processing through WMI into wpa_supplicant/wpasvc.
-# This is only for Windows builds and requires WMI-related header files and
-# WbemUuid.Lib from Platform SDK even when building with MinGW.
-#CONFIG_NDIS_EVENTS_INTEGRATED=y
-#PLATFORMSDKLIB="/opt/Program Files/Microsoft Platform SDK/Lib"
-
-# Add support for new DBus control interface
-# (fi.w1.hostap.wpa_supplicant1)
-#CONFIG_CTRL_IFACE_DBUS_NEW=y
-
-# Add introspection support for new DBus control interface
-#CONFIG_CTRL_IFACE_DBUS_INTRO=y
-
-# Add support for loading EAP methods dynamically as shared libraries.
-# When this option is enabled, each EAP method can be either included
-# statically (CONFIG_EAP_<method>=y) or dynamically (CONFIG_EAP_<method>=dyn).
-# Dynamic EAP methods are build as shared objects (eap_*.so) and they need to
-# be loaded in the beginning of the wpa_supplicant configuration file
-# (see load_dynamic_eap parameter in the example file) before being used in
-# the network blocks.
-#
-# Note that some shared parts of EAP methods are included in the main program
-# and in order to be able to use dynamic EAP methods using these parts, the
-# main program must have been build with the EAP method enabled (=y or =dyn).
-# This means that EAP-TLS/PEAP/TTLS/FAST cannot be added as dynamic libraries
-# unless at least one of them was included in the main build to force inclusion
-# of the shared code. Similarly, at least one of EAP-SIM/AKA must be included
-# in the main build to be able to load these methods dynamically.
-#
-# Please also note that using dynamic libraries will increase the total binary
-# size. Thus, it may not be the best option for targets that have limited
-# amount of memory/flash.
-#CONFIG_DYNAMIC_EAP_METHODS=y
-
-# IEEE Std 802.11r-2008 (Fast BSS Transition) for station mode
-CONFIG_IEEE80211R=y
-
-# Add support for writing debug log to a file (/tmp/wpa_supplicant-log-#.txt)
-#CONFIG_DEBUG_FILE=y
-
-# Send debug messages to syslog instead of stdout
-CONFIG_DEBUG_SYSLOG=y
-# Set syslog facility for debug messages
-CONFIG_DEBUG_SYSLOG_FACILITY=LOG_DAEMON
-
-# Add support for sending all debug messages (regardless of debug verbosity)
-# to the Linux kernel tracing facility. This helps debug the entire stack by
-# making it easy to record everything happening from the driver up into the
-# same file, e.g., using trace-cmd.
-#CONFIG_DEBUG_LINUX_TRACING=y
-
-# Add support for writing debug log to Android logcat instead of standard
-# output
-#CONFIG_ANDROID_LOG=y
-
-# Enable privilege separation (see README 'Privilege separation' for details)
-#CONFIG_PRIVSEP=y
-
-# Enable mitigation against certain attacks against TKIP by delaying Michael
-# MIC error reports by a random amount of time between 0 and 60 seconds
-#CONFIG_DELAYED_MIC_ERROR_REPORT=y
-
-# Enable tracing code for developer debugging
-# This tracks use of memory allocations and other registrations and reports
-# incorrect use with a backtrace of call (or allocation) location.
-#CONFIG_WPA_TRACE=y
-# For BSD, uncomment these.
-#LIBS += -lexecinfo
-#LIBS_p += -lexecinfo
-#LIBS_c += -lexecinfo
-
-# Use libbfd to get more details for developer debugging
-# This enables use of libbfd to get more detailed symbols for the backtraces
-# generated by CONFIG_WPA_TRACE=y.
-#CONFIG_WPA_TRACE_BFD=y
-# For BSD, uncomment these.
-#LIBS += -lbfd -liberty -lz
-#LIBS_p += -lbfd -liberty -lz
-#LIBS_c += -lbfd -liberty -lz
-
-# wpa_supplicant depends on strong random number generation being available
-# from the operating system. os_get_random() function is used to fetch random
-# data when needed, e.g., for key generation. On Linux and BSD systems, this
-# works by reading /dev/urandom. It should be noted that the OS entropy pool
-# needs to be properly initialized before wpa_supplicant is started. This is
-# important especially on embedded devices that do not have a hardware random
-# number generator and may by default start up with minimal entropy available
-# for random number generation.
-#
-# As a safety net, wpa_supplicant is by default trying to internally collect
-# additional entropy for generating random data to mix in with the data fetched
-# from the OS. This by itself is not considered to be very strong, but it may
-# help in cases where the system pool is not initialized properly. However, it
-# is very strongly recommended that the system pool is initialized with enough
-# entropy either by using hardware assisted random number generator or by
-# storing state over device reboots.
-#
-# wpa_supplicant can be configured to maintain its own entropy store over
-# restarts to enhance random number generation. This is not perfect, but it is
-# much more secure than using the same sequence of random numbers after every
-# reboot. This can be enabled with -e<entropy file> command line option. The
-# specified file needs to be readable and writable by wpa_supplicant.
-#
-# If the os_get_random() is known to provide strong random data (e.g., on
-# Linux/BSD, the board in question is known to have reliable source of random
-# data from /dev/urandom), the internal wpa_supplicant random pool can be
-# disabled. This will save some in binary size and CPU use. However, this
-# should only be considered for builds that are known to be used on devices
-# that meet the requirements described above.
-CONFIG_NO_RANDOM_POOL=y
-
-# Should we attempt to use the getrandom(2) call that provides more reliable
-# yet secure randomness source than /dev/random on Linux 3.17 and newer.
-# Requires glibc 2.25 to build, falls back to /dev/random if unavailable.
-CONFIG_GETRANDOM=y
-
-# IEEE 802.11n (High Throughput) support (mainly for AP mode)
-#CONFIG_IEEE80211N=y
-
-# IEEE 802.11ac (Very High Throughput) support (mainly for AP mode)
-# (depends on CONFIG_IEEE80211N)
-#CONFIG_IEEE80211AC=y
-
-# Wireless Network Management (IEEE Std 802.11v-2011)
-# Note: This is experimental and not complete implementation.
-#CONFIG_WNM=y
-
-# Interworking (IEEE 802.11u)
-# This can be used to enable functionality to improve interworking with
-# external networks (GAS/ANQP to learn more about the networks and network
-# selection based on available credentials).
-#CONFIG_INTERWORKING=y
-
-# Hotspot 2.0
-#CONFIG_HS20=y
-
-# Enable interface matching in wpa_supplicant
-#CONFIG_MATCH_IFACE=y
-
-# Disable roaming in wpa_supplicant
-#CONFIG_NO_ROAMING=y
-
-# AP mode operations with wpa_supplicant
-# This can be used for controlling AP mode operations with wpa_supplicant. It
-# should be noted that this is mainly aimed at simple cases like
-# WPA2-Personal while more complex configurations like WPA2-Enterprise with an
-# external RADIUS server can be supported with hostapd.
-#CONFIG_AP=y
-
-# P2P (Wi-Fi Direct)
-# This can be used to enable P2P support in wpa_supplicant. See README-P2P for
-# more information on P2P operations.
-#CONFIG_P2P=y
-
-# Enable TDLS support
-#CONFIG_TDLS=y
-
-# Wi-Fi Display
-# This can be used to enable Wi-Fi Display extensions for P2P using an external
-# program to control the additional information exchanges in the messages.
-#CONFIG_WIFI_DISPLAY=y
-
-# Autoscan
-# This can be used to enable automatic scan support in wpa_supplicant.
-# See wpa_supplicant.conf for more information on autoscan usage.
-#
-# Enabling directly a module will enable autoscan support.
-# For exponential module:
-#CONFIG_AUTOSCAN_EXPONENTIAL=y
-# For periodic module:
-#CONFIG_AUTOSCAN_PERIODIC=y
-
-# Password (and passphrase, etc.) backend for external storage
-# These optional mechanisms can be used to add support for storing passwords
-# and other secrets in external (to wpa_supplicant) location. This allows, for
-# example, operating system specific key storage to be used
-#
-# External password backend for testing purposes (developer use)
-#CONFIG_EXT_PASSWORD_TEST=y
-
-# Enable Fast Session Transfer (FST)
-#CONFIG_FST=y
-
-# Enable CLI commands for FST testing
-#CONFIG_FST_TEST=y
-
-# OS X builds. This is only for building eapol_test.
-#CONFIG_OSX=y
-
-# Automatic Channel Selection
-# This will allow wpa_supplicant to pick the channel automatically when channel
-# is set to "0".
-#
-# TODO: Extend parser to be able to parse "channel=acs_survey" as an alternative
-# to "channel=0". This would enable us to eventually add other ACS algorithms in
-# similar way.
-#
-# Automatic selection is currently only done through initialization, later on
-# we hope to do background checks to keep us moving to more ideal channels as
-# time goes by. ACS is currently only supported through the nl80211 driver and
-# your driver must have survey dump capability that is filled by the driver
-# during scanning.
-#
-# TODO: In analogy to hostapd be able to customize the ACS survey algorithm with
-# a newly to create wpa_supplicant.conf variable acs_num_scans.
-#
-# Supported ACS drivers:
-# * ath9k
-# * ath5k
-# * ath10k
-#
-# For more details refer to:
-# http://wireless.kernel.org/en/users/Documentation/acs
-#CONFIG_ACS=y
-
-# Support Multi Band Operation
-#CONFIG_MBO=y
-
-# Fast Initial Link Setup (FILS) (IEEE 802.11ai)
-#CONFIG_FILS=y
-# FILS shared key authentication with PFS
-#CONFIG_FILS_SK_PFS=y
-
-# Support RSN on IBSS networks
-# This is needed to be able to use mode=1 network profile with proto=RSN and
-# key_mgmt=WPA-PSK (i.e., full key management instead of WPA-None).
-#CONFIG_IBSS_RSN=y
-
-# External PMKSA cache control
-# This can be used to enable control interface commands that allow the current
-# PMKSA cache entries to be fetched and new entries to be added.
-#CONFIG_PMKSA_CACHE_EXTERNAL=y
-
-# Mesh Networking (IEEE 802.11s)
-#CONFIG_MESH=y
-
-# Background scanning modules
-# These can be used to request wpa_supplicant to perform background scanning
-# operations for roaming within an ESS (same SSID). See the bgscan parameter in
-# the wpa_supplicant.conf file for more details.
-# Periodic background scans based on signal strength
-#CONFIG_BGSCAN_SIMPLE=y
-# Learn channels used by the network and try to avoid bgscans on other
-# channels (experimental)
-#CONFIG_BGSCAN_LEARN=y
-
-# Opportunistic Wireless Encryption (OWE)
-# Experimental implementation of draft-harkins-owe-07.txt
-#CONFIG_OWE=y
-
-# Device Provisioning Protocol (DPP)
-# This requires CONFIG_IEEE80211W=y to be enabled, too. (see
-# wpa_supplicant/README-DPP for details)
-#CONFIG_DPP=y
-
-# uBus IPC/RPC System
-# Services can connect to the bus and provide methods
-# that can be called by other services or clients.
-CONFIG_UBUS=y
-
-# OpenWrt patch 380-disable-ctrl-iface-mib.patch
-# leads to the MIB only being compiled in if
-# CONFIG_CTRL_IFACE_MIB is enabled.
-#CONFIG_CTRL_IFACE_MIB=y
diff --git a/package/network/services/hostapd/files/wpa_supplicant-full.config b/package/network/services/hostapd/files/wpa_supplicant-full.config
deleted file mode 100644
index b3e85d073d..0000000000
--- a/package/network/services/hostapd/files/wpa_supplicant-full.config
+++ /dev/null
@@ -1,625 +0,0 @@
-# Example wpa_supplicant build time configuration
-#
-# This file lists the configuration options that are used when building the
-# wpa_supplicant binary. All lines starting with # are ignored. Configuration
-# option lines must be commented out complete, if they are not to be included,
-# i.e., just setting VARIABLE=n is not disabling that variable.
-#
-# This file is included in Makefile, so variables like CFLAGS and LIBS can also
-# be modified from here. In most cases, these lines should use += in order not
-# to override previous values of the variables.
-
-
-# Uncomment following two lines and fix the paths if you have installed OpenSSL
-# or GnuTLS in non-default location
-#CFLAGS += -I/usr/local/openssl/include
-#LIBS += -L/usr/local/openssl/lib
-
-# Some Red Hat versions seem to include kerberos header files from OpenSSL, but
-# the kerberos files are not in the default include path. Following line can be
-# used to fix build issues on such systems (krb5.h not found).
-#CFLAGS += -I/usr/include/kerberos
-
-# Driver interface for generic Linux wireless extensions
-# Note: WEXT is deprecated in the current Linux kernel version and no new
-# functionality is added to it. nl80211-based interface is the new
-# replacement for WEXT and its use allows wpa_supplicant to properly control
-# the driver to improve existing functionality like roaming and to support new
-# functionality.
-CONFIG_DRIVER_WEXT=y
-
-# Driver interface for Linux drivers using the nl80211 kernel interface
-CONFIG_DRIVER_NL80211=y
-
-# QCA vendor extensions to nl80211
-#CONFIG_DRIVER_NL80211_QCA=y
-
-# driver_nl80211.c requires libnl. If you are compiling it yourself
-# you may need to point hostapd to your version of libnl.
-#
-#CFLAGS += -I$<path to libnl include files>
-#LIBS += -L$<path to libnl library files>
-
-# Use libnl v2.0 (or 3.0) libraries.
-#CONFIG_LIBNL20=y
-
-# Use libnl 3.2 libraries (if this is selected, CONFIG_LIBNL20 is ignored)
-#CONFIG_LIBNL32=y
-
-
-# Driver interface for FreeBSD net80211 layer (e.g., Atheros driver)
-#CONFIG_DRIVER_BSD=y
-#CFLAGS += -I/usr/local/include
-#LIBS += -L/usr/local/lib
-#LIBS_p += -L/usr/local/lib
-#LIBS_c += -L/usr/local/lib
-
-# Driver interface for Windows NDIS
-#CONFIG_DRIVER_NDIS=y
-#CFLAGS += -I/usr/include/w32api/ddk
-#LIBS += -L/usr/local/lib
-# For native build using mingw
-#CONFIG_NATIVE_WINDOWS=y
-# Additional directories for cross-compilation on Linux host for mingw target
-#CFLAGS += -I/opt/mingw/mingw32/include/ddk
-#LIBS += -L/opt/mingw/mingw32/lib
-#CC=mingw32-gcc
-# By default, driver_ndis uses WinPcap for low-level operations. This can be
-# replaced with the following option which replaces WinPcap calls with NDISUIO.
-# However, this requires that WZC is disabled (net stop wzcsvc) before starting
-# wpa_supplicant.
-# CONFIG_USE_NDISUIO=y
-
-# Driver interface for wired Ethernet drivers
-CONFIG_DRIVER_WIRED=y
-
-# Driver interface for MACsec capable Qualcomm Atheros drivers
-#CONFIG_DRIVER_MACSEC_QCA=y
-
-# Driver interface for Linux MACsec drivers
-#CONFIG_DRIVER_MACSEC_LINUX=y
-
-# Driver interface for the Broadcom RoboSwitch family
-#CONFIG_DRIVER_ROBOSWITCH=y
-
-# Driver interface for no driver (e.g., WPS ER only)
-#CONFIG_DRIVER_NONE=y
-
-# Solaris libraries
-#LIBS += -lsocket -ldlpi -lnsl
-#LIBS_c += -lsocket
-
-# Enable IEEE 802.1X Supplicant (automatically included if any EAP method or
-# MACsec is included)
-CONFIG_IEEE8021X_EAPOL=y
-
-# EAP-MD5
-CONFIG_EAP_MD5=y
-
-# EAP-MSCHAPv2
-CONFIG_EAP_MSCHAPV2=y
-
-# EAP-TLS
-CONFIG_EAP_TLS=y
-
-# EAL-PEAP
-CONFIG_EAP_PEAP=y
-
-# EAP-TTLS
-CONFIG_EAP_TTLS=y
-
-# EAP-FAST
-CONFIG_EAP_FAST=y
-
-# EAP-TEAP
-# Note: The current EAP-TEAP implementation is experimental and should not be
-# enabled for production use. The IETF RFC 7170 that defines EAP-TEAP has number
-# of conflicting statements and missing details and the implementation has
-# vendor specific workarounds for those and as such, may not interoperate with
-# any other implementation. This should not be used for anything else than
-# experimentation and interoperability testing until those issues has been
-# resolved.
-#CONFIG_EAP_TEAP=y
-
-# EAP-GTC
-CONFIG_EAP_GTC=y
-
-# EAP-OTP
-CONFIG_EAP_OTP=y
-
-# EAP-SIM (enable CONFIG_PCSC, if EAP-SIM is used)
-#CONFIG_EAP_SIM=y
-
-# Enable SIM simulator (Milenage) for EAP-SIM
-#CONFIG_SIM_SIMULATOR=y
-
-# EAP-PSK (experimental; this is _not_ needed for WPA-PSK)
-#CONFIG_EAP_PSK=y
-
-# EAP-pwd (secure authentication using only a password)
-#CONFIG_EAP_PWD=y
-
-# EAP-PAX
-#CONFIG_EAP_PAX=y
-
-# LEAP
-CONFIG_EAP_LEAP=y
-
-# EAP-AKA (enable CONFIG_PCSC, if EAP-AKA is used)
-#CONFIG_EAP_AKA=y
-
-# EAP-AKA' (enable CONFIG_PCSC, if EAP-AKA' is used).
-# This requires CONFIG_EAP_AKA to be enabled, too.
-#CONFIG_EAP_AKA_PRIME=y
-
-# Enable USIM simulator (Milenage) for EAP-AKA
-#CONFIG_USIM_SIMULATOR=y
-
-# EAP-SAKE
-#CONFIG_EAP_SAKE=y
-
-# EAP-GPSK
-#CONFIG_EAP_GPSK=y
-# Include support for optional SHA256 cipher suite in EAP-GPSK
-#CONFIG_EAP_GPSK_SHA256=y
-
-# EAP-TNC and related Trusted Network Connect support (experimental)
-#CONFIG_EAP_TNC=y
-
-# Wi-Fi Protected Setup (WPS)
-CONFIG_WPS=y
-# Enable WPS external registrar functionality
-#CONFIG_WPS_ER=y
-# Disable credentials for an open network by default when acting as a WPS
-# registrar.
-#CONFIG_WPS_REG_DISABLE_OPEN=y
-# Enable WPS support with NFC config method
-#CONFIG_WPS_NFC=y
-
-# EAP-IKEv2
-#CONFIG_EAP_IKEV2=y
-
-# EAP-EKE
-#CONFIG_EAP_EKE=y
-
-# MACsec
-#CONFIG_MACSEC=y
-
-# PKCS#12 (PFX) support (used to read private key and certificate file from
-# a file that usually has extension .p12 or .pfx)
-CONFIG_PKCS12=y
-
-# Smartcard support (i.e., private key on a smartcard), e.g., with openssl
-# engine.
-CONFIG_SMARTCARD=y
-
-# PC/SC interface for smartcards (USIM, GSM SIM)
-# Enable this if EAP-SIM or EAP-AKA is included
-#CONFIG_PCSC=y
-
-# Support HT overrides (disable HT/HT40, mask MCS rates, etc.)
-CONFIG_HT_OVERRIDES=y
-
-# Support VHT overrides (disable VHT, mask MCS rates, etc.)
-CONFIG_VHT_OVERRIDES=y
-
-# Development testing
-#CONFIG_EAPOL_TEST=y
-
-# Select control interface backend for external programs, e.g, wpa_cli:
-# unix = UNIX domain sockets (default for Linux/*BSD)
-# udp = UDP sockets using localhost (127.0.0.1)
-# udp6 = UDP IPv6 sockets using localhost (::1)
-# named_pipe = Windows Named Pipe (default for Windows)
-# udp-remote = UDP sockets with remote access (only for tests systems/purpose)
-# udp6-remote = UDP IPv6 sockets with remote access (only for tests purpose)
-# y = use default (backwards compatibility)
-# If this option is commented out, control interface is not included in the
-# build.
-CONFIG_CTRL_IFACE=y
-
-# Include support for GNU Readline and History Libraries in wpa_cli.
-# When building a wpa_cli binary for distribution, please note that these
-# libraries are licensed under GPL and as such, BSD license may not apply for
-# the resulting binary.
-#CONFIG_READLINE=y
-
-# Include internal line edit mode in wpa_cli. This can be used as a replacement
-# for GNU Readline to provide limited command line editing and history support.
-#CONFIG_WPA_CLI_EDIT=y
-
-# Remove debugging code that is printing out debug message to stdout.
-# This can be used to reduce the size of the wpa_supplicant considerably
-# if debugging code is not needed. The size reduction can be around 35%
-# (e.g., 90 kB).
-#CONFIG_NO_STDOUT_DEBUG=y
-
-# Remove WPA support, e.g., for wired-only IEEE 802.1X supplicant, to save
-# 35-50 kB in code size.
-#CONFIG_NO_WPA=y
-
-# Remove IEEE 802.11i/WPA-Personal ASCII passphrase support
-# This option can be used to reduce code size by removing support for
-# converting ASCII passphrases into PSK. If this functionality is removed, the
-# PSK can only be configured as the 64-octet hexstring (e.g., from
-# wpa_passphrase). This saves about 0.5 kB in code size.
-#CONFIG_NO_WPA_PASSPHRASE=y
-
-# Simultaneous Authentication of Equals (SAE), WPA3-Personal
-#CONFIG_SAE=y
-
-# Disable scan result processing (ap_mode=1) to save code size by about 1 kB.
-# This can be used if ap_scan=1 mode is never enabled.
-#CONFIG_NO_SCAN_PROCESSING=y
-
-# Select configuration backend:
-# file = text file (e.g., wpa_supplicant.conf; note: the configuration file
-#	path is given on command line, not here; this option is just used to
-#	select the backend that allows configuration files to be used)
-# winreg = Windows registry (see win_example.reg for an example)
-CONFIG_BACKEND=file
-
-# Remove configuration write functionality (i.e., to allow the configuration
-# file to be updated based on runtime configuration changes). The runtime
-# configuration can still be changed, the changes are just not going to be
-# persistent over restarts. This option can be used to reduce code size by
-# about 3.5 kB.
-#CONFIG_NO_CONFIG_WRITE=y
-
-# Remove support for configuration blobs to reduce code size by about 1.5 kB.
-#CONFIG_NO_CONFIG_BLOBS=y
-
-# Select program entry point implementation:
-# main = UNIX/POSIX like main() function (default)
-# main_winsvc = Windows service (read parameters from registry)
-# main_none = Very basic example (development use only)
-#CONFIG_MAIN=main
-
-# Select wrapper for operating system and C library specific functions
-# unix = UNIX/POSIX like systems (default)
-# win32 = Windows systems
-# none = Empty template
-#CONFIG_OS=unix
-
-# Select event loop implementation
-# eloop = select() loop (default)
-# eloop_win = Windows events and WaitForMultipleObject() loop
-#CONFIG_ELOOP=eloop
-
-# Should we use poll instead of select? Select is used by default.
-#CONFIG_ELOOP_POLL=y
-
-# Should we use epoll instead of select? Select is used by default.
-CONFIG_ELOOP_EPOLL=y
-
-# Should we use kqueue instead of select? Select is used by default.
-#CONFIG_ELOOP_KQUEUE=y
-
-# Select layer 2 packet implementation
-# linux = Linux packet socket (default)
-# pcap = libpcap/libdnet/WinPcap
-# freebsd = FreeBSD libpcap
-# winpcap = WinPcap with receive thread
-# ndis = Windows NDISUIO (note: requires CONFIG_USE_NDISUIO=y)
-# none = Empty template
-#CONFIG_L2_PACKET=linux
-
-# Disable Linux packet socket workaround applicable for station interface
-# in a bridge for EAPOL frames. This should be uncommented only if the kernel
-# is known to not have the regression issue in packet socket behavior with
-# bridge interfaces (commit 'bridge: respect RFC2863 operational state')').
-CONFIG_NO_LINUX_PACKET_SOCKET_WAR=y
-
-# IEEE 802.11w (management frame protection), also known as PMF
-# Driver support is also needed for IEEE 802.11w.
-#CONFIG_IEEE80211W=y
-
-# Support Operating Channel Validation
-#CONFIG_OCV=y
-
-# Select TLS implementation
-# openssl = OpenSSL (default)
-# gnutls = GnuTLS
-# internal = Internal TLSv1 implementation (experimental)
-# linux = Linux kernel AF_ALG and internal TLSv1 implementation (experimental)
-# none = Empty template
-CONFIG_TLS=internal
-
-# TLS-based EAP methods require at least TLS v1.0. Newer version of TLS (v1.1)
-# can be enabled to get a stronger construction of messages when block ciphers
-# are used. It should be noted that some existing TLS v1.0 -based
-# implementation may not be compatible with TLS v1.1 message (ClientHello is
-# sent prior to negotiating which version will be used)
-#CONFIG_TLSV11=y
-
-# TLS-based EAP methods require at least TLS v1.0. Newer version of TLS (v1.2)
-# can be enabled to enable use of stronger crypto algorithms. It should be
-# noted that some existing TLS v1.0 -based implementation may not be compatible
-# with TLS v1.2 message (ClientHello is sent prior to negotiating which version
-# will be used)
-#CONFIG_TLSV12=y
-
-# Select which ciphers to use by default with OpenSSL if the user does not
-# specify them.
-#CONFIG_TLS_DEFAULT_CIPHERS="DEFAULT:!EXP:!LOW"
-
-# If CONFIG_TLS=internal is used, additional library and include paths are
-# needed for LibTomMath. Alternatively, an integrated, minimal version of
-# LibTomMath can be used. See beginning of libtommath.c for details on benefits
-# and drawbacks of this option.
-CONFIG_INTERNAL_LIBTOMMATH=y
-#ifndef CONFIG_INTERNAL_LIBTOMMATH
-#LTM_PATH=/usr/src/libtommath-0.39
-#CFLAGS += -I$(LTM_PATH)
-#LIBS += -L$(LTM_PATH)
-#LIBS_p += -L$(LTM_PATH)
-#endif
-# At the cost of about 4 kB of additional binary size, the internal LibTomMath
-# can be configured to include faster routines for exptmod, sqr, and div to
-# speed up DH and RSA calculation considerably
-CONFIG_INTERNAL_LIBTOMMATH_FAST=y
-
-# Include NDIS event processing through WMI into wpa_supplicant/wpasvc.
-# This is only for Windows builds and requires WMI-related header files and
-# WbemUuid.Lib from Platform SDK even when building with MinGW.
-#CONFIG_NDIS_EVENTS_INTEGRATED=y
-#PLATFORMSDKLIB="/opt/Program Files/Microsoft Platform SDK/Lib"
-
-# Add support for new DBus control interface
-# (fi.w1.hostap.wpa_supplicant1)
-#CONFIG_CTRL_IFACE_DBUS_NEW=y
-
-# Add introspection support for new DBus control interface
-#CONFIG_CTRL_IFACE_DBUS_INTRO=y
-
-# Add support for loading EAP methods dynamically as shared libraries.
-# When this option is enabled, each EAP method can be either included
-# statically (CONFIG_EAP_<method>=y) or dynamically (CONFIG_EAP_<method>=dyn).
-# Dynamic EAP methods are build as shared objects (eap_*.so) and they need to
-# be loaded in the beginning of the wpa_supplicant configuration file
-# (see load_dynamic_eap parameter in the example file) before being used in
-# the network blocks.
-#
-# Note that some shared parts of EAP methods are included in the main program
-# and in order to be able to use dynamic EAP methods using these parts, the
-# main program must have been build with the EAP method enabled (=y or =dyn).
-# This means that EAP-TLS/PEAP/TTLS/FAST cannot be added as dynamic libraries
-# unless at least one of them was included in the main build to force inclusion
-# of the shared code. Similarly, at least one of EAP-SIM/AKA must be included
-# in the main build to be able to load these methods dynamically.
-#
-# Please also note that using dynamic libraries will increase the total binary
-# size. Thus, it may not be the best option for targets that have limited
-# amount of memory/flash.
-#CONFIG_DYNAMIC_EAP_METHODS=y
-
-# IEEE Std 802.11r-2008 (Fast BSS Transition) for station mode
-CONFIG_IEEE80211R=y
-
-# Add support for writing debug log to a file (/tmp/wpa_supplicant-log-#.txt)
-#CONFIG_DEBUG_FILE=y
-
-# Send debug messages to syslog instead of stdout
-CONFIG_DEBUG_SYSLOG=y
-# Set syslog facility for debug messages
-CONFIG_DEBUG_SYSLOG_FACILITY=LOG_DAEMON
-
-# Add support for sending all debug messages (regardless of debug verbosity)
-# to the Linux kernel tracing facility. This helps debug the entire stack by
-# making it easy to record everything happening from the driver up into the
-# same file, e.g., using trace-cmd.
-#CONFIG_DEBUG_LINUX_TRACING=y
-
-# Add support for writing debug log to Android logcat instead of standard
-# output
-#CONFIG_ANDROID_LOG=y
-
-# Enable privilege separation (see README 'Privilege separation' for details)
-#CONFIG_PRIVSEP=y
-
-# Enable mitigation against certain attacks against TKIP by delaying Michael
-# MIC error reports by a random amount of time between 0 and 60 seconds
-#CONFIG_DELAYED_MIC_ERROR_REPORT=y
-
-# Enable tracing code for developer debugging
-# This tracks use of memory allocations and other registrations and reports
-# incorrect use with a backtrace of call (or allocation) location.
-#CONFIG_WPA_TRACE=y
-# For BSD, uncomment these.
-#LIBS += -lexecinfo
-#LIBS_p += -lexecinfo
-#LIBS_c += -lexecinfo
-
-# Use libbfd to get more details for developer debugging
-# This enables use of libbfd to get more detailed symbols for the backtraces
-# generated by CONFIG_WPA_TRACE=y.
-#CONFIG_WPA_TRACE_BFD=y
-# For BSD, uncomment these.
-#LIBS += -lbfd -liberty -lz
-#LIBS_p += -lbfd -liberty -lz
-#LIBS_c += -lbfd -liberty -lz
-
-# wpa_supplicant depends on strong random number generation being available
-# from the operating system. os_get_random() function is used to fetch random
-# data when needed, e.g., for key generation. On Linux and BSD systems, this
-# works by reading /dev/urandom. It should be noted that the OS entropy pool
-# needs to be properly initialized before wpa_supplicant is started. This is
-# important especially on embedded devices that do not have a hardware random
-# number generator and may by default start up with minimal entropy available
-# for random number generation.
-#
-# As a safety net, wpa_supplicant is by default trying to internally collect
-# additional entropy for generating random data to mix in with the data fetched
-# from the OS. This by itself is not considered to be very strong, but it may
-# help in cases where the system pool is not initialized properly. However, it
-# is very strongly recommended that the system pool is initialized with enough
-# entropy either by using hardware assisted random number generator or by
-# storing state over device reboots.
-#
-# wpa_supplicant can be configured to maintain its own entropy store over
-# restarts to enhance random number generation. This is not perfect, but it is
-# much more secure than using the same sequence of random numbers after every
-# reboot. This can be enabled with -e<entropy file> command line option. The
-# specified file needs to be readable and writable by wpa_supplicant.
-#
-# If the os_get_random() is known to provide strong random data (e.g., on
-# Linux/BSD, the board in question is known to have reliable source of random
-# data from /dev/urandom), the internal wpa_supplicant random pool can be
-# disabled. This will save some in binary size and CPU use. However, this
-# should only be considered for builds that are known to be used on devices
-# that meet the requirements described above.
-CONFIG_NO_RANDOM_POOL=y
-
-# Should we attempt to use the getrandom(2) call that provides more reliable
-# yet secure randomness source than /dev/random on Linux 3.17 and newer.
-# Requires glibc 2.25 to build, falls back to /dev/random if unavailable.
-CONFIG_GETRANDOM=y
-
-# IEEE 802.11n (High Throughput) support (mainly for AP mode)
-#CONFIG_IEEE80211N=y
-
-# IEEE 802.11ac (Very High Throughput) support (mainly for AP mode)
-# (depends on CONFIG_IEEE80211N)
-#CONFIG_IEEE80211AC=y
-
-# Wireless Network Management (IEEE Std 802.11v-2011)
-# Note: This is experimental and not complete implementation.
-CONFIG_WNM=y
-
-# Interworking (IEEE 802.11u)
-# This can be used to enable functionality to improve interworking with
-# external networks (GAS/ANQP to learn more about the networks and network
-# selection based on available credentials).
-CONFIG_INTERWORKING=y
-
-# Hotspot 2.0
-CONFIG_HS20=y
-
-# Enable interface matching in wpa_supplicant
-#CONFIG_MATCH_IFACE=y
-
-# Disable roaming in wpa_supplicant
-#CONFIG_NO_ROAMING=y
-
-# AP mode operations with wpa_supplicant
-# This can be used for controlling AP mode operations with wpa_supplicant. It
-# should be noted that this is mainly aimed at simple cases like
-# WPA2-Personal while more complex configurations like WPA2-Enterprise with an
-# external RADIUS server can be supported with hostapd.
-#CONFIG_AP=y
-
-# P2P (Wi-Fi Direct)
-# This can be used to enable P2P support in wpa_supplicant. See README-P2P for
-# more information on P2P operations.
-#CONFIG_P2P=y
-
-# Enable TDLS support
-#CONFIG_TDLS=y
-
-# Wi-Fi Display
-# This can be used to enable Wi-Fi Display extensions for P2P using an external
-# program to control the additional information exchanges in the messages.
-#CONFIG_WIFI_DISPLAY=y
-
-# Autoscan
-# This can be used to enable automatic scan support in wpa_supplicant.
-# See wpa_supplicant.conf for more information on autoscan usage.
-#
-# Enabling directly a module will enable autoscan support.
-# For exponential module:
-#CONFIG_AUTOSCAN_EXPONENTIAL=y
-# For periodic module:
-#CONFIG_AUTOSCAN_PERIODIC=y
-
-# Password (and passphrase, etc.) backend for external storage
-# These optional mechanisms can be used to add support for storing passwords
-# and other secrets in external (to wpa_supplicant) location. This allows, for
-# example, operating system specific key storage to be used
-#
-# External password backend for testing purposes (developer use)
-#CONFIG_EXT_PASSWORD_TEST=y
-
-# Enable Fast Session Transfer (FST)
-#CONFIG_FST=y
-
-# Enable CLI commands for FST testing
-#CONFIG_FST_TEST=y
-
-# OS X builds. This is only for building eapol_test.
-#CONFIG_OSX=y
-
-# Automatic Channel Selection
-# This will allow wpa_supplicant to pick the channel automatically when channel
-# is set to "0".
-#
-# TODO: Extend parser to be able to parse "channel=acs_survey" as an alternative
-# to "channel=0". This would enable us to eventually add other ACS algorithms in
-# similar way.
-#
-# Automatic selection is currently only done through initialization, later on
-# we hope to do background checks to keep us moving to more ideal channels as
-# time goes by. ACS is currently only supported through the nl80211 driver and
-# your driver must have survey dump capability that is filled by the driver
-# during scanning.
-#
-# TODO: In analogy to hostapd be able to customize the ACS survey algorithm with
-# a newly to create wpa_supplicant.conf variable acs_num_scans.
-#
-# Supported ACS drivers:
-# * ath9k
-# * ath5k
-# * ath10k
-#
-# For more details refer to:
-# http://wireless.kernel.org/en/users/Documentation/acs
-#CONFIG_ACS=y
-
-# Support Multi Band Operation
-#CONFIG_MBO=y
-
-# Fast Initial Link Setup (FILS) (IEEE 802.11ai)
-#CONFIG_FILS=y
-# FILS shared key authentication with PFS
-#CONFIG_FILS_SK_PFS=y
-
-# Support RSN on IBSS networks
-# This is needed to be able to use mode=1 network profile with proto=RSN and
-# key_mgmt=WPA-PSK (i.e., full key management instead of WPA-None).
-CONFIG_IBSS_RSN=y
-
-# External PMKSA cache control
-# This can be used to enable control interface commands that allow the current
-# PMKSA cache entries to be fetched and new entries to be added.
-#CONFIG_PMKSA_CACHE_EXTERNAL=y
-
-# Mesh Networking (IEEE 802.11s)
-#CONFIG_MESH=y
-
-# Background scanning modules
-# These can be used to request wpa_supplicant to perform background scanning
-# operations for roaming within an ESS (same SSID). See the bgscan parameter in
-# the wpa_supplicant.conf file for more details.
-# Periodic background scans based on signal strength
-#CONFIG_BGSCAN_SIMPLE=y
-# Learn channels used by the network and try to avoid bgscans on other
-# channels (experimental)
-#CONFIG_BGSCAN_LEARN=y
-
-# Opportunistic Wireless Encryption (OWE)
-# Experimental implementation of draft-harkins-owe-07.txt
-#CONFIG_OWE=y
-
-# Device Provisioning Protocol (DPP)
-# This requires CONFIG_IEEE80211W=y to be enabled, too. (see
-# wpa_supplicant/README-DPP for details)
-#CONFIG_DPP=y
-
-# uBus IPC/RPC System
-# Services can connect to the bus and provide methods
-# that can be called by other services or clients.
-CONFIG_UBUS=y
-
-# OpenWrt patch 380-disable-ctrl-iface-mib.patch
-# leads to the MIB only being compiled in if
-# CONFIG_CTRL_IFACE_MIB is enabled.
-CONFIG_CTRL_IFACE_MIB=y
diff --git a/package/network/services/hostapd/files/wpa_supplicant-mini.config b/package/network/services/hostapd/files/wpa_supplicant-mini.config
deleted file mode 100644
index 9eb1111e52..0000000000
--- a/package/network/services/hostapd/files/wpa_supplicant-mini.config
+++ /dev/null
@@ -1,625 +0,0 @@
-# Example wpa_supplicant build time configuration
-#
-# This file lists the configuration options that are used when building the
-# wpa_supplicant binary. All lines starting with # are ignored. Configuration
-# option lines must be commented out complete, if they are not to be included,
-# i.e., just setting VARIABLE=n is not disabling that variable.
-#
-# This file is included in Makefile, so variables like CFLAGS and LIBS can also
-# be modified from here. In most cases, these lines should use += in order not
-# to override previous values of the variables.
-
-
-# Uncomment following two lines and fix the paths if you have installed OpenSSL
-# or GnuTLS in non-default location
-#CFLAGS += -I/usr/local/openssl/include
-#LIBS += -L/usr/local/openssl/lib
-
-# Some Red Hat versions seem to include kerberos header files from OpenSSL, but
-# the kerberos files are not in the default include path. Following line can be
-# used to fix build issues on such systems (krb5.h not found).
-#CFLAGS += -I/usr/include/kerberos
-
-# Driver interface for generic Linux wireless extensions
-# Note: WEXT is deprecated in the current Linux kernel version and no new
-# functionality is added to it. nl80211-based interface is the new
-# replacement for WEXT and its use allows wpa_supplicant to properly control
-# the driver to improve existing functionality like roaming and to support new
-# functionality.
-CONFIG_DRIVER_WEXT=y
-
-# Driver interface for Linux drivers using the nl80211 kernel interface
-CONFIG_DRIVER_NL80211=y
-
-# QCA vendor extensions to nl80211
-#CONFIG_DRIVER_NL80211_QCA=y
-
-# driver_nl80211.c requires libnl. If you are compiling it yourself
-# you may need to point hostapd to your version of libnl.
-#
-#CFLAGS += -I$<path to libnl include files>
-#LIBS += -L$<path to libnl library files>
-
-# Use libnl v2.0 (or 3.0) libraries.
-#CONFIG_LIBNL20=y
-
-# Use libnl 3.2 libraries (if this is selected, CONFIG_LIBNL20 is ignored)
-#CONFIG_LIBNL32=y
-
-
-# Driver interface for FreeBSD net80211 layer (e.g., Atheros driver)
-#CONFIG_DRIVER_BSD=y
-#CFLAGS += -I/usr/local/include
-#LIBS += -L/usr/local/lib
-#LIBS_p += -L/usr/local/lib
-#LIBS_c += -L/usr/local/lib
-
-# Driver interface for Windows NDIS
-#CONFIG_DRIVER_NDIS=y
-#CFLAGS += -I/usr/include/w32api/ddk
-#LIBS += -L/usr/local/lib
-# For native build using mingw
-#CONFIG_NATIVE_WINDOWS=y
-# Additional directories for cross-compilation on Linux host for mingw target
-#CFLAGS += -I/opt/mingw/mingw32/include/ddk
-#LIBS += -L/opt/mingw/mingw32/lib
-#CC=mingw32-gcc
-# By default, driver_ndis uses WinPcap for low-level operations. This can be
-# replaced with the following option which replaces WinPcap calls with NDISUIO.
-# However, this requires that WZC is disabled (net stop wzcsvc) before starting
-# wpa_supplicant.
-# CONFIG_USE_NDISUIO=y
-
-# Driver interface for wired Ethernet drivers
-CONFIG_DRIVER_WIRED=y
-
-# Driver interface for MACsec capable Qualcomm Atheros drivers
-#CONFIG_DRIVER_MACSEC_QCA=y
-
-# Driver interface for Linux MACsec drivers
-#CONFIG_DRIVER_MACSEC_LINUX=y
-
-# Driver interface for the Broadcom RoboSwitch family
-#CONFIG_DRIVER_ROBOSWITCH=y
-
-# Driver interface for no driver (e.g., WPS ER only)
-#CONFIG_DRIVER_NONE=y
-
-# Solaris libraries
-#LIBS += -lsocket -ldlpi -lnsl
-#LIBS_c += -lsocket
-
-# Enable IEEE 802.1X Supplicant (automatically included if any EAP method or
-# MACsec is included)
-#CONFIG_IEEE8021X_EAPOL=y
-
-# EAP-MD5
-#CONFIG_EAP_MD5=y
-
-# EAP-MSCHAPv2
-#CONFIG_EAP_MSCHAPV2=y
-
-# EAP-TLS
-#CONFIG_EAP_TLS=y
-
-# EAL-PEAP
-#CONFIG_EAP_PEAP=y
-
-# EAP-TTLS
-#CONFIG_EAP_TTLS=y
-
-# EAP-FAST
-#CONFIG_EAP_FAST=y
-
-# EAP-TEAP
-# Note: The current EAP-TEAP implementation is experimental and should not be
-# enabled for production use. The IETF RFC 7170 that defines EAP-TEAP has number
-# of conflicting statements and missing details and the implementation has
-# vendor specific workarounds for those and as such, may not interoperate with
-# any other implementation. This should not be used for anything else than
-# experimentation and interoperability testing until those issues has been
-# resolved.
-#CONFIG_EAP_TEAP=y
-
-# EAP-GTC
-#CONFIG_EAP_GTC=y
-
-# EAP-OTP
-#CONFIG_EAP_OTP=y
-
-# EAP-SIM (enable CONFIG_PCSC, if EAP-SIM is used)
-#CONFIG_EAP_SIM=y
-
-# Enable SIM simulator (Milenage) for EAP-SIM
-#CONFIG_SIM_SIMULATOR=y
-
-# EAP-PSK (experimental; this is _not_ needed for WPA-PSK)
-#CONFIG_EAP_PSK=y
-
-# EAP-pwd (secure authentication using only a password)
-#CONFIG_EAP_PWD=y
-
-# EAP-PAX
-#CONFIG_EAP_PAX=y
-
-# LEAP
-#CONFIG_EAP_LEAP=y
-
-# EAP-AKA (enable CONFIG_PCSC, if EAP-AKA is used)
-#CONFIG_EAP_AKA=y
-
-# EAP-AKA' (enable CONFIG_PCSC, if EAP-AKA' is used).
-# This requires CONFIG_EAP_AKA to be enabled, too.
-#CONFIG_EAP_AKA_PRIME=y
-
-# Enable USIM simulator (Milenage) for EAP-AKA
-#CONFIG_USIM_SIMULATOR=y
-
-# EAP-SAKE
-#CONFIG_EAP_SAKE=y
-
-# EAP-GPSK
-#CONFIG_EAP_GPSK=y
-# Include support for optional SHA256 cipher suite in EAP-GPSK
-#CONFIG_EAP_GPSK_SHA256=y
-
-# EAP-TNC and related Trusted Network Connect support (experimental)
-#CONFIG_EAP_TNC=y
-
-# Wi-Fi Protected Setup (WPS)
-#CONFIG_WPS=y
-# Enable WPS external registrar functionality
-#CONFIG_WPS_ER=y
-# Disable credentials for an open network by default when acting as a WPS
-# registrar.
-#CONFIG_WPS_REG_DISABLE_OPEN=y
-# Enable WPS support with NFC config method
-#CONFIG_WPS_NFC=y
-
-# EAP-IKEv2
-#CONFIG_EAP_IKEV2=y
-
-# EAP-EKE
-#CONFIG_EAP_EKE=y
-
-# MACsec
-#CONFIG_MACSEC=y
-
-# PKCS#12 (PFX) support (used to read private key and certificate file from
-# a file that usually has extension .p12 or .pfx)
-#CONFIG_PKCS12=y
-
-# Smartcard support (i.e., private key on a smartcard), e.g., with openssl
-# engine.
-#CONFIG_SMARTCARD=y
-
-# PC/SC interface for smartcards (USIM, GSM SIM)
-# Enable this if EAP-SIM or EAP-AKA is included
-#CONFIG_PCSC=y
-
-# Support HT overrides (disable HT/HT40, mask MCS rates, etc.)
-CONFIG_HT_OVERRIDES=y
-
-# Support VHT overrides (disable VHT, mask MCS rates, etc.)
-CONFIG_VHT_OVERRIDES=y
-
-# Development testing
-#CONFIG_EAPOL_TEST=y
-
-# Select control interface backend for external programs, e.g, wpa_cli:
-# unix = UNIX domain sockets (default for Linux/*BSD)
-# udp = UDP sockets using localhost (127.0.0.1)
-# udp6 = UDP IPv6 sockets using localhost (::1)
-# named_pipe = Windows Named Pipe (default for Windows)
-# udp-remote = UDP sockets with remote access (only for tests systems/purpose)
-# udp6-remote = UDP IPv6 sockets with remote access (only for tests purpose)
-# y = use default (backwards compatibility)
-# If this option is commented out, control interface is not included in the
-# build.
-CONFIG_CTRL_IFACE=y
-
-# Include support for GNU Readline and History Libraries in wpa_cli.
-# When building a wpa_cli binary for distribution, please note that these
-# libraries are licensed under GPL and as such, BSD license may not apply for
-# the resulting binary.
-#CONFIG_READLINE=y
-
-# Include internal line edit mode in wpa_cli. This can be used as a replacement
-# for GNU Readline to provide limited command line editing and history support.
-#CONFIG_WPA_CLI_EDIT=y
-
-# Remove debugging code that is printing out debug message to stdout.
-# This can be used to reduce the size of the wpa_supplicant considerably
-# if debugging code is not needed. The size reduction can be around 35%
-# (e.g., 90 kB).
-#CONFIG_NO_STDOUT_DEBUG=y
-
-# Remove WPA support, e.g., for wired-only IEEE 802.1X supplicant, to save
-# 35-50 kB in code size.
-#CONFIG_NO_WPA=y
-
-# Remove IEEE 802.11i/WPA-Personal ASCII passphrase support
-# This option can be used to reduce code size by removing support for
-# converting ASCII passphrases into PSK. If this functionality is removed, the
-# PSK can only be configured as the 64-octet hexstring (e.g., from
-# wpa_passphrase). This saves about 0.5 kB in code size.
-#CONFIG_NO_WPA_PASSPHRASE=y
-
-# Simultaneous Authentication of Equals (SAE), WPA3-Personal
-#CONFIG_SAE=y
-
-# Disable scan result processing (ap_mode=1) to save code size by about 1 kB.
-# This can be used if ap_scan=1 mode is never enabled.
-#CONFIG_NO_SCAN_PROCESSING=y
-
-# Select configuration backend:
-# file = text file (e.g., wpa_supplicant.conf; note: the configuration file
-#	path is given on command line, not here; this option is just used to
-#	select the backend that allows configuration files to be used)
-# winreg = Windows registry (see win_example.reg for an example)
-CONFIG_BACKEND=file
-
-# Remove configuration write functionality (i.e., to allow the configuration
-# file to be updated based on runtime configuration changes). The runtime
-# configuration can still be changed, the changes are just not going to be
-# persistent over restarts. This option can be used to reduce code size by
-# about 3.5 kB.
-CONFIG_NO_CONFIG_WRITE=y
-
-# Remove support for configuration blobs to reduce code size by about 1.5 kB.
-#CONFIG_NO_CONFIG_BLOBS=y
-
-# Select program entry point implementation:
-# main = UNIX/POSIX like main() function (default)
-# main_winsvc = Windows service (read parameters from registry)
-# main_none = Very basic example (development use only)
-#CONFIG_MAIN=main
-
-# Select wrapper for operating system and C library specific functions
-# unix = UNIX/POSIX like systems (default)
-# win32 = Windows systems
-# none = Empty template
-#CONFIG_OS=unix
-
-# Select event loop implementation
-# eloop = select() loop (default)
-# eloop_win = Windows events and WaitForMultipleObject() loop
-#CONFIG_ELOOP=eloop
-
-# Should we use poll instead of select? Select is used by default.
-#CONFIG_ELOOP_POLL=y
-
-# Should we use epoll instead of select? Select is used by default.
-CONFIG_ELOOP_EPOLL=y
-
-# Should we use kqueue instead of select? Select is used by default.
-#CONFIG_ELOOP_KQUEUE=y
-
-# Select layer 2 packet implementation
-# linux = Linux packet socket (default)
-# pcap = libpcap/libdnet/WinPcap
-# freebsd = FreeBSD libpcap
-# winpcap = WinPcap with receive thread
-# ndis = Windows NDISUIO (note: requires CONFIG_USE_NDISUIO=y)
-# none = Empty template
-#CONFIG_L2_PACKET=linux
-
-# Disable Linux packet socket workaround applicable for station interface
-# in a bridge for EAPOL frames. This should be uncommented only if the kernel
-# is known to not have the regression issue in packet socket behavior with
-# bridge interfaces (commit 'bridge: respect RFC2863 operational state')').
-CONFIG_NO_LINUX_PACKET_SOCKET_WAR=y
-
-# IEEE 802.11w (management frame protection), also known as PMF
-# Driver support is also needed for IEEE 802.11w.
-#CONFIG_IEEE80211W=y
-
-# Support Operating Channel Validation
-#CONFIG_OCV=y
-
-# Select TLS implementation
-# openssl = OpenSSL (default)
-# gnutls = GnuTLS
-# internal = Internal TLSv1 implementation (experimental)
-# linux = Linux kernel AF_ALG and internal TLSv1 implementation (experimental)
-# none = Empty template
-CONFIG_TLS=internal
-
-# TLS-based EAP methods require at least TLS v1.0. Newer version of TLS (v1.1)
-# can be enabled to get a stronger construction of messages when block ciphers
-# are used. It should be noted that some existing TLS v1.0 -based
-# implementation may not be compatible with TLS v1.1 message (ClientHello is
-# sent prior to negotiating which version will be used)
-#CONFIG_TLSV11=y
-
-# TLS-based EAP methods require at least TLS v1.0. Newer version of TLS (v1.2)
-# can be enabled to enable use of stronger crypto algorithms. It should be
-# noted that some existing TLS v1.0 -based implementation may not be compatible
-# with TLS v1.2 message (ClientHello is sent prior to negotiating which version
-# will be used)
-#CONFIG_TLSV12=y
-
-# Select which ciphers to use by default with OpenSSL if the user does not
-# specify them.
-#CONFIG_TLS_DEFAULT_CIPHERS="DEFAULT:!EXP:!LOW"
-
-# If CONFIG_TLS=internal is used, additional library and include paths are
-# needed for LibTomMath. Alternatively, an integrated, minimal version of
-# LibTomMath can be used. See beginning of libtommath.c for details on benefits
-# and drawbacks of this option.
-#CONFIG_INTERNAL_LIBTOMMATH=y
-#ifndef CONFIG_INTERNAL_LIBTOMMATH
-#LTM_PATH=/usr/src/libtommath-0.39
-#CFLAGS += -I$(LTM_PATH)
-#LIBS += -L$(LTM_PATH)
-#LIBS_p += -L$(LTM_PATH)
-#endif
-# At the cost of about 4 kB of additional binary size, the internal LibTomMath
-# can be configured to include faster routines for exptmod, sqr, and div to
-# speed up DH and RSA calculation considerably
-#CONFIG_INTERNAL_LIBTOMMATH_FAST=y
-
-# Include NDIS event processing through WMI into wpa_supplicant/wpasvc.
-# This is only for Windows builds and requires WMI-related header files and
-# WbemUuid.Lib from Platform SDK even when building with MinGW.
-#CONFIG_NDIS_EVENTS_INTEGRATED=y
-#PLATFORMSDKLIB="/opt/Program Files/Microsoft Platform SDK/Lib"
-
-# Add support for new DBus control interface
-# (fi.w1.hostap.wpa_supplicant1)
-#CONFIG_CTRL_IFACE_DBUS_NEW=y
-
-# Add introspection support for new DBus control interface
-#CONFIG_CTRL_IFACE_DBUS_INTRO=y
-
-# Add support for loading EAP methods dynamically as shared libraries.
-# When this option is enabled, each EAP method can be either included
-# statically (CONFIG_EAP_<method>=y) or dynamically (CONFIG_EAP_<method>=dyn).
-# Dynamic EAP methods are build as shared objects (eap_*.so) and they need to
-# be loaded in the beginning of the wpa_supplicant configuration file
-# (see load_dynamic_eap parameter in the example file) before being used in
-# the network blocks.
-#
-# Note that some shared parts of EAP methods are included in the main program
-# and in order to be able to use dynamic EAP methods using these parts, the
-# main program must have been build with the EAP method enabled (=y or =dyn).
-# This means that EAP-TLS/PEAP/TTLS/FAST cannot be added as dynamic libraries
-# unless at least one of them was included in the main build to force inclusion
-# of the shared code. Similarly, at least one of EAP-SIM/AKA must be included
-# in the main build to be able to load these methods dynamically.
-#
-# Please also note that using dynamic libraries will increase the total binary
-# size. Thus, it may not be the best option for targets that have limited
-# amount of memory/flash.
-#CONFIG_DYNAMIC_EAP_METHODS=y
-
-# IEEE Std 802.11r-2008 (Fast BSS Transition) for station mode
-#CONFIG_IEEE80211R=y
-
-# Add support for writing debug log to a file (/tmp/wpa_supplicant-log-#.txt)
-#CONFIG_DEBUG_FILE=y
-
-# Send debug messages to syslog instead of stdout
-CONFIG_DEBUG_SYSLOG=y
-# Set syslog facility for debug messages
-CONFIG_DEBUG_SYSLOG_FACILITY=LOG_DAEMON
-
-# Add support for sending all debug messages (regardless of debug verbosity)
-# to the Linux kernel tracing facility. This helps debug the entire stack by
-# making it easy to record everything happening from the driver up into the
-# same file, e.g., using trace-cmd.
-#CONFIG_DEBUG_LINUX_TRACING=y
-
-# Add support for writing debug log to Android logcat instead of standard
-# output
-#CONFIG_ANDROID_LOG=y
-
-# Enable privilege separation (see README 'Privilege separation' for details)
-#CONFIG_PRIVSEP=y
-
-# Enable mitigation against certain attacks against TKIP by delaying Michael
-# MIC error reports by a random amount of time between 0 and 60 seconds
-#CONFIG_DELAYED_MIC_ERROR_REPORT=y
-
-# Enable tracing code for developer debugging
-# This tracks use of memory allocations and other registrations and reports
-# incorrect use with a backtrace of call (or allocation) location.
-#CONFIG_WPA_TRACE=y
-# For BSD, uncomment these.
-#LIBS += -lexecinfo
-#LIBS_p += -lexecinfo
-#LIBS_c += -lexecinfo
-
-# Use libbfd to get more details for developer debugging
-# This enables use of libbfd to get more detailed symbols for the backtraces
-# generated by CONFIG_WPA_TRACE=y.
-#CONFIG_WPA_TRACE_BFD=y
-# For BSD, uncomment these.
-#LIBS += -lbfd -liberty -lz
-#LIBS_p += -lbfd -liberty -lz
-#LIBS_c += -lbfd -liberty -lz
-
-# wpa_supplicant depends on strong random number generation being available
-# from the operating system. os_get_random() function is used to fetch random
-# data when needed, e.g., for key generation. On Linux and BSD systems, this
-# works by reading /dev/urandom. It should be noted that the OS entropy pool
-# needs to be properly initialized before wpa_supplicant is started. This is
-# important especially on embedded devices that do not have a hardware random
-# number generator and may by default start up with minimal entropy available
-# for random number generation.
-#
-# As a safety net, wpa_supplicant is by default trying to internally collect
-# additional entropy for generating random data to mix in with the data fetched
-# from the OS. This by itself is not considered to be very strong, but it may
-# help in cases where the system pool is not initialized properly. However, it
-# is very strongly recommended that the system pool is initialized with enough
-# entropy either by using hardware assisted random number generator or by
-# storing state over device reboots.
-#
-# wpa_supplicant can be configured to maintain its own entropy store over
-# restarts to enhance random number generation. This is not perfect, but it is
-# much more secure than using the same sequence of random numbers after every
-# reboot. This can be enabled with -e<entropy file> command line option. The
-# specified file needs to be readable and writable by wpa_supplicant.
-#
-# If the os_get_random() is known to provide strong random data (e.g., on
-# Linux/BSD, the board in question is known to have reliable source of random
-# data from /dev/urandom), the internal wpa_supplicant random pool can be
-# disabled. This will save some in binary size and CPU use. However, this
-# should only be considered for builds that are known to be used on devices
-# that meet the requirements described above.
-CONFIG_NO_RANDOM_POOL=y
-
-# Should we attempt to use the getrandom(2) call that provides more reliable
-# yet secure randomness source than /dev/random on Linux 3.17 and newer.
-# Requires glibc 2.25 to build, falls back to /dev/random if unavailable.
-CONFIG_GETRANDOM=y
-
-# IEEE 802.11n (High Throughput) support (mainly for AP mode)
-#CONFIG_IEEE80211N=y
-
-# IEEE 802.11ac (Very High Throughput) support (mainly for AP mode)
-# (depends on CONFIG_IEEE80211N)
-#CONFIG_IEEE80211AC=y
-
-# Wireless Network Management (IEEE Std 802.11v-2011)
-# Note: This is experimental and not complete implementation.
-#CONFIG_WNM=y
-
-# Interworking (IEEE 802.11u)
-# This can be used to enable functionality to improve interworking with
-# external networks (GAS/ANQP to learn more about the networks and network
-# selection based on available credentials).
-#CONFIG_INTERWORKING=y
-
-# Hotspot 2.0
-#CONFIG_HS20=y
-
-# Enable interface matching in wpa_supplicant
-#CONFIG_MATCH_IFACE=y
-
-# Disable roaming in wpa_supplicant
-#CONFIG_NO_ROAMING=y
-
-# AP mode operations with wpa_supplicant
-# This can be used for controlling AP mode operations with wpa_supplicant. It
-# should be noted that this is mainly aimed at simple cases like
-# WPA2-Personal while more complex configurations like WPA2-Enterprise with an
-# external RADIUS server can be supported with hostapd.
-#CONFIG_AP=y
-
-# P2P (Wi-Fi Direct)
-# This can be used to enable P2P support in wpa_supplicant. See README-P2P for
-# more information on P2P operations.
-#CONFIG_P2P=y
-
-# Enable TDLS support
-#CONFIG_TDLS=y
-
-# Wi-Fi Display
-# This can be used to enable Wi-Fi Display extensions for P2P using an external
-# program to control the additional information exchanges in the messages.
-#CONFIG_WIFI_DISPLAY=y
-
-# Autoscan
-# This can be used to enable automatic scan support in wpa_supplicant.
-# See wpa_supplicant.conf for more information on autoscan usage.
-#
-# Enabling directly a module will enable autoscan support.
-# For exponential module:
-#CONFIG_AUTOSCAN_EXPONENTIAL=y
-# For periodic module:
-#CONFIG_AUTOSCAN_PERIODIC=y
-
-# Password (and passphrase, etc.) backend for external storage
-# These optional mechanisms can be used to add support for storing passwords
-# and other secrets in external (to wpa_supplicant) location. This allows, for
-# example, operating system specific key storage to be used
-#
-# External password backend for testing purposes (developer use)
-#CONFIG_EXT_PASSWORD_TEST=y
-
-# Enable Fast Session Transfer (FST)
-#CONFIG_FST=y
-
-# Enable CLI commands for FST testing
-#CONFIG_FST_TEST=y
-
-# OS X builds. This is only for building eapol_test.
-#CONFIG_OSX=y
-
-# Automatic Channel Selection
-# This will allow wpa_supplicant to pick the channel automatically when channel
-# is set to "0".
-#
-# TODO: Extend parser to be able to parse "channel=acs_survey" as an alternative
-# to "channel=0". This would enable us to eventually add other ACS algorithms in
-# similar way.
-#
-# Automatic selection is currently only done through initialization, later on
-# we hope to do background checks to keep us moving to more ideal channels as
-# time goes by. ACS is currently only supported through the nl80211 driver and
-# your driver must have survey dump capability that is filled by the driver
-# during scanning.
-#
-# TODO: In analogy to hostapd be able to customize the ACS survey algorithm with
-# a newly to create wpa_supplicant.conf variable acs_num_scans.
-#
-# Supported ACS drivers:
-# * ath9k
-# * ath5k
-# * ath10k
-#
-# For more details refer to:
-# http://wireless.kernel.org/en/users/Documentation/acs
-#CONFIG_ACS=y
-
-# Support Multi Band Operation
-#CONFIG_MBO=y
-
-# Fast Initial Link Setup (FILS) (IEEE 802.11ai)
-#CONFIG_FILS=y
-# FILS shared key authentication with PFS
-#CONFIG_FILS_SK_PFS=y
-
-# Support RSN on IBSS networks
-# This is needed to be able to use mode=1 network profile with proto=RSN and
-# key_mgmt=WPA-PSK (i.e., full key management instead of WPA-None).
-#CONFIG_IBSS_RSN=y
-
-# External PMKSA cache control
-# This can be used to enable control interface commands that allow the current
-# PMKSA cache entries to be fetched and new entries to be added.
-#CONFIG_PMKSA_CACHE_EXTERNAL=y
-
-# Mesh Networking (IEEE 802.11s)
-#CONFIG_MESH=y
-
-# Background scanning modules
-# These can be used to request wpa_supplicant to perform background scanning
-# operations for roaming within an ESS (same SSID). See the bgscan parameter in
-# the wpa_supplicant.conf file for more details.
-# Periodic background scans based on signal strength
-#CONFIG_BGSCAN_SIMPLE=y
-# Learn channels used by the network and try to avoid bgscans on other
-# channels (experimental)
-#CONFIG_BGSCAN_LEARN=y
-
-# Opportunistic Wireless Encryption (OWE)
-# Experimental implementation of draft-harkins-owe-07.txt
-#CONFIG_OWE=y
-
-# Device Provisioning Protocol (DPP)
-# This requires CONFIG_IEEE80211W=y to be enabled, too. (see
-# wpa_supplicant/README-DPP for details)
-#CONFIG_DPP=y
-
-# uBus IPC/RPC System
-# Services can connect to the bus and provide methods
-# that can be called by other services or clients.
-CONFIG_UBUS=y
-
-# OpenWrt patch 380-disable-ctrl-iface-mib.patch
-# leads to the MIB only being compiled in if
-# CONFIG_CTRL_IFACE_MIB is enabled.
-#CONFIG_CTRL_IFACE_MIB=y
diff --git a/package/network/services/hostapd/files/wpa_supplicant-p2p.config b/package/network/services/hostapd/files/wpa_supplicant-p2p.config
deleted file mode 100644
index b00847a256..0000000000
--- a/package/network/services/hostapd/files/wpa_supplicant-p2p.config
+++ /dev/null
@@ -1,625 +0,0 @@
-# Example wpa_supplicant build time configuration
-#
-# This file lists the configuration options that are used when building the
-# wpa_supplicant binary. All lines starting with # are ignored. Configuration
-# option lines must be commented out complete, if they are not to be included,
-# i.e., just setting VARIABLE=n is not disabling that variable.
-#
-# This file is included in Makefile, so variables like CFLAGS and LIBS can also
-# be modified from here. In most cases, these lines should use += in order not
-# to override previous values of the variables.
-
-
-# Uncomment following two lines and fix the paths if you have installed OpenSSL
-# or GnuTLS in non-default location
-#CFLAGS += -I/usr/local/openssl/include
-#LIBS += -L/usr/local/openssl/lib
-
-# Some Red Hat versions seem to include kerberos header files from OpenSSL, but
-# the kerberos files are not in the default include path. Following line can be
-# used to fix build issues on such systems (krb5.h not found).
-#CFLAGS += -I/usr/include/kerberos
-
-# Driver interface for generic Linux wireless extensions
-# Note: WEXT is deprecated in the current Linux kernel version and no new
-# functionality is added to it. nl80211-based interface is the new
-# replacement for WEXT and its use allows wpa_supplicant to properly control
-# the driver to improve existing functionality like roaming and to support new
-# functionality.
-CONFIG_DRIVER_WEXT=y
-
-# Driver interface for Linux drivers using the nl80211 kernel interface
-CONFIG_DRIVER_NL80211=y
-
-# QCA vendor extensions to nl80211
-#CONFIG_DRIVER_NL80211_QCA=y
-
-# driver_nl80211.c requires libnl. If you are compiling it yourself
-# you may need to point hostapd to your version of libnl.
-#
-#CFLAGS += -I$<path to libnl include files>
-#LIBS += -L$<path to libnl library files>
-
-# Use libnl v2.0 (or 3.0) libraries.
-#CONFIG_LIBNL20=y
-
-# Use libnl 3.2 libraries (if this is selected, CONFIG_LIBNL20 is ignored)
-#CONFIG_LIBNL32=y
-
-
-# Driver interface for FreeBSD net80211 layer (e.g., Atheros driver)
-#CONFIG_DRIVER_BSD=y
-#CFLAGS += -I/usr/local/include
-#LIBS += -L/usr/local/lib
-#LIBS_p += -L/usr/local/lib
-#LIBS_c += -L/usr/local/lib
-
-# Driver interface for Windows NDIS
-#CONFIG_DRIVER_NDIS=y
-#CFLAGS += -I/usr/include/w32api/ddk
-#LIBS += -L/usr/local/lib
-# For native build using mingw
-#CONFIG_NATIVE_WINDOWS=y
-# Additional directories for cross-compilation on Linux host for mingw target
-#CFLAGS += -I/opt/mingw/mingw32/include/ddk
-#LIBS += -L/opt/mingw/mingw32/lib
-#CC=mingw32-gcc
-# By default, driver_ndis uses WinPcap for low-level operations. This can be
-# replaced with the following option which replaces WinPcap calls with NDISUIO.
-# However, this requires that WZC is disabled (net stop wzcsvc) before starting
-# wpa_supplicant.
-# CONFIG_USE_NDISUIO=y
-
-# Driver interface for wired Ethernet drivers
-CONFIG_DRIVER_WIRED=y
-
-# Driver interface for MACsec capable Qualcomm Atheros drivers
-#CONFIG_DRIVER_MACSEC_QCA=y
-
-# Driver interface for Linux MACsec drivers
-#CONFIG_DRIVER_MACSEC_LINUX=y
-
-# Driver interface for the Broadcom RoboSwitch family
-#CONFIG_DRIVER_ROBOSWITCH=y
-
-# Driver interface for no driver (e.g., WPS ER only)
-#CONFIG_DRIVER_NONE=y
-
-# Solaris libraries
-#LIBS += -lsocket -ldlpi -lnsl
-#LIBS_c += -lsocket
-
-# Enable IEEE 802.1X Supplicant (automatically included if any EAP method or
-# MACsec is included)
-CONFIG_IEEE8021X_EAPOL=y
-
-# EAP-MD5
-CONFIG_EAP_MD5=y
-
-# EAP-MSCHAPv2
-CONFIG_EAP_MSCHAPV2=y
-
-# EAP-TLS
-CONFIG_EAP_TLS=y
-
-# EAL-PEAP
-CONFIG_EAP_PEAP=y
-
-# EAP-TTLS
-CONFIG_EAP_TTLS=y
-
-# EAP-FAST
-CONFIG_EAP_FAST=y
-
-# EAP-TEAP
-# Note: The current EAP-TEAP implementation is experimental and should not be
-# enabled for production use. The IETF RFC 7170 that defines EAP-TEAP has number
-# of conflicting statements and missing details and the implementation has
-# vendor specific workarounds for those and as such, may not interoperate with
-# any other implementation. This should not be used for anything else than
-# experimentation and interoperability testing until those issues has been
-# resolved.
-#CONFIG_EAP_TEAP=y
-
-# EAP-GTC
-CONFIG_EAP_GTC=y
-
-# EAP-OTP
-CONFIG_EAP_OTP=y
-
-# EAP-SIM (enable CONFIG_PCSC, if EAP-SIM is used)
-#CONFIG_EAP_SIM=y
-
-# Enable SIM simulator (Milenage) for EAP-SIM
-#CONFIG_SIM_SIMULATOR=y
-
-# EAP-PSK (experimental; this is _not_ needed for WPA-PSK)
-#CONFIG_EAP_PSK=y
-
-# EAP-pwd (secure authentication using only a password)
-#CONFIG_EAP_PWD=y
-
-# EAP-PAX
-#CONFIG_EAP_PAX=y
-
-# LEAP
-CONFIG_EAP_LEAP=y
-
-# EAP-AKA (enable CONFIG_PCSC, if EAP-AKA is used)
-#CONFIG_EAP_AKA=y
-
-# EAP-AKA' (enable CONFIG_PCSC, if EAP-AKA' is used).
-# This requires CONFIG_EAP_AKA to be enabled, too.
-#CONFIG_EAP_AKA_PRIME=y
-
-# Enable USIM simulator (Milenage) for EAP-AKA
-#CONFIG_USIM_SIMULATOR=y
-
-# EAP-SAKE
-#CONFIG_EAP_SAKE=y
-
-# EAP-GPSK
-#CONFIG_EAP_GPSK=y
-# Include support for optional SHA256 cipher suite in EAP-GPSK
-#CONFIG_EAP_GPSK_SHA256=y
-
-# EAP-TNC and related Trusted Network Connect support (experimental)
-#CONFIG_EAP_TNC=y
-
-# Wi-Fi Protected Setup (WPS)
-CONFIG_WPS=y
-# Enable WPS external registrar functionality
-#CONFIG_WPS_ER=y
-# Disable credentials for an open network by default when acting as a WPS
-# registrar.
-#CONFIG_WPS_REG_DISABLE_OPEN=y
-# Enable WPS support with NFC config method
-#CONFIG_WPS_NFC=y
-
-# EAP-IKEv2
-#CONFIG_EAP_IKEV2=y
-
-# EAP-EKE
-#CONFIG_EAP_EKE=y
-
-# MACsec
-#CONFIG_MACSEC=y
-
-# PKCS#12 (PFX) support (used to read private key and certificate file from
-# a file that usually has extension .p12 or .pfx)
-CONFIG_PKCS12=y
-
-# Smartcard support (i.e., private key on a smartcard), e.g., with openssl
-# engine.
-CONFIG_SMARTCARD=y
-
-# PC/SC interface for smartcards (USIM, GSM SIM)
-# Enable this if EAP-SIM or EAP-AKA is included
-#CONFIG_PCSC=y
-
-# Support HT overrides (disable HT/HT40, mask MCS rates, etc.)
-CONFIG_HT_OVERRIDES=y
-
-# Support VHT overrides (disable VHT, mask MCS rates, etc.)
-CONFIG_VHT_OVERRIDES=y
-
-# Development testing
-#CONFIG_EAPOL_TEST=y
-
-# Select control interface backend for external programs, e.g, wpa_cli:
-# unix = UNIX domain sockets (default for Linux/*BSD)
-# udp = UDP sockets using localhost (127.0.0.1)
-# udp6 = UDP IPv6 sockets using localhost (::1)
-# named_pipe = Windows Named Pipe (default for Windows)
-# udp-remote = UDP sockets with remote access (only for tests systems/purpose)
-# udp6-remote = UDP IPv6 sockets with remote access (only for tests purpose)
-# y = use default (backwards compatibility)
-# If this option is commented out, control interface is not included in the
-# build.
-CONFIG_CTRL_IFACE=y
-
-# Include support for GNU Readline and History Libraries in wpa_cli.
-# When building a wpa_cli binary for distribution, please note that these
-# libraries are licensed under GPL and as such, BSD license may not apply for
-# the resulting binary.
-#CONFIG_READLINE=y
-
-# Include internal line edit mode in wpa_cli. This can be used as a replacement
-# for GNU Readline to provide limited command line editing and history support.
-#CONFIG_WPA_CLI_EDIT=y
-
-# Remove debugging code that is printing out debug message to stdout.
-# This can be used to reduce the size of the wpa_supplicant considerably
-# if debugging code is not needed. The size reduction can be around 35%
-# (e.g., 90 kB).
-#CONFIG_NO_STDOUT_DEBUG=y
-
-# Remove WPA support, e.g., for wired-only IEEE 802.1X supplicant, to save
-# 35-50 kB in code size.
-#CONFIG_NO_WPA=y
-
-# Remove IEEE 802.11i/WPA-Personal ASCII passphrase support
-# This option can be used to reduce code size by removing support for
-# converting ASCII passphrases into PSK. If this functionality is removed, the
-# PSK can only be configured as the 64-octet hexstring (e.g., from
-# wpa_passphrase). This saves about 0.5 kB in code size.
-#CONFIG_NO_WPA_PASSPHRASE=y
-
-# Simultaneous Authentication of Equals (SAE), WPA3-Personal
-#CONFIG_SAE=y
-
-# Disable scan result processing (ap_mode=1) to save code size by about 1 kB.
-# This can be used if ap_scan=1 mode is never enabled.
-#CONFIG_NO_SCAN_PROCESSING=y
-
-# Select configuration backend:
-# file = text file (e.g., wpa_supplicant.conf; note: the configuration file
-#	path is given on command line, not here; this option is just used to
-#	select the backend that allows configuration files to be used)
-# winreg = Windows registry (see win_example.reg for an example)
-CONFIG_BACKEND=file
-
-# Remove configuration write functionality (i.e., to allow the configuration
-# file to be updated based on runtime configuration changes). The runtime
-# configuration can still be changed, the changes are just not going to be
-# persistent over restarts. This option can be used to reduce code size by
-# about 3.5 kB.
-#CONFIG_NO_CONFIG_WRITE=y
-
-# Remove support for configuration blobs to reduce code size by about 1.5 kB.
-#CONFIG_NO_CONFIG_BLOBS=y
-
-# Select program entry point implementation:
-# main = UNIX/POSIX like main() function (default)
-# main_winsvc = Windows service (read parameters from registry)
-# main_none = Very basic example (development use only)
-#CONFIG_MAIN=main
-
-# Select wrapper for operating system and C library specific functions
-# unix = UNIX/POSIX like systems (default)
-# win32 = Windows systems
-# none = Empty template
-#CONFIG_OS=unix
-
-# Select event loop implementation
-# eloop = select() loop (default)
-# eloop_win = Windows events and WaitForMultipleObject() loop
-#CONFIG_ELOOP=eloop
-
-# Should we use poll instead of select? Select is used by default.
-#CONFIG_ELOOP_POLL=y
-
-# Should we use epoll instead of select? Select is used by default.
-CONFIG_ELOOP_EPOLL=y
-
-# Should we use kqueue instead of select? Select is used by default.
-#CONFIG_ELOOP_KQUEUE=y
-
-# Select layer 2 packet implementation
-# linux = Linux packet socket (default)
-# pcap = libpcap/libdnet/WinPcap
-# freebsd = FreeBSD libpcap
-# winpcap = WinPcap with receive thread
-# ndis = Windows NDISUIO (note: requires CONFIG_USE_NDISUIO=y)
-# none = Empty template
-#CONFIG_L2_PACKET=linux
-
-# Disable Linux packet socket workaround applicable for station interface
-# in a bridge for EAPOL frames. This should be uncommented only if the kernel
-# is known to not have the regression issue in packet socket behavior with
-# bridge interfaces (commit 'bridge: respect RFC2863 operational state')').
-CONFIG_NO_LINUX_PACKET_SOCKET_WAR=y
-
-# IEEE 802.11w (management frame protection), also known as PMF
-# Driver support is also needed for IEEE 802.11w.
-CONFIG_IEEE80211W=y
-
-# Support Operating Channel Validation
-#CONFIG_OCV=y
-
-# Select TLS implementation
-# openssl = OpenSSL (default)
-# gnutls = GnuTLS
-# internal = Internal TLSv1 implementation (experimental)
-# linux = Linux kernel AF_ALG and internal TLSv1 implementation (experimental)
-# none = Empty template
-CONFIG_TLS=internal
-
-# TLS-based EAP methods require at least TLS v1.0. Newer version of TLS (v1.1)
-# can be enabled to get a stronger construction of messages when block ciphers
-# are used. It should be noted that some existing TLS v1.0 -based
-# implementation may not be compatible with TLS v1.1 message (ClientHello is
-# sent prior to negotiating which version will be used)
-#CONFIG_TLSV11=y
-
-# TLS-based EAP methods require at least TLS v1.0. Newer version of TLS (v1.2)
-# can be enabled to enable use of stronger crypto algorithms. It should be
-# noted that some existing TLS v1.0 -based implementation may not be compatible
-# with TLS v1.2 message (ClientHello is sent prior to negotiating which version
-# will be used)
-#CONFIG_TLSV12=y
-
-# Select which ciphers to use by default with OpenSSL if the user does not
-# specify them.
-#CONFIG_TLS_DEFAULT_CIPHERS="DEFAULT:!EXP:!LOW"
-
-# If CONFIG_TLS=internal is used, additional library and include paths are
-# needed for LibTomMath. Alternatively, an integrated, minimal version of
-# LibTomMath can be used. See beginning of libtommath.c for details on benefits
-# and drawbacks of this option.
-CONFIG_INTERNAL_LIBTOMMATH=y
-#ifndef CONFIG_INTERNAL_LIBTOMMATH
-#LTM_PATH=/usr/src/libtommath-0.39
-#CFLAGS += -I$(LTM_PATH)
-#LIBS += -L$(LTM_PATH)
-#LIBS_p += -L$(LTM_PATH)
-#endif
-# At the cost of about 4 kB of additional binary size, the internal LibTomMath
-# can be configured to include faster routines for exptmod, sqr, and div to
-# speed up DH and RSA calculation considerably
-CONFIG_INTERNAL_LIBTOMMATH_FAST=y
-
-# Include NDIS event processing through WMI into wpa_supplicant/wpasvc.
-# This is only for Windows builds and requires WMI-related header files and
-# WbemUuid.Lib from Platform SDK even when building with MinGW.
-#CONFIG_NDIS_EVENTS_INTEGRATED=y
-#PLATFORMSDKLIB="/opt/Program Files/Microsoft Platform SDK/Lib"
-
-# Add support for new DBus control interface
-# (fi.w1.hostap.wpa_supplicant1)
-#CONFIG_CTRL_IFACE_DBUS_NEW=y
-
-# Add introspection support for new DBus control interface
-#CONFIG_CTRL_IFACE_DBUS_INTRO=y
-
-# Add support for loading EAP methods dynamically as shared libraries.
-# When this option is enabled, each EAP method can be either included
-# statically (CONFIG_EAP_<method>=y) or dynamically (CONFIG_EAP_<method>=dyn).
-# Dynamic EAP methods are build as shared objects (eap_*.so) and they need to
-# be loaded in the beginning of the wpa_supplicant configuration file
-# (see load_dynamic_eap parameter in the example file) before being used in
-# the network blocks.
-#
-# Note that some shared parts of EAP methods are included in the main program
-# and in order to be able to use dynamic EAP methods using these parts, the
-# main program must have been build with the EAP method enabled (=y or =dyn).
-# This means that EAP-TLS/PEAP/TTLS/FAST cannot be added as dynamic libraries
-# unless at least one of them was included in the main build to force inclusion
-# of the shared code. Similarly, at least one of EAP-SIM/AKA must be included
-# in the main build to be able to load these methods dynamically.
-#
-# Please also note that using dynamic libraries will increase the total binary
-# size. Thus, it may not be the best option for targets that have limited
-# amount of memory/flash.
-#CONFIG_DYNAMIC_EAP_METHODS=y
-
-# IEEE Std 802.11r-2008 (Fast BSS Transition) for station mode
-#CONFIG_IEEE80211R=y
-
-# Add support for writing debug log to a file (/tmp/wpa_supplicant-log-#.txt)
-#CONFIG_DEBUG_FILE=y
-
-# Send debug messages to syslog instead of stdout
-CONFIG_DEBUG_SYSLOG=y
-# Set syslog facility for debug messages
-CONFIG_DEBUG_SYSLOG_FACILITY=LOG_DAEMON
-
-# Add support for sending all debug messages (regardless of debug verbosity)
-# to the Linux kernel tracing facility. This helps debug the entire stack by
-# making it easy to record everything happening from the driver up into the
-# same file, e.g., using trace-cmd.
-#CONFIG_DEBUG_LINUX_TRACING=y
-
-# Add support for writing debug log to Android logcat instead of standard
-# output
-#CONFIG_ANDROID_LOG=y
-
-# Enable privilege separation (see README 'Privilege separation' for details)
-#CONFIG_PRIVSEP=y
-
-# Enable mitigation against certain attacks against TKIP by delaying Michael
-# MIC error reports by a random amount of time between 0 and 60 seconds
-#CONFIG_DELAYED_MIC_ERROR_REPORT=y
-
-# Enable tracing code for developer debugging
-# This tracks use of memory allocations and other registrations and reports
-# incorrect use with a backtrace of call (or allocation) location.
-#CONFIG_WPA_TRACE=y
-# For BSD, uncomment these.
-#LIBS += -lexecinfo
-#LIBS_p += -lexecinfo
-#LIBS_c += -lexecinfo
-
-# Use libbfd to get more details for developer debugging
-# This enables use of libbfd to get more detailed symbols for the backtraces
-# generated by CONFIG_WPA_TRACE=y.
-#CONFIG_WPA_TRACE_BFD=y
-# For BSD, uncomment these.
-#LIBS += -lbfd -liberty -lz
-#LIBS_p += -lbfd -liberty -lz
-#LIBS_c += -lbfd -liberty -lz
-
-# wpa_supplicant depends on strong random number generation being available
-# from the operating system. os_get_random() function is used to fetch random
-# data when needed, e.g., for key generation. On Linux and BSD systems, this
-# works by reading /dev/urandom. It should be noted that the OS entropy pool
-# needs to be properly initialized before wpa_supplicant is started. This is
-# important especially on embedded devices that do not have a hardware random
-# number generator and may by default start up with minimal entropy available
-# for random number generation.
-#
-# As a safety net, wpa_supplicant is by default trying to internally collect
-# additional entropy for generating random data to mix in with the data fetched
-# from the OS. This by itself is not considered to be very strong, but it may
-# help in cases where the system pool is not initialized properly. However, it
-# is very strongly recommended that the system pool is initialized with enough
-# entropy either by using hardware assisted random number generator or by
-# storing state over device reboots.
-#
-# wpa_supplicant can be configured to maintain its own entropy store over
-# restarts to enhance random number generation. This is not perfect, but it is
-# much more secure than using the same sequence of random numbers after every
-# reboot. This can be enabled with -e<entropy file> command line option. The
-# specified file needs to be readable and writable by wpa_supplicant.
-#
-# If the os_get_random() is known to provide strong random data (e.g., on
-# Linux/BSD, the board in question is known to have reliable source of random
-# data from /dev/urandom), the internal wpa_supplicant random pool can be
-# disabled. This will save some in binary size and CPU use. However, this
-# should only be considered for builds that are known to be used on devices
-# that meet the requirements described above.
-CONFIG_NO_RANDOM_POOL=y
-
-# Should we attempt to use the getrandom(2) call that provides more reliable
-# yet secure randomness source than /dev/random on Linux 3.17 and newer.
-# Requires glibc 2.25 to build, falls back to /dev/random if unavailable.
-CONFIG_GETRANDOM=y
-
-# IEEE 802.11n (High Throughput) support (mainly for AP mode)
-#CONFIG_IEEE80211N=y
-
-# IEEE 802.11ac (Very High Throughput) support (mainly for AP mode)
-# (depends on CONFIG_IEEE80211N)
-#CONFIG_IEEE80211AC=y
-
-# Wireless Network Management (IEEE Std 802.11v-2011)
-# Note: This is experimental and not complete implementation.
-#CONFIG_WNM=y
-
-# Interworking (IEEE 802.11u)
-# This can be used to enable functionality to improve interworking with
-# external networks (GAS/ANQP to learn more about the networks and network
-# selection based on available credentials).
-#CONFIG_INTERWORKING=y
-
-# Hotspot 2.0
-#CONFIG_HS20=y
-
-# Enable interface matching in wpa_supplicant
-#CONFIG_MATCH_IFACE=y
-
-# Disable roaming in wpa_supplicant
-#CONFIG_NO_ROAMING=y
-
-# AP mode operations with wpa_supplicant
-# This can be used for controlling AP mode operations with wpa_supplicant. It
-# should be noted that this is mainly aimed at simple cases like
-# WPA2-Personal while more complex configurations like WPA2-Enterprise with an
-# external RADIUS server can be supported with hostapd.
-CONFIG_AP=y
-
-# P2P (Wi-Fi Direct)
-# This can be used to enable P2P support in wpa_supplicant. See README-P2P for
-# more information on P2P operations.
-CONFIG_P2P=y
-
-# Enable TDLS support
-#CONFIG_TDLS=y
-
-# Wi-Fi Display
-# This can be used to enable Wi-Fi Display extensions for P2P using an external
-# program to control the additional information exchanges in the messages.
-#CONFIG_WIFI_DISPLAY=y
-
-# Autoscan
-# This can be used to enable automatic scan support in wpa_supplicant.
-# See wpa_supplicant.conf for more information on autoscan usage.
-#
-# Enabling directly a module will enable autoscan support.
-# For exponential module:
-#CONFIG_AUTOSCAN_EXPONENTIAL=y
-# For periodic module:
-#CONFIG_AUTOSCAN_PERIODIC=y
-
-# Password (and passphrase, etc.) backend for external storage
-# These optional mechanisms can be used to add support for storing passwords
-# and other secrets in external (to wpa_supplicant) location. This allows, for
-# example, operating system specific key storage to be used
-#
-# External password backend for testing purposes (developer use)
-#CONFIG_EXT_PASSWORD_TEST=y
-
-# Enable Fast Session Transfer (FST)
-#CONFIG_FST=y
-
-# Enable CLI commands for FST testing
-#CONFIG_FST_TEST=y
-
-# OS X builds. This is only for building eapol_test.
-#CONFIG_OSX=y
-
-# Automatic Channel Selection
-# This will allow wpa_supplicant to pick the channel automatically when channel
-# is set to "0".
-#
-# TODO: Extend parser to be able to parse "channel=acs_survey" as an alternative
-# to "channel=0". This would enable us to eventually add other ACS algorithms in
-# similar way.
-#
-# Automatic selection is currently only done through initialization, later on
-# we hope to do background checks to keep us moving to more ideal channels as
-# time goes by. ACS is currently only supported through the nl80211 driver and
-# your driver must have survey dump capability that is filled by the driver
-# during scanning.
-#
-# TODO: In analogy to hostapd be able to customize the ACS survey algorithm with
-# a newly to create wpa_supplicant.conf variable acs_num_scans.
-#
-# Supported ACS drivers:
-# * ath9k
-# * ath5k
-# * ath10k
-#
-# For more details refer to:
-# http://wireless.kernel.org/en/users/Documentation/acs
-#CONFIG_ACS=y
-
-# Support Multi Band Operation
-#CONFIG_MBO=y
-
-# Fast Initial Link Setup (FILS) (IEEE 802.11ai)
-#CONFIG_FILS=y
-# FILS shared key authentication with PFS
-#CONFIG_FILS_SK_PFS=y
-
-# Support RSN on IBSS networks
-# This is needed to be able to use mode=1 network profile with proto=RSN and
-# key_mgmt=WPA-PSK (i.e., full key management instead of WPA-None).
-CONFIG_IBSS_RSN=y
-
-# External PMKSA cache control
-# This can be used to enable control interface commands that allow the current
-# PMKSA cache entries to be fetched and new entries to be added.
-#CONFIG_PMKSA_CACHE_EXTERNAL=y
-
-# Mesh Networking (IEEE 802.11s)
-#CONFIG_MESH=y
-
-# Background scanning modules
-# These can be used to request wpa_supplicant to perform background scanning
-# operations for roaming within an ESS (same SSID). See the bgscan parameter in
-# the wpa_supplicant.conf file for more details.
-# Periodic background scans based on signal strength
-#CONFIG_BGSCAN_SIMPLE=y
-# Learn channels used by the network and try to avoid bgscans on other
-# channels (experimental)
-#CONFIG_BGSCAN_LEARN=y
-
-# Opportunistic Wireless Encryption (OWE)
-# Experimental implementation of draft-harkins-owe-07.txt
-#CONFIG_OWE=y
-
-# Device Provisioning Protocol (DPP)
-# This requires CONFIG_IEEE80211W=y to be enabled, too. (see
-# wpa_supplicant/README-DPP for details)
-#CONFIG_DPP=y
-
-# uBus IPC/RPC System
-# Services can connect to the bus and provide methods
-# that can be called by other services or clients.
-CONFIG_UBUS=y
-
-# OpenWrt patch 380-disable-ctrl-iface-mib.patch
-# leads to the MIB only being compiled in if
-# CONFIG_CTRL_IFACE_MIB is enabled.
-#CONFIG_CTRL_IFACE_MIB=y
diff --git a/package/network/services/hostapd/files/wpad.init b/package/network/services/hostapd/files/wpad.init
deleted file mode 100644
index 79c5bf1075..0000000000
--- a/package/network/services/hostapd/files/wpad.init
+++ /dev/null
@@ -1,41 +0,0 @@
-#!/bin/sh /etc/rc.common
-
-START=19
-STOP=21
-
-USE_PROCD=1
-NAME=wpad
-
-start_service() {
-	if [ -x "/usr/sbin/hostapd" ]; then
-		mkdir -p /var/run/hostapd
-		chown network:network /var/run/hostapd
-		procd_open_instance hostapd
-		procd_set_param command /usr/sbin/hostapd -s -g /var/run/hostapd/global
-		procd_set_param respawn 3600 1 0
-		[ -x /sbin/ujail -a -e /etc/capabilities/wpad.json ] && {
-			procd_add_jail hostapd
-			procd_set_param capabilities /etc/capabilities/wpad.json
-			procd_set_param user network
-			procd_set_param group network
-			procd_set_param no_new_privs 1
-		}
-		procd_close_instance
-	fi
-
-	if [ -x "/usr/sbin/wpa_supplicant" ]; then
-		mkdir -p /var/run/wpa_supplicant
-		chown network:network /var/run/wpa_supplicant
-		procd_open_instance supplicant
-		procd_set_param command /usr/sbin/wpa_supplicant -n -s -g /var/run/wpa_supplicant/global
-		procd_set_param respawn 3600 1 0
-		[ -x /sbin/ujail -a -e /etc/capabilities/wpad.json ] && {
-			procd_add_jail wpa_supplicant
-			procd_set_param capabilities /etc/capabilities/wpad.json
-			procd_set_param user network
-			procd_set_param group network
-			procd_set_param no_new_privs 1
-		}
-		procd_close_instance
-	fi
-}
diff --git a/package/network/services/hostapd/files/wpad.json b/package/network/services/hostapd/files/wpad.json
deleted file mode 100644
index c73f3d98bd..0000000000
--- a/package/network/services/hostapd/files/wpad.json
+++ /dev/null
@@ -1,22 +0,0 @@
-{
-	"bounding": [
-		"CAP_NET_ADMIN",
-		"CAP_NET_RAW"
-	],
-	"effective": [
-		"CAP_NET_ADMIN",
-		"CAP_NET_RAW"
-	],
-	"ambient": [
-		"CAP_NET_ADMIN",
-		"CAP_NET_RAW"
-	],
-	"permitted": [
-		"CAP_NET_ADMIN",
-		"CAP_NET_RAW"
-	],
-	"inheritable": [
-		"CAP_NET_ADMIN",
-		"CAP_NET_RAW"
-	]
-}
diff --git a/package/network/services/hostapd/files/wpad_acl.json b/package/network/services/hostapd/files/wpad_acl.json
deleted file mode 100644
index c77ccd8ea0..0000000000
--- a/package/network/services/hostapd/files/wpad_acl.json
+++ /dev/null
@@ -1,10 +0,0 @@
-{
-	"user": "network",
-	"access": {
-		"service": {
-			"methods": [ "event" ]
-		}
-	},
-	"publish": [ "hostapd", "hostapd.*", "wpa_supplicant", "wpa_supplicant.*" ],
-	"send": [ "bss.*", "wps_credentials" ]
-}
diff --git a/package/network/services/hostapd/files/wps-hotplug.sh b/package/network/services/hostapd/files/wps-hotplug.sh
deleted file mode 100644
index d00939d769..0000000000
--- a/package/network/services/hostapd/files/wps-hotplug.sh
+++ /dev/null
@@ -1,62 +0,0 @@
-#!/bin/sh
-
-wps_catch_credentials() {
-	local iface ifaces ifc ifname ssid encryption key radio radios
-	local found=0
-
-	. /usr/share/libubox/jshn.sh
-	ubus -S -t 30 listen wps_credentials | while read creds; do
-		json_init
-		json_load "$creds"
-		json_select wps_credentials || continue
-		json_get_vars ifname ssid key encryption
-		local ifcname="$ifname"
-		json_init
-		json_load "$(ubus -S call network.wireless status)"
-		json_get_keys radios
-		for radio in $radios; do
-			json_select $radio
-			json_select interfaces
-			json_get_keys ifaces
-			for ifc in $ifaces; do
-				json_select $ifc
-				json_get_vars ifname
-				[ "$ifname" = "$ifcname" ] && {
-					ubus -S call uci set "{\"config\":\"wireless\", \"type\":\"wifi-iface\",		\
-								\"match\": { \"device\": \"$radio\", \"encryption\": \"wps\" },	\
-								\"values\": { \"encryption\": \"$encryption\", 			\
-										\"ssid\": \"$ssid\", 				\
-										\"key\": \"$key\" } }"
-					ubus -S call uci commit '{"config": "wireless"}'
-					ubus -S call uci apply
-				}
-				json_select ..
-			done
-			json_select ..
-			json_select ..
-		done
-	done
-}
-
-if [ "$ACTION" = "pressed" -a "$BUTTON" = "wps" ]; then
-	wps_done=0
-	ubusobjs="$( ubus -S list hostapd.* )"
-	for ubusobj in $ubusobjs; do
-		ubus -S call $ubusobj wps_start && wps_done=1
-	done
-	[ $wps_done = 0 ] || return 0
-	wps_done=0
-	ubusobjs="$( ubus -S list wpa_supplicant.* )"
-	for ubusobj in $ubusobjs; do
-		ifname="$(echo $ubusobj | cut -d'.' -f2 )"
-		multi_ap=""
-		if [ -e "/var/run/wpa_supplicant-${ifname}.conf.is_multiap" ]; then
-			ubus -S call $ubusobj wps_start '{ "multi_ap": true }' && wps_done=1
-		else
-			ubus -S call $ubusobj wps_start && wps_done=1
-		fi
-	done
-	[ $wps_done = 0 ] || wps_catch_credentials &
-fi
-
-return 0
diff --git a/package/network/services/hostapd/patches/001-HE-VHT-fix-frequency-setup-with-HE-enabled.patch b/package/network/services/hostapd/patches/001-HE-VHT-fix-frequency-setup-with-HE-enabled.patch
deleted file mode 100644
index 37c17c50af..0000000000
--- a/package/network/services/hostapd/patches/001-HE-VHT-fix-frequency-setup-with-HE-enabled.patch
+++ /dev/null
@@ -1,196 +0,0 @@
-From 91976250359b263a44861aebe553b20627fe487e Mon Sep 17 00:00:00 2001
-From: Markus Theil <markus.theil@tu-ilmenau.de>
-Date: Tue, 30 Jun 2020 13:53:17 +0200
-Subject: [PATCH 01/19] HE/VHT: fix frequency setup with HE enabled
-
-Some places in the code base were not using the
-wrappers like hostapd_set_oper_centr_freq_seg0_idx
-and friends. This could lead to errors, for example when
-joining 80 MHz mesh networks. Fix this, by enforcing
-usage of these wrappers.
-
-wpa_supplicant_conf_ap_ht now checks for HE capability
-before dealing with VHT in order for these wrappers to work,
-as they first check HE support in the config.
-
-While doing these changes, I've noticed that the extra
-channel setup code for mesh networks in wpa_supplicant/mesh.c
-should not be necessary anymore and dropped it.
-wpa_supplicant_conf_ap_ht should handle this setup already.
-
-Acked-by: John Crispin <john@phrozen.org>
-Signed-off-by: Markus Theil <markus.theil@tu-ilmenau.de>
----
- src/ap/dfs.c          |  8 ++++----
- wpa_supplicant/ap.c   | 40 +++++++++++++++++++++++-----------------
- wpa_supplicant/mesh.c | 24 ------------------------
- 3 files changed, 27 insertions(+), 45 deletions(-)
-
---- a/src/ap/dfs.c
-+++ b/src/ap/dfs.c
-@@ -1028,7 +1028,7 @@ static int hostapd_dfs_start_channel_swi
- 	unsigned int i;
- 	int err = 1;
- 	struct hostapd_hw_modes *cmode = iface->current_mode;
--	u8 current_vht_oper_chwidth = iface->conf->vht_oper_chwidth;
-+	u8 current_vht_oper_chwidth = hostapd_get_oper_chwidth(iface->conf);
- 
- 	wpa_printf(MSG_DEBUG, "%s called (CAC active: %s, CSA active: %s)",
- 		   __func__, iface->cac_started ? "yes" : "no",
-@@ -1089,8 +1089,8 @@ static int hostapd_dfs_start_channel_swi
- 		"freq=%d chan=%d sec_chan=%d", channel->freq,
- 		channel->chan, secondary_channel);
- 
--	new_vht_oper_chwidth = iface->conf->vht_oper_chwidth;
--	iface->conf->vht_oper_chwidth = current_vht_oper_chwidth;
-+	new_vht_oper_chwidth = hostapd_get_oper_chwidth(iface->conf);
-+	hostapd_set_oper_chwidth(iface->conf, current_vht_oper_chwidth);
- 
- 	/* Setup CSA request */
- 	os_memset(&csa_settings, 0, sizeof(csa_settings));
-@@ -1130,7 +1130,7 @@ static int hostapd_dfs_start_channel_swi
- 		iface->freq = channel->freq;
- 		iface->conf->channel = channel->chan;
- 		iface->conf->secondary_channel = secondary_channel;
--		iface->conf->vht_oper_chwidth = new_vht_oper_chwidth;
-+		hostapd_set_oper_chwidth(iface->conf, new_vht_oper_chwidth);
- 		hostapd_set_oper_centr_freq_seg0_idx(iface->conf,
- 						     oper_centr_freq_seg0_idx);
- 		hostapd_set_oper_centr_freq_seg1_idx(iface->conf,
---- a/wpa_supplicant/ap.c
-+++ b/wpa_supplicant/ap.c
-@@ -52,6 +52,7 @@ static void wpas_conf_ap_vht(struct wpa_
- #ifdef CONFIG_P2P
- 	u8 center_chan = 0;
- 	u8 channel = conf->channel;
-+	u8 freq_seg_idx;
- #endif /* CONFIG_P2P */
- 
- 	if (!conf->secondary_channel)
-@@ -59,19 +60,21 @@ static void wpas_conf_ap_vht(struct wpa_
- 
- 	/* Use the maximum oper channel width if it's given. */
- 	if (ssid->max_oper_chwidth)
--		conf->vht_oper_chwidth = ssid->max_oper_chwidth;
-+		hostapd_set_oper_chwidth(conf, ssid->max_oper_chwidth);
- 
- 	ieee80211_freq_to_chan(ssid->vht_center_freq2,
--			       &conf->vht_oper_centr_freq_seg1_idx);
-+			       &freq_seg_idx);
-+	hostapd_set_oper_centr_freq_seg1_idx(conf, freq_seg_idx);
- 
- 	if (!ssid->p2p_group) {
- 		if (!ssid->vht_center_freq1 ||
--		    conf->vht_oper_chwidth == CHANWIDTH_USE_HT)
-+		    hostapd_get_oper_chwidth(conf) == CHANWIDTH_USE_HT)
- 			goto no_vht;
- 		ieee80211_freq_to_chan(ssid->vht_center_freq1,
--				       &conf->vht_oper_centr_freq_seg0_idx);
-+				       &freq_seg_idx);
-+		hostapd_set_oper_centr_freq_seg0_idx(conf, freq_seg_idx);
- 		wpa_printf(MSG_DEBUG, "VHT seg0 index %d for AP",
--			   conf->vht_oper_centr_freq_seg0_idx);
-+			   hostapd_get_oper_centr_freq_seg0_idx(conf));
- 		return;
- 	}
- 
-@@ -96,14 +99,14 @@ static void wpas_conf_ap_vht(struct wpa_
- 		 * try oper_cwidth 160 MHz first then VHT 80 MHz, if 160 MHz is
- 		 * not supported.
- 		 */
--		conf->vht_oper_chwidth = CHANWIDTH_160MHZ;
-+		hostapd_set_oper_chwidth(conf, CHANWIDTH_160MHZ);
- 		center_chan = wpas_p2p_get_vht160_center(wpa_s, mode, channel);
- 		if (center_chan) {
- 			wpa_printf(MSG_DEBUG,
- 				   "VHT center channel %u for auto-selected 160 MHz bandwidth",
- 				   center_chan);
- 		} else {
--			conf->vht_oper_chwidth = CHANWIDTH_80MHZ;
-+			hostapd_set_oper_chwidth(conf, CHANWIDTH_80MHZ);
- 			center_chan = wpas_p2p_get_vht80_center(wpa_s, mode,
- 								channel);
- 			wpa_printf(MSG_DEBUG,
-@@ -115,9 +118,9 @@ static void wpas_conf_ap_vht(struct wpa_
- 	if (!center_chan)
- 		goto no_vht;
- 
--	conf->vht_oper_centr_freq_seg0_idx = center_chan;
-+	hostapd_set_oper_centr_freq_seg0_idx(conf, center_chan);
- 	wpa_printf(MSG_DEBUG, "VHT seg0 index %d for P2P GO",
--		   conf->vht_oper_centr_freq_seg0_idx);
-+		   hostapd_get_oper_centr_freq_seg0_idx(conf));
- 	return;
- #endif /* CONFIG_P2P */
- 
-@@ -125,9 +128,9 @@ no_vht:
- 	wpa_printf(MSG_DEBUG,
- 		   "No VHT higher bandwidth support for the selected channel %d",
- 		   conf->channel);
--	conf->vht_oper_centr_freq_seg0_idx =
--		conf->channel + conf->secondary_channel * 2;
--	conf->vht_oper_chwidth = CHANWIDTH_USE_HT;
-+	hostapd_set_oper_centr_freq_seg0_idx(conf,
-+					     conf->channel + conf->secondary_channel * 2);
-+	hostapd_set_oper_chwidth(conf, CHANWIDTH_USE_HT);
- }
- 
- 
-@@ -231,16 +234,19 @@ int wpa_supplicant_conf_ap_ht(struct wpa
- 				 HT_CAP_INFO_TX_STBC |
- 				 HT_CAP_INFO_MAX_AMSDU_SIZE);
- 
-+			/* check this before VHT, because setting oper chan
-+			 * width and friends is the same call for HE and VHT
-+			 * and checks if conf->ieee8021ax == 1 */
-+			if (mode->he_capab[wpas_mode_to_ieee80211_mode(
-+					    ssid->mode)].he_supported &&
-+			    ssid->he)
-+				conf->ieee80211ax = 1;
-+
- 			if (mode->vht_capab && ssid->vht) {
- 				conf->ieee80211ac = 1;
- 				conf->vht_capab |= mode->vht_capab;
- 				wpas_conf_ap_vht(wpa_s, ssid, conf, mode);
- 			}
--
--			if (mode->he_capab[wpas_mode_to_ieee80211_mode(
--					    ssid->mode)].he_supported &&
--			    ssid->he)
--				conf->ieee80211ax = 1;
- 		}
- 	}
- 
---- a/wpa_supplicant/mesh.c
-+++ b/wpa_supplicant/mesh.c
-@@ -333,30 +333,6 @@ static int wpa_supplicant_mesh_init(stru
- 			   frequency);
- 		goto out_free;
- 	}
--	if (ssid->ht40)
--		conf->secondary_channel = ssid->ht40;
--	if (conf->hw_mode == HOSTAPD_MODE_IEEE80211A && ssid->vht) {
--		if (ssid->max_oper_chwidth != DEFAULT_MAX_OPER_CHWIDTH)
--			conf->vht_oper_chwidth = ssid->max_oper_chwidth;
--		switch (conf->vht_oper_chwidth) {
--		case CHANWIDTH_80MHZ:
--		case CHANWIDTH_80P80MHZ:
--			ieee80211_freq_to_chan(
--				frequency,
--				&conf->vht_oper_centr_freq_seg0_idx);
--			conf->vht_oper_centr_freq_seg0_idx += ssid->ht40 * 2;
--			break;
--		case CHANWIDTH_160MHZ:
--			ieee80211_freq_to_chan(
--				frequency,
--				&conf->vht_oper_centr_freq_seg0_idx);
--			conf->vht_oper_centr_freq_seg0_idx += ssid->ht40 * 2;
--			conf->vht_oper_centr_freq_seg0_idx += 40 / 5;
--			break;
--		}
--		ieee80211_freq_to_chan(ssid->vht_center_freq2,
--				       &conf->vht_oper_centr_freq_seg1_idx);
--	}
- 
- 	if (ssid->mesh_basic_rates == NULL) {
- 		/*
diff --git a/package/network/services/hostapd/patches/002-mesh-fix-channel-init-order-disable-pri-sec-channel-.patch b/package/network/services/hostapd/patches/002-mesh-fix-channel-init-order-disable-pri-sec-channel-.patch
deleted file mode 100644
index c7101b1dbc..0000000000
--- a/package/network/services/hostapd/patches/002-mesh-fix-channel-init-order-disable-pri-sec-channel-.patch
+++ /dev/null
@@ -1,126 +0,0 @@
-From d869c753b79a1423c2bd9b0afdfa0d89d55a930c Mon Sep 17 00:00:00 2001
-From: Markus Theil <markus.theil@tu-ilmenau.de>
-Date: Tue, 30 Jun 2020 13:53:18 +0200
-Subject: [PATCH 02/19] mesh: fix channel init order, disable pri/sec channel
- switch
-
-wpa_supplicant_conf_ap_ht has to happen before hostapd_setup_interface
-in order for its configuration settings to have effect on interface
-configuration.
-
-Disable primary and secondary channel switch because of missing tie
-breaking rule/frames in mesh networks. A rather long comment about
-this issue is placed in mesh.c in the corresponding place.
-
-In consequence, remove mesh coex test, which contradicts this change.
-
-I was not able to reproduce the memory corruption during
-mesh_secure_ocv_mix_legacy, which lead to a revert of a similar patch
-in the past.
-
-Signed-off-by: Markus Theil <markus.theil@tu-ilmenau.de>
----
- tests/hwsim/test_wpas_mesh.py | 50 -----------------------------------
- wpa_supplicant/mesh.c         | 25 ++++++++++++++++--
- 2 files changed, 23 insertions(+), 52 deletions(-)
-
---- a/tests/hwsim/test_wpas_mesh.py
-+++ b/tests/hwsim/test_wpas_mesh.py
-@@ -933,56 +933,6 @@ def _test_wpas_mesh_open_5ghz(dev, apdev
-     dev[0].dump_monitor()
-     dev[1].dump_monitor()
- 
--def test_wpas_mesh_open_5ghz_coex(dev, apdev):
--    """Mesh network on 5 GHz band and 20/40 coex change"""
--    try:
--        _test_wpas_mesh_open_5ghz_coex(dev, apdev)
--    finally:
--        dev[0].request("MESH_GROUP_REMOVE " + dev[0].ifname)
--        dev[1].request("MESH_GROUP_REMOVE " + dev[1].ifname)
--        set_world_reg(apdev0=apdev[0], dev0=dev[0])
--        dev[0].flush_scan_cache()
--        dev[1].flush_scan_cache()
--
--def _test_wpas_mesh_open_5ghz_coex(dev, apdev):
--    check_mesh_support(dev[0])
--    subprocess.call(['iw', 'reg', 'set', 'US'])
--
--    # Start a 20 MHz BSS on channel 40 that would be the secondary channel of
--    # HT40+ mesh on channel 36.
--    params = {"ssid": "test-ht40",
--              "hw_mode": "a",
--              "channel": "40",
--              "country_code": "US"}
--    hapd = hostapd.add_ap(apdev[0], params)
--    bssid = hapd.own_addr()
--
--    for i in range(2):
--        for j in range(5):
--            ev = dev[i].wait_event(["CTRL-EVENT-REGDOM-CHANGE"], timeout=5)
--            if ev is None:
--                raise Exception("No regdom change event")
--            if "alpha2=US" in ev:
--                break
--        dev[i].scan_for_bss(bssid, freq=5200)
--        add_open_mesh_network(dev[i], freq="5180")
--
--    check_mesh_joined_connected(dev)
--
--    freq = dev[0].get_status_field("freq")
--    if freq != "5200":
--        raise Exception("Unexpected STATUS freq=" + freq)
--    sig = dev[0].request("SIGNAL_POLL").splitlines()
--    if "FREQUENCY=5200" not in sig:
--        raise Exception("Unexpected SIGNAL_POLL output: " + str(sig))
--
--    hapd.disable()
--    dev[0].mesh_group_remove()
--    dev[1].mesh_group_remove()
--    check_mesh_group_removed(dev[0])
--    check_mesh_group_removed(dev[1])
--    dev[0].dump_monitor()
--    dev[1].dump_monitor()
- 
- def test_wpas_mesh_open_ht40(dev, apdev):
-     """Mesh and HT40 support difference"""
---- a/wpa_supplicant/mesh.c
-+++ b/wpa_supplicant/mesh.c
-@@ -363,6 +363,29 @@ static int wpa_supplicant_mesh_init(stru
- 		conf->basic_rates[rate_len] = -1;
- 	}
- 
-+	/* While it can enhance performance to switch the primary channel, which
-+	 * is also the secondary channel of another network at the same time),
-+	 * to the other primary channel, problems exist with this in mesh networks.
-+	 *
-+	 * Example with problems:
-+	 *     - 3 mesh nodes M1-M3, freq (5200, 5180)
-+	 *     - other node O1, e.g. AP mode, freq (5180, 5200),
-+	 * Locations: O1 M1      M2      M3
-+	 *
-+	 * M3 can only send frames to M1 over M2, no direct connection is possible
-+	 * Start O1, M1 and M3 first, M1 or O1 will switch channels to align with
-+	 * each other. M3 does not swap, because M1 or O1 cannot be reached.
-+	 * M2 is started afterwards and can either connect to M3 or M1 because of
-+	 * this primary secondary channel switch.
-+	 *
-+	 * Solutions: (1) central coordination -> not always possible
-+	 *            (2) disable pri/sec channel switch in mesh networks
-+	 *
-+	 * In AP mode, when all nodes can work independently, this poses of course
-+	 * no problem, therefore disable it only in mesh mode.`*/
-+	conf->no_pri_sec_switch = 1;
-+	wpa_supplicant_conf_ap_ht(wpa_s, ssid, conf);
-+
- 	if (wpa_drv_init_mesh(wpa_s)) {
- 		wpa_msg(wpa_s, MSG_ERROR, "Failed to init mesh in driver");
- 		return -1;
-@@ -374,8 +397,6 @@ static int wpa_supplicant_mesh_init(stru
- 		return -1;
- 	}
- 
--	wpa_supplicant_conf_ap_ht(wpa_s, ssid, conf);
--
- 	return 0;
- out_free:
- 	wpa_supplicant_mesh_deinit(wpa_s);
diff --git a/package/network/services/hostapd/patches/003-wpa_supplicant-handle-HT40-and-mode-downgrade-in-AP-.patch b/package/network/services/hostapd/patches/003-wpa_supplicant-handle-HT40-and-mode-downgrade-in-AP-.patch
deleted file mode 100644
index f42620042d..0000000000
--- a/package/network/services/hostapd/patches/003-wpa_supplicant-handle-HT40-and-mode-downgrade-in-AP-.patch
+++ /dev/null
@@ -1,102 +0,0 @@
-From 978a59514ccde994b5c06e1cbb49cc8cebe6381c Mon Sep 17 00:00:00 2001
-From: Markus Theil <markus.theil@tu-ilmenau.de>
-Date: Tue, 30 Jun 2020 13:53:19 +0200
-Subject: [PATCH 03/19] wpa_supplicant: handle HT40 and mode downgrade in AP
- mode
-
-This patch adds some missing pieces to the interface configuration
-of AP/mesh mode in wpa_supplicant.
- - check for secondary channel and HT40 capability
- - try to downgrade to 11b if 11g is not available
-Especially with the HT40 check, this code now performs all settings,
-which the deleted/duplicated mesh code did.
-
-Signed-off-by: Markus Theil <markus.theil@tu-ilmenau.de>
----
- wpa_supplicant/ap.c | 49 ++++++++++++++++++++++++++++++++++++---------
- 1 file changed, 40 insertions(+), 9 deletions(-)
-
---- a/wpa_supplicant/ap.c
-+++ b/wpa_supplicant/ap.c
-@@ -134,6 +134,23 @@ no_vht:
- }
- 
- 
-+static struct hostapd_hw_modes *wpa_supplicant_find_hw_mode(struct wpa_supplicant *wpa_s,
-+							    enum hostapd_hw_mode hw_mode)
-+{
-+	struct hostapd_hw_modes *mode = NULL;
-+	int i;
-+
-+	for (i = 0; i < wpa_s->hw.num_modes; i++) {
-+		if (wpa_s->hw.modes[i].mode == hw_mode) {
-+			mode = &wpa_s->hw.modes[i];
-+			break;
-+		}
-+	}
-+
-+	return mode;
-+}
-+
-+
- int wpa_supplicant_conf_ap_ht(struct wpa_supplicant *wpa_s,
- 			      struct wpa_ssid *ssid,
- 			      struct hostapd_config *conf)
-@@ -147,9 +164,6 @@ int wpa_supplicant_conf_ap_ht(struct wpa
- 		return -1;
- 	}
- 
--	/* TODO: enable HT40 if driver supports it;
--	 * drop to 11b if driver does not support 11g */
--
- 	/*
- 	 * Enable HT20 if the driver supports it, by setting conf->ieee80211n
- 	 * and a mask of allowed capabilities within conf->ht_capab.
-@@ -158,17 +172,27 @@ int wpa_supplicant_conf_ap_ht(struct wpa
- 	 */
- 	if (wpa_s->hw.modes) {
- 		struct hostapd_hw_modes *mode = NULL;
--		int i, no_ht = 0;
-+		int no_ht = 0;
- 
- 		wpa_printf(MSG_DEBUG,
- 			   "Determining HT/VHT options based on driver capabilities (freq=%u chan=%u)",
- 			   ssid->frequency, conf->channel);
- 
--		for (i = 0; i < wpa_s->hw.num_modes; i++) {
--			if (wpa_s->hw.modes[i].mode == conf->hw_mode) {
--				mode = &wpa_s->hw.modes[i];
--				break;
--			}
-+		mode = wpa_supplicant_find_hw_mode(wpa_s, conf->hw_mode);
-+
-+		/* may drop drop to 11b if driver does not support 11g */
-+		if (!mode && conf->hw_mode == HOSTAPD_MODE_IEEE80211G) {
-+			conf->hw_mode = HOSTAPD_MODE_IEEE80211B;
-+			wpa_printf(MSG_INFO,
-+			   "Try downgrade to IEEE 802.11b as 802.11g is not "
-+			   "supported by the current hardware");
-+			mode = wpa_supplicant_find_hw_mode(wpa_s, conf->hw_mode);
-+		}
-+
-+		if (!mode) {
-+			wpa_printf(MSG_ERROR,
-+			   "No match between requested and supported hw modes found");
-+			return -1;
- 		}
- 
- #ifdef CONFIG_HT_OVERRIDES
-@@ -193,6 +217,13 @@ int wpa_supplicant_conf_ap_ht(struct wpa
- 				      HT_CAP_INFO_SUPP_CHANNEL_WIDTH_SET),
- 				   ssid->ht40);
- 			conf->ieee80211n = 1;
-+
-+			if (ssid->ht40 &&
-+			    mode->ht_capab & HT_CAP_INFO_SUPP_CHANNEL_WIDTH_SET)
-+				conf->secondary_channel = ssid->ht40;
-+			else
-+				conf->secondary_channel = 0;
-+
- #ifdef CONFIG_P2P
- 			if (ssid->p2p_group &&
- 			    conf->hw_mode == HOSTAPD_MODE_IEEE80211A &&
diff --git a/package/network/services/hostapd/patches/004-wpa_supplicant-fix-frequency-config-for-non-p2p-vht-.patch b/package/network/services/hostapd/patches/004-wpa_supplicant-fix-frequency-config-for-non-p2p-vht-.patch
deleted file mode 100644
index e8682af644..0000000000
--- a/package/network/services/hostapd/patches/004-wpa_supplicant-fix-frequency-config-for-non-p2p-vht-.patch
+++ /dev/null
@@ -1,63 +0,0 @@
-From 7f7325dae1d03a3964d4e91940d8369f3fed7b43 Mon Sep 17 00:00:00 2001
-From: Markus Theil <markus.theil@tu-ilmenau.de>
-Date: Tue, 30 Jun 2020 13:53:20 +0200
-Subject: [PATCH 04/19] wpa_supplicant: fix frequency config for non p2p vht/he
- cases
-
-Fix compile without CONFIG_P2P and only set secondary channel seg idx
-if we use a mode supporting a sec channel for vht/he.
-
-Signed-off-by: Markus Theil <markus.theil@tu-ilmenau.de>
----
- wpa_supplicant/ap.c | 23 +++++++++++++----------
- 1 file changed, 13 insertions(+), 10 deletions(-)
-
---- a/wpa_supplicant/ap.c
-+++ b/wpa_supplicant/ap.c
-@@ -52,8 +52,8 @@ static void wpas_conf_ap_vht(struct wpa_
- #ifdef CONFIG_P2P
- 	u8 center_chan = 0;
- 	u8 channel = conf->channel;
--	u8 freq_seg_idx;
- #endif /* CONFIG_P2P */
-+	u8 freq_seg_idx;
- 
- 	if (!conf->secondary_channel)
- 		goto no_vht;
-@@ -62,24 +62,27 @@ static void wpas_conf_ap_vht(struct wpa_
- 	if (ssid->max_oper_chwidth)
- 		hostapd_set_oper_chwidth(conf, ssid->max_oper_chwidth);
- 
--	ieee80211_freq_to_chan(ssid->vht_center_freq2,
--			       &freq_seg_idx);
--	hostapd_set_oper_centr_freq_seg1_idx(conf, freq_seg_idx);
--
- 	if (!ssid->p2p_group) {
--		if (!ssid->vht_center_freq1 ||
--		    hostapd_get_oper_chwidth(conf) == CHANWIDTH_USE_HT)
-+		if (!ssid->vht_center_freq1)
- 			goto no_vht;
- 		ieee80211_freq_to_chan(ssid->vht_center_freq1,
- 				       &freq_seg_idx);
- 		hostapd_set_oper_centr_freq_seg0_idx(conf, freq_seg_idx);
--		wpa_printf(MSG_DEBUG, "VHT seg0 index %d for AP",
--			   hostapd_get_oper_centr_freq_seg0_idx(conf));
-+
-+		if (hostapd_get_oper_chwidth(conf) == CHANWIDTH_80P80MHZ) {
-+			ieee80211_freq_to_chan(ssid->vht_center_freq2,
-+					       &freq_seg_idx);
-+			hostapd_set_oper_centr_freq_seg1_idx(conf, freq_seg_idx);
-+		}
-+
-+		wpa_printf(MSG_DEBUG, "VHT seg0 index %d and seg1 index %d for AP",
-+			   hostapd_get_oper_centr_freq_seg0_idx(conf),
-+			   hostapd_get_oper_centr_freq_seg1_idx(conf));
- 		return;
- 	}
- 
- #ifdef CONFIG_P2P
--	switch (conf->vht_oper_chwidth) {
-+	switch (hostapd_get_oper_chwidth(conf)) {
- 	case CHANWIDTH_80MHZ:
- 	case CHANWIDTH_80P80MHZ:
- 		center_chan = wpas_p2p_get_vht80_center(wpa_s, mode, channel);
diff --git a/package/network/services/hostapd/patches/005-wpa_supplicant-enable-vht-and-he-in-default-config-p.patch b/package/network/services/hostapd/patches/005-wpa_supplicant-enable-vht-and-he-in-default-config-p.patch
deleted file mode 100644
index 25d74252cd..0000000000
--- a/package/network/services/hostapd/patches/005-wpa_supplicant-enable-vht-and-he-in-default-config-p.patch
+++ /dev/null
@@ -1,25 +0,0 @@
-From ff7fb3fa0831c8521327d777c5607a3b7d8736b8 Mon Sep 17 00:00:00 2001
-From: Markus Theil <markus.theil@tu-ilmenau.de>
-Date: Tue, 30 Jun 2020 13:53:21 +0200
-Subject: [PATCH 05/19] wpa_supplicant: enable vht and he in default config
- parameters
-
-Enable VHT and HE as default config parameters in order for
-wpa_supplicant AP mode to use it, if hw support is given.
-
-Signed-off-by: Markus Theil <markus.theil@tu-ilmenau.de>
----
- wpa_supplicant/config.c | 2 ++
- 1 file changed, 2 insertions(+)
-
---- a/wpa_supplicant/config.c
-+++ b/wpa_supplicant/config.c
-@@ -3036,6 +3036,8 @@ void wpa_config_set_network_defaults(str
- 	ssid->wpa_deny_ptk0_rekey = PTK0_REKEY_ALLOW_ALWAYS;
- 	ssid->bg_scan_period = DEFAULT_BG_SCAN_PERIOD;
- 	ssid->ht = 1;
-+	ssid->vht = 1;
-+	ssid->he = 1;
- #ifdef IEEE8021X_EAPOL
- 	ssid->eapol_flags = DEFAULT_EAPOL_FLAGS;
- 	ssid->eap_workaround = DEFAULT_EAP_WORKAROUND;
diff --git a/package/network/services/hostapd/patches/006-hw_features-better-debug-messages-for-some-error-cas.patch b/package/network/services/hostapd/patches/006-hw_features-better-debug-messages-for-some-error-cas.patch
deleted file mode 100644
index 31b1ac0d38..0000000000
--- a/package/network/services/hostapd/patches/006-hw_features-better-debug-messages-for-some-error-cas.patch
+++ /dev/null
@@ -1,83 +0,0 @@
-From 6522dcbbcf71abcb80cce84b93b4a9a5cfcd4fca Mon Sep 17 00:00:00 2001
-From: Markus Theil <markus.theil@tu-ilmenau.de>
-Date: Tue, 30 Jun 2020 13:53:22 +0200
-Subject: [PATCH 06/19] hw_features: better debug messages for some error cases
-
-Signed-off-by: Markus Theil <markus.theil@tu-ilmenau.de>
----
- src/common/hw_features_common.c | 29 ++++++++++++++++++++++-------
- 1 file changed, 22 insertions(+), 7 deletions(-)
-
---- a/src/common/hw_features_common.c
-+++ b/src/common/hw_features_common.c
-@@ -540,13 +540,18 @@ int hostapd_set_freq_params(struct hosta
- 		if (center_segment1 ||
- 		    (center_segment0 != 0 &&
- 		     5000 + center_segment0 * 5 != data->center_freq1 &&
--		     2407 + center_segment0 * 5 != data->center_freq1))
-+		     2407 + center_segment0 * 5 != data->center_freq1)) {
-+			wpa_printf(MSG_ERROR, "20/40 MHz: center segment 0 (=%i) and center freq 1 (=%i) not in sync",
-+				   center_segment0, data->center_freq1);
- 			return -1;
-+		}
- 		break;
- 	case CHANWIDTH_80P80MHZ:
- 		if (center_segment1 == center_segment0 + 4 ||
--		    center_segment1 == center_segment0 - 4)
-+		    center_segment1 == center_segment0 - 4) {
-+			wpa_printf(MSG_ERROR, "80+80 MHz: center segment 1 only 20 MHz apart");
- 			return -1;
-+		}
- 		data->center_freq2 = 5000 + center_segment1 * 5;
- 		/* fall through */
- 	case CHANWIDTH_80MHZ:
-@@ -555,8 +560,10 @@ int hostapd_set_freq_params(struct hosta
- 		     center_segment1) ||
- 		    (oper_chwidth == CHANWIDTH_80P80MHZ &&
- 		     !center_segment1) ||
--		    !sec_channel_offset)
-+		    !sec_channel_offset) {
-+			wpa_printf(MSG_ERROR, "80/80+80 MHz: center segment 1 wrong or no second channel offset");
- 			return -1;
-+		}
- 		if (!center_segment0) {
- 			if (channel <= 48)
- 				center_segment0 = 42;
-@@ -582,16 +589,22 @@ int hostapd_set_freq_params(struct hosta
- 			    center_segment0 == channel - 2 ||
- 			    center_segment0 == channel - 6)
- 				data->center_freq1 = 5000 + center_segment0 * 5;
--			else
-+			else {
-+				wpa_printf(MSG_ERROR, "Wrong coupling between HT and VHT/HE channel setting");
- 				return -1;
-+			}
- 		}
- 		break;
- 	case CHANWIDTH_160MHZ:
- 		data->bandwidth = 160;
--		if (center_segment1)
-+		if (center_segment1) {
-+			wpa_printf(MSG_ERROR, "160 MHz: center segment 1 should not be set");
- 			return -1;
--		if (!sec_channel_offset)
-+		}
-+		if (!sec_channel_offset) {
-+			wpa_printf(MSG_ERROR, "160 MHz: second channel offset not set");
- 			return -1;
-+		}
- 		/*
- 		 * Note: HT/VHT config and params are coupled. Check if
- 		 * HT40 channel band is in VHT160 channel band configuration.
-@@ -605,8 +618,10 @@ int hostapd_set_freq_params(struct hosta
- 		    center_segment0 == channel - 10 ||
- 		    center_segment0 == channel - 14)
- 			data->center_freq1 = 5000 + center_segment0 * 5;
--		else
-+		else {
-+			wpa_printf(MSG_ERROR, "160 MHz: HT40 channel band is not in 160 MHz band");
- 			return -1;
-+		}
- 		break;
- 	}
- 
diff --git a/package/network/services/hostapd/patches/007-dfs-use-helper-functions-for-vht-he-parameters.patch b/package/network/services/hostapd/patches/007-dfs-use-helper-functions-for-vht-he-parameters.patch
deleted file mode 100644
index 3481c52eef..0000000000
--- a/package/network/services/hostapd/patches/007-dfs-use-helper-functions-for-vht-he-parameters.patch
+++ /dev/null
@@ -1,27 +0,0 @@
-From 6eacc14904b6f09a1490e697c01adf5dc56c4905 Mon Sep 17 00:00:00 2001
-From: Markus Theil <markus.theil@tu-ilmenau.de>
-Date: Tue, 30 Jun 2020 13:53:23 +0200
-Subject: [PATCH 07/19] dfs: use helper functions for vht/he parameters
-
-Signed-off-by: Markus Theil <markus.theil@tu-ilmenau.de>
----
- src/ap/dfs.c | 6 ++++--
- 1 file changed, 4 insertions(+), 2 deletions(-)
-
---- a/src/ap/dfs.c
-+++ b/src/ap/dfs.c
-@@ -955,10 +955,12 @@ dfs_downgrade_bandwidth(struct hostapd_i
- 		if (*skip_radar) {
- 			*skip_radar = 0;
- 		} else {
--			if (iface->conf->vht_oper_chwidth == CHANWIDTH_USE_HT)
-+			int oper_chwidth = hostapd_get_oper_chwidth(iface->conf);
-+
-+			if (oper_chwidth == CHANWIDTH_USE_HT)
- 				break;
- 			*skip_radar = 1;
--			iface->conf->vht_oper_chwidth--;
-+			hostapd_set_oper_chwidth(iface->conf, oper_chwidth - 1);
- 		}
- 	}
- 
diff --git a/package/network/services/hostapd/patches/008-mesh-use-setup-completion-callback-to-complete-mesh-.patch b/package/network/services/hostapd/patches/008-mesh-use-setup-completion-callback-to-complete-mesh-.patch
deleted file mode 100644
index 28c283d035..0000000000
--- a/package/network/services/hostapd/patches/008-mesh-use-setup-completion-callback-to-complete-mesh-.patch
+++ /dev/null
@@ -1,108 +0,0 @@
-From 11e5bbe58eebdb10793eec374b6c8ccc7daf7ec8 Mon Sep 17 00:00:00 2001
-From: Peter Oh <peter.oh@bowerswilkins.com>
-Date: Tue, 30 Jun 2020 14:18:56 +0200
-Subject: [PATCH 08/19] mesh: use setup completion callback to complete mesh
- join
-
-mesh join function is the last function to be called during
-mesh join process, but it's been called a bit earlier than
-it's supposed to be, so that some mesh parameter values
-such as VHT capabilities not applied correct when mesh join
-is in process.
-Moreover current design of mesh join that is called directly
-after mesh initialization isn't suitable for DFS channels to use,
-since mesh join process should be paused until DFS CAC is
-done and resumed after it's done.
-The callback will be called by hostapd_setup_interface_complete_sync.
-There is possiblity that completing mesh init fails, so add error
-handle codes.
-
-Signed-off-by: Peter Oh <peter.oh@bowerswilkins.com>
----
- src/ap/hostapd.c      | 11 ++++++++++-
- wpa_supplicant/mesh.c | 12 ++++++++++--
- 2 files changed, 20 insertions(+), 3 deletions(-)
-
---- a/src/ap/hostapd.c
-+++ b/src/ap/hostapd.c
-@@ -434,6 +434,8 @@ static void hostapd_free_hapd_data(struc
- #ifdef CONFIG_MESH
- 	wpabuf_free(hapd->mesh_pending_auth);
- 	hapd->mesh_pending_auth = NULL;
-+	/* handling setup failure is already done */
-+	hapd->setup_complete_cb = NULL;
- #endif /* CONFIG_MESH */
- 
- 	hostapd_clean_rrm(hapd);
-@@ -2156,6 +2158,13 @@ dfs_offload:
- 	if (hapd->setup_complete_cb)
- 		hapd->setup_complete_cb(hapd->setup_complete_cb_ctx);
- 
-+#ifdef CONFIG_MESH
-+	if (delay_apply_cfg && iface->mconf == NULL) {
-+		wpa_printf(MSG_ERROR, "Error while completing mesh init");
-+		goto fail;
-+	}
-+#endif /* CONFIG_MESH */
-+
- 	wpa_printf(MSG_DEBUG, "%s: Setup of interface done.",
- 		   iface->bss[0]->conf->iface);
- 	if (iface->interfaces && iface->interfaces->terminate_on_error > 0)
-@@ -2299,7 +2308,7 @@ int hostapd_setup_interface(struct hosta
- 	ret = setup_interface(iface);
- 	if (ret) {
- 		wpa_printf(MSG_ERROR, "%s: Unable to setup interface.",
--			   iface->bss[0]->conf->iface);
-+			iface->conf ? iface->conf->bss[0]->iface : "N/A");
- 		return -1;
- 	}
- 
---- a/wpa_supplicant/mesh.c
-+++ b/wpa_supplicant/mesh.c
-@@ -193,7 +193,6 @@ static int wpas_mesh_init_rsn(struct wpa
- 	return !wpa_s->mesh_rsn ? -1 : 0;
- }
- 
--
- static int wpas_mesh_complete(struct wpa_supplicant *wpa_s)
- {
- 	struct hostapd_iface *ifmsh = wpa_s->ifmsh;
-@@ -244,6 +243,13 @@ static int wpas_mesh_complete(struct wpa
- }
- 
- 
-+static void wpas_mesh_complete_cb(void *arg)
-+{
-+	struct wpa_supplicant *wpa_s = arg;
-+	wpas_mesh_complete(wpa_s);
-+}
-+
-+
- static int wpa_supplicant_mesh_init(struct wpa_supplicant *wpa_s,
- 				    struct wpa_ssid *ssid,
- 				    struct hostapd_freq_params *freq)
-@@ -267,6 +273,7 @@ static int wpa_supplicant_mesh_init(stru
- 	if (!ifmsh)
- 		return -ENOMEM;
- 
-+	ifmsh->owner = wpa_s;
- 	ifmsh->drv_flags = wpa_s->drv_flags;
- 	ifmsh->drv_flags2 = wpa_s->drv_flags2;
- 	ifmsh->num_bss = 1;
-@@ -285,6 +292,8 @@ static int wpa_supplicant_mesh_init(stru
- 	bss->drv_priv = wpa_s->drv_priv;
- 	bss->iface = ifmsh;
- 	bss->mesh_sta_free_cb = mesh_mpm_free_sta;
-+	bss->setup_complete_cb = wpas_mesh_complete_cb;
-+	bss->setup_complete_cb_ctx = wpa_s;
- 	frequency = ssid->frequency;
- 	if (frequency != freq->freq &&
- 	    frequency == freq->freq + freq->sec_channel_offset * 20) {
-@@ -523,7 +532,6 @@ int wpa_supplicant_join_mesh(struct wpa_
- 		goto out;
- 	}
- 
--	ret = wpas_mesh_complete(wpa_s);
- out:
- 	return ret;
- }
diff --git a/package/network/services/hostapd/patches/009-mesh-update-ssid-frequency-as-pri-sec-channel-switch.patch b/package/network/services/hostapd/patches/009-mesh-update-ssid-frequency-as-pri-sec-channel-switch.patch
deleted file mode 100644
index b48de67636..0000000000
--- a/package/network/services/hostapd/patches/009-mesh-update-ssid-frequency-as-pri-sec-channel-switch.patch
+++ /dev/null
@@ -1,26 +0,0 @@
-From 87c5e8883898e7eb8e9637e212350c1925a22654 Mon Sep 17 00:00:00 2001
-From: Peter Oh <peter.oh@bowerswilkins.com>
-Date: Tue, 30 Jun 2020 14:18:57 +0200
-Subject: [PATCH 09/19] mesh: update ssid->frequency as pri/sec channel switch
-
-ssid->frequency is one of variables used to gets channel
-number from given frequency. Leave it as unchanged when
-pri/sec channel switched will cause picking up wrong
-channel number after applying secondary channel offset
-for HT40 and leads failing interface bring-up.
-
-Signed-off-by: Peter Oh <peter.oh@bowerswilkins.com>
----
- wpa_supplicant/mesh.c | 1 +
- 1 file changed, 1 insertion(+)
-
---- a/wpa_supplicant/mesh.c
-+++ b/wpa_supplicant/mesh.c
-@@ -299,6 +299,7 @@ static int wpa_supplicant_mesh_init(stru
- 	    frequency == freq->freq + freq->sec_channel_offset * 20) {
- 		wpa_printf(MSG_DEBUG, "mesh: pri/sec channels switched");
- 		frequency = freq->freq;
-+		ssid->frequency = frequency;
- 	}
- 	wpa_s->assoc_freq = frequency;
- 	wpa_s->current_ssid = ssid;
diff --git a/package/network/services/hostapd/patches/010-mesh-Allow-DFS-channels-to-be-selected-if-dfs-is-ena.patch b/package/network/services/hostapd/patches/010-mesh-Allow-DFS-channels-to-be-selected-if-dfs-is-ena.patch
deleted file mode 100644
index 8afeba93ed..0000000000
--- a/package/network/services/hostapd/patches/010-mesh-Allow-DFS-channels-to-be-selected-if-dfs-is-ena.patch
+++ /dev/null
@@ -1,80 +0,0 @@
-From 8de8cd8380af0c43d4fde67a668d79ef73b26b26 Mon Sep 17 00:00:00 2001
-From: Peter Oh <peter.oh@bowerswilkins.com>
-Date: Tue, 30 Jun 2020 14:18:58 +0200
-Subject: [PATCH 10/19] mesh: Allow DFS channels to be selected if dfs is
- enabled
-
-Note: DFS is assumed to be usable if a country code has been set
-
-Signed-off-by: Benjamin Berg <benjamin@sipsolutions.net>
-Signed-off-by: Peter Oh <peter.oh@bowerswilkins.com>
----
- wpa_supplicant/wpa_supplicant.c | 25 +++++++++++++++++++------
- 1 file changed, 19 insertions(+), 6 deletions(-)
-
---- a/wpa_supplicant/wpa_supplicant.c
-+++ b/wpa_supplicant/wpa_supplicant.c
-@@ -2349,6 +2349,8 @@ void ibss_mesh_setup_freq(struct wpa_sup
- 	int chwidth, seg0, seg1;
- 	u32 vht_caps = 0;
- 	int is_24ghz;
-+	int dfs_enabled = wpa_s->conf->country[0] &&
-+			 (wpa_s->drv_flags & WPA_DRIVER_FLAGS_RADAR);
- 
- 	freq->freq = ssid->frequency;
- 
-@@ -2436,8 +2438,11 @@ void ibss_mesh_setup_freq(struct wpa_sup
- 		return;
- 
- 	/* Check primary channel flags */
--	if (pri_chan->flag & (HOSTAPD_CHAN_DISABLED | HOSTAPD_CHAN_NO_IR))
-+	if (pri_chan->flag & HOSTAPD_CHAN_DISABLED)
- 		return;
-+	if (pri_chan->flag & (HOSTAPD_CHAN_RADAR | HOSTAPD_CHAN_NO_IR))
-+		if (!dfs_enabled)
-+			return;
- 
- 	freq->channel = pri_chan->chan;
- 
-@@ -2470,8 +2475,11 @@ void ibss_mesh_setup_freq(struct wpa_sup
- 		return;
- 
- 	/* Check secondary channel flags */
--	if (sec_chan->flag & (HOSTAPD_CHAN_DISABLED | HOSTAPD_CHAN_NO_IR))
-+	if (sec_chan->flag & HOSTAPD_CHAN_DISABLED)
- 		return;
-+	if (sec_chan->flag & (HOSTAPD_CHAN_RADAR | HOSTAPD_CHAN_NO_IR))
-+		if (!dfs_enabled)
-+			return;
- 
- 	if (ht40 == -1) {
- 		if (!(pri_chan->flag & HOSTAPD_CHAN_HT40MINUS))
-@@ -2564,8 +2572,11 @@ skip_ht40:
- 			return;
- 
- 		/* Back to HT configuration if channel not usable */
--		if (chan->flag & (HOSTAPD_CHAN_DISABLED | HOSTAPD_CHAN_NO_IR))
-+		if (chan->flag & HOSTAPD_CHAN_DISABLED)
- 			return;
-+		if (chan->flag & (HOSTAPD_CHAN_RADAR | HOSTAPD_CHAN_NO_IR))
-+			if (!dfs_enabled)
-+				return;
- 	}
- 
- 	chwidth = CHANWIDTH_80MHZ;
-@@ -2585,10 +2596,12 @@ skip_ht40:
- 				if (!chan)
- 					continue;
- 
--				if (chan->flag & (HOSTAPD_CHAN_DISABLED |
--						  HOSTAPD_CHAN_NO_IR |
--						  HOSTAPD_CHAN_RADAR))
-+				if (chan->flag & HOSTAPD_CHAN_DISABLED)
- 					continue;
-+				if (chan->flag & (HOSTAPD_CHAN_RADAR |
-+						  HOSTAPD_CHAN_NO_IR))
-+					if (!dfs_enabled)
-+						continue;
- 
- 				/* Found a suitable second segment for 80+80 */
- 				chwidth = CHANWIDTH_80P80MHZ;
diff --git a/package/network/services/hostapd/patches/011-mesh-do-not-set-offchanok-on-DFS-channels-in-non-ETS.patch b/package/network/services/hostapd/patches/011-mesh-do-not-set-offchanok-on-DFS-channels-in-non-ETS.patch
deleted file mode 100644
index d491f7c4bc..0000000000
--- a/package/network/services/hostapd/patches/011-mesh-do-not-set-offchanok-on-DFS-channels-in-non-ETS.patch
+++ /dev/null
@@ -1,53 +0,0 @@
-From af8dcbc87466ed6472850a4f1cfe252652cb3d26 Mon Sep 17 00:00:00 2001
-From: Peter Oh <peter.oh@bowerswilkins.com>
-Date: Tue, 30 Jun 2020 14:18:59 +0200
-Subject: [PATCH 11/19] mesh: do not set offchanok on DFS channels in non-ETSI
-
-mac80211 does not allow mgmt tx to use off channel on
-DFS channels in non-ETSI domain, because it will invalidate
-CAC result on current operating channel.
-(mac80211 commit: 34373d12f3cbb74960a73431138ef619d857996f)
-Hence don't set offchanok for mgmt tx in case of DFS channels
-in non-ETSI.
-
-Signed-off-by: Peter Oh <peter.oh@bowerswilkins.com>
----
- src/drivers/driver_nl80211.c | 19 +++++++++++++++++++
- 1 file changed, 19 insertions(+)
-
---- a/src/drivers/driver_nl80211.c
-+++ b/src/drivers/driver_nl80211.c
-@@ -7788,7 +7788,11 @@ static int wpa_driver_nl80211_send_actio
- 	int ret = -1;
- 	u8 *buf;
- 	struct ieee80211_hdr *hdr;
-+	struct hostapd_hw_modes *modes;
- 	int offchanok = 1;
-+	u16 num_modes, flags;
-+	u8 dfs_domain;
-+	int i;
- 
- 	if (is_ap_interface(drv->nlmode) && (int) freq == bss->freq &&
- 	    bss->beacon_set)
-@@ -7817,6 +7821,21 @@ static int wpa_driver_nl80211_send_actio
- 		os_memset(bss->rand_addr, 0, ETH_ALEN);
- 	}
- 
-+	if (is_mesh_interface(drv->nlmode)) {
-+		modes = nl80211_get_hw_feature_data(bss, &num_modes,
-+						    &flags, &dfs_domain);
-+		if (dfs_domain != HOSTAPD_DFS_REGION_ETSI &&
-+		    ieee80211_is_dfs(bss->freq, modes, num_modes))
-+			offchanok = 0;
-+		if (modes) {
-+			for (i = 0; i < num_modes; i++) {
-+				os_free(modes[i].channels);
-+				os_free(modes[i].rates);
-+			}
-+			os_free(modes);
-+		}
-+	}
-+
- 	if (is_ap_interface(drv->nlmode) &&
- 	    (!(drv->capa.flags & WPA_DRIVER_FLAGS_OFFCHANNEL_TX) ||
- 	     (int) freq == bss->freq || drv->device_ap_sme ||
diff --git a/package/network/services/hostapd/patches/012-mesh-fix-channel-switch-error-during-CAC.patch b/package/network/services/hostapd/patches/012-mesh-fix-channel-switch-error-during-CAC.patch
deleted file mode 100644
index f324d81ae3..0000000000
--- a/package/network/services/hostapd/patches/012-mesh-fix-channel-switch-error-during-CAC.patch
+++ /dev/null
@@ -1,66 +0,0 @@
-From ab6995f15aae17af93507dd2344615f91672a31a Mon Sep 17 00:00:00 2001
-From: Peter Oh <peter.oh@bowerswilkins.com>
-Date: Tue, 30 Jun 2020 14:19:00 +0200
-Subject: [PATCH 12/19] mesh: fix channel switch error during CAC
-
-Mesh interface has used its channel parameters that configured
-during its initialization even after channel switched due to
-DFS radar detection during CAC which caused channel switch error.
-This change fixes the error by updating its channel parameters
-when channel's been changed from initial one.
-
-Signed-off-by: Peter Oh <peter.oh@bowerswilkins.com>
----
- wpa_supplicant/mesh.c | 34 ++++++++++++++++++++++++++++++++++
- 1 file changed, 34 insertions(+)
-
---- a/wpa_supplicant/mesh.c
-+++ b/wpa_supplicant/mesh.c
-@@ -13,6 +13,7 @@
- #include "utils/uuid.h"
- #include "common/ieee802_11_defs.h"
- #include "common/wpa_ctrl.h"
-+#include "common/hw_features_common.h"
- #include "ap/sta_info.h"
- #include "ap/hostapd.h"
- #include "ap/ieee802_11.h"
-@@ -206,6 +207,39 @@ static int wpas_mesh_complete(struct wpa
- 		return -1;
- 	}
- 
-+	/*
-+	 * inspect if channel's been changed since initialized.
-+	 * i.e. DFS radar detection
-+	 */
-+	if (ifmsh->freq != params->freq.freq) {
-+		wpa_s->assoc_freq = ifmsh->freq;
-+		ssid->frequency = ifmsh->freq;
-+		struct he_capabilities *he_capab = NULL;
-+
-+		if (ifmsh->current_mode)
-+			he_capab = &ifmsh->current_mode->he_capab[IEEE80211_MODE_MESH];
-+
-+		if (hostapd_set_freq_params(&params->freq,
-+				ifmsh->conf->hw_mode,
-+				ifmsh->freq,
-+				ifmsh->conf->channel,
-+				ifmsh->conf->enable_edmg,
-+				ifmsh->conf->edmg_channel,
-+				ifmsh->conf->ieee80211n,
-+				ifmsh->conf->ieee80211ac,
-+				ifmsh->conf->ieee80211ax,
-+				ifmsh->conf->secondary_channel,
-+				hostapd_get_oper_chwidth(ifmsh->conf),
-+				hostapd_get_oper_centr_freq_seg0_idx(ifmsh->conf),
-+				hostapd_get_oper_centr_freq_seg1_idx(ifmsh->conf),
-+				ifmsh->conf->vht_capab,
-+				he_capab)) {
-+			wpa_printf(MSG_ERROR, "Error updating mesh frequency params.");
-+			wpa_supplicant_mesh_deinit(wpa_s);
-+			return -1;
-+		}
-+	}
-+
- 	if (ifmsh->mconf->security != MESH_CONF_SEC_NONE &&
- 	    wpas_mesh_init_rsn(wpa_s)) {
- 		wpa_printf(MSG_ERROR,
diff --git a/package/network/services/hostapd/patches/013-mesh-inform-kernel-driver-DFS-handler-in-userspace.patch b/package/network/services/hostapd/patches/013-mesh-inform-kernel-driver-DFS-handler-in-userspace.patch
deleted file mode 100644
index fb4e68636e..0000000000
--- a/package/network/services/hostapd/patches/013-mesh-inform-kernel-driver-DFS-handler-in-userspace.patch
+++ /dev/null
@@ -1,48 +0,0 @@
-From f1118eca5b1a63a4acb2a11ceea15dc4bc259c77 Mon Sep 17 00:00:00 2001
-From: Peter Oh <peter.oh@bowerswilkins.com>
-Date: Tue, 30 Jun 2020 14:19:01 +0200
-Subject: [PATCH 13/19] mesh: inform kernel driver DFS handler in userspace
-
-NL80211_ATTR_HANDLE_DFS is required by kerenel space
-to enable DFS channels that indicates DFS handler
-resides in userspace.
-
-Signed-off-by: Peter Oh <peter.oh@bowerswilkins.com>
----
- src/drivers/driver.h         | 1 +
- src/drivers/driver_nl80211.c | 3 +++
- wpa_supplicant/mesh.c        | 1 +
- 3 files changed, 5 insertions(+)
-
---- a/src/drivers/driver.h
-+++ b/src/drivers/driver.h
-@@ -1542,6 +1542,7 @@ struct wpa_driver_mesh_join_params {
- #define WPA_DRIVER_MESH_FLAG_SAE_AUTH	0x00000004
- #define WPA_DRIVER_MESH_FLAG_AMPE	0x00000008
- 	unsigned int flags;
-+	u8 handle_dfs;
- };
- 
- struct wpa_driver_set_key_params {
---- a/src/drivers/driver_nl80211.c
-+++ b/src/drivers/driver_nl80211.c
-@@ -10070,6 +10070,9 @@ static int nl80211_join_mesh(struct i802
- 
- 	wpa_printf(MSG_DEBUG, "  * flags=%08X", params->flags);
- 
-+	if (params->handle_dfs)
-+		if (nla_put_flag(msg, NL80211_ATTR_HANDLE_DFS))
-+			goto fail;
- 	container = nla_nest_start(msg, NL80211_ATTR_MESH_SETUP);
- 	if (!container)
- 		goto fail;
---- a/wpa_supplicant/mesh.c
-+++ b/wpa_supplicant/mesh.c
-@@ -355,6 +355,7 @@ static int wpa_supplicant_mesh_init(stru
- 		conf->country[0] = wpa_s->conf->country[0];
- 		conf->country[1] = wpa_s->conf->country[1];
- 		conf->country[2] = ' ';
-+		wpa_s->mesh_params->handle_dfs = 1;
- 	}
- 
- 	bss->iconf = conf;
diff --git a/package/network/services/hostapd/patches/014-mesh-fixes-for-mesh-init-deinit.patch b/package/network/services/hostapd/patches/014-mesh-fixes-for-mesh-init-deinit.patch
deleted file mode 100644
index fe12d401e4..0000000000
--- a/package/network/services/hostapd/patches/014-mesh-fixes-for-mesh-init-deinit.patch
+++ /dev/null
@@ -1,158 +0,0 @@
-From 30bdefd7559d57eae8c3c7e6f721ecf7be929bf2 Mon Sep 17 00:00:00 2001
-From: Markus Theil <markus.theil@tu-ilmenau.de>
-Date: Tue, 30 Jun 2020 14:19:02 +0200
-Subject: [PATCH 14/19] mesh: fixes for mesh init/deinit
-
-Send mesh group started notification after join completion
-callback is called.
-
-Implement outstanding TODO, to leave the mesh network on deinit.
-
-Signed-off-by: Markus Theil <markus.theil@tu-ilmenau.de>
----
- wpa_supplicant/mesh.c           | 32 ++++++++++++++++++++------------
- wpa_supplicant/mesh.h           |  6 ++++--
- wpa_supplicant/wpa_supplicant.c |  8 ++------
- 3 files changed, 26 insertions(+), 20 deletions(-)
-
---- a/wpa_supplicant/mesh.c
-+++ b/wpa_supplicant/mesh.c
-@@ -30,20 +30,20 @@
- 
- static void wpa_supplicant_mesh_deinit(struct wpa_supplicant *wpa_s)
- {
--	wpa_supplicant_mesh_iface_deinit(wpa_s, wpa_s->ifmsh);
-+	wpa_supplicant_mesh_iface_deinit(wpa_s, wpa_s->ifmsh, true);
- 	wpa_s->ifmsh = NULL;
- 	wpa_s->current_ssid = NULL;
- 	os_free(wpa_s->mesh_rsn);
- 	wpa_s->mesh_rsn = NULL;
- 	os_free(wpa_s->mesh_params);
- 	wpa_s->mesh_params = NULL;
--	/* TODO: leave mesh (stop beacon). This will happen on link down
--	 * anyway, so it's not urgent */
-+	wpa_supplicant_leave_mesh(wpa_s, false);
- }
- 
- 
- void wpa_supplicant_mesh_iface_deinit(struct wpa_supplicant *wpa_s,
--				      struct hostapd_iface *ifmsh)
-+				      struct hostapd_iface *ifmsh,
-+				      bool also_clear_hostapd)
- {
- 	if (!ifmsh)
- 		return;
-@@ -64,8 +64,10 @@ void wpa_supplicant_mesh_iface_deinit(st
- 	}
- 
- 	/* take care of shared data */
--	hostapd_interface_deinit(ifmsh);
--	hostapd_interface_free(ifmsh);
-+	if (also_clear_hostapd) {
-+		hostapd_interface_deinit(ifmsh);
-+		hostapd_interface_free(ifmsh);
-+	}
- }
- 
- 
-@@ -244,8 +246,7 @@ static int wpas_mesh_complete(struct wpa
- 	    wpas_mesh_init_rsn(wpa_s)) {
- 		wpa_printf(MSG_ERROR,
- 			   "mesh: RSN initialization failed - deinit mesh");
--		wpa_supplicant_mesh_deinit(wpa_s);
--		wpa_drv_leave_mesh(wpa_s);
-+		wpa_supplicant_mesh_iface_deinit(wpa_s, wpa_s->ifmsh, false);
- 		return -1;
- 	}
- 
-@@ -270,9 +271,15 @@ static int wpas_mesh_complete(struct wpa
- 	/* hostapd sets the interface down until we associate */
- 	wpa_drv_set_operstate(wpa_s, 1);
- 
--	if (!ret)
-+	if (!ret) {
- 		wpa_supplicant_set_state(wpa_s, WPA_COMPLETED);
- 
-+		wpa_msg(wpa_s, MSG_INFO, MESH_GROUP_STARTED "ssid=\"%s\" id=%d",
-+			wpa_ssid_txt(ssid->ssid, ssid->ssid_len),
-+			ssid->id);
-+		wpas_notify_mesh_group_started(wpa_s, ssid);
-+	}
-+
- 	return ret;
- }
- 
-@@ -563,7 +570,7 @@ int wpa_supplicant_join_mesh(struct wpa_
- 	wpa_s->mesh_params = params;
- 	if (wpa_supplicant_mesh_init(wpa_s, ssid, &params->freq)) {
- 		wpa_msg(wpa_s, MSG_ERROR, "Failed to init mesh");
--		wpa_drv_leave_mesh(wpa_s);
-+		wpa_supplicant_leave_mesh(wpa_s, true);
- 		ret = -1;
- 		goto out;
- 	}
-@@ -573,14 +580,15 @@ out:
- }
- 
- 
--int wpa_supplicant_leave_mesh(struct wpa_supplicant *wpa_s)
-+int wpa_supplicant_leave_mesh(struct wpa_supplicant *wpa_s, bool need_deinit)
- {
- 	int ret = 0;
- 
- 	wpa_msg(wpa_s, MSG_INFO, "leaving mesh");
- 
- 	/* Need to send peering close messages first */
--	wpa_supplicant_mesh_deinit(wpa_s);
-+	if (need_deinit)
-+		wpa_supplicant_mesh_deinit(wpa_s);
- 
- 	ret = wpa_drv_leave_mesh(wpa_s);
- 	if (ret)
---- a/wpa_supplicant/mesh.h
-+++ b/wpa_supplicant/mesh.h
-@@ -11,9 +11,11 @@
- 
- int wpa_supplicant_join_mesh(struct wpa_supplicant *wpa_s,
- 			     struct wpa_ssid *ssid);
--int wpa_supplicant_leave_mesh(struct wpa_supplicant *wpa_s);
-+int wpa_supplicant_leave_mesh(struct wpa_supplicant *wpa_s,
-+			      bool need_deinit);
- void wpa_supplicant_mesh_iface_deinit(struct wpa_supplicant *wpa_s,
--				      struct hostapd_iface *ifmsh);
-+				      struct hostapd_iface *ifmsh,
-+				      bool also_clear_hostapd);
- int wpas_mesh_scan_result_text(const u8 *ies, size_t ies_len, char *buf,
- 			       char *end);
- int wpas_mesh_add_interface(struct wpa_supplicant *wpa_s, char *ifname,
---- a/wpa_supplicant/wpa_supplicant.c
-+++ b/wpa_supplicant/wpa_supplicant.c
-@@ -2225,10 +2225,6 @@ void wpa_supplicant_associate(struct wpa
- 			return;
- 		}
- 		wpa_s->current_bss = bss;
--		wpa_msg(wpa_s, MSG_INFO, MESH_GROUP_STARTED "ssid=\"%s\" id=%d",
--			wpa_ssid_txt(ssid->ssid, ssid->ssid_len),
--			ssid->id);
--		wpas_notify_mesh_group_started(wpa_s, ssid);
- #else /* CONFIG_MESH */
- 		wpa_msg(wpa_s, MSG_ERROR,
- 			"mesh mode support not included in the build");
-@@ -3938,7 +3934,7 @@ void wpa_supplicant_deauthenticate(struc
- 			wpa_s->ifname);
- 		wpas_notify_mesh_group_removed(wpa_s, mconf->meshid,
- 					       mconf->meshid_len, reason_code);
--		wpa_supplicant_leave_mesh(wpa_s);
-+		wpa_supplicant_leave_mesh(wpa_s, true);
- 	}
- #endif /* CONFIG_MESH */
- 
-@@ -6551,7 +6547,7 @@ static void wpa_supplicant_deinit_iface(
- 
- #ifdef CONFIG_MESH
- 	if (wpa_s->ifmsh) {
--		wpa_supplicant_mesh_iface_deinit(wpa_s, wpa_s->ifmsh);
-+		wpa_supplicant_mesh_iface_deinit(wpa_s, wpa_s->ifmsh, true);
- 		wpa_s->ifmsh = NULL;
- 	}
- #endif /* CONFIG_MESH */
diff --git a/package/network/services/hostapd/patches/015-mesh-fix-DFS-deinit-init.patch b/package/network/services/hostapd/patches/015-mesh-fix-DFS-deinit-init.patch
deleted file mode 100644
index c540dd6786..0000000000
--- a/package/network/services/hostapd/patches/015-mesh-fix-DFS-deinit-init.patch
+++ /dev/null
@@ -1,262 +0,0 @@
-From d017f5d98a143c46c3c3fcb0e6507ca0b2bebdb0 Mon Sep 17 00:00:00 2001
-From: Markus Theil <markus.theil@tu-ilmenau.de>
-Date: Tue, 30 Jun 2020 14:19:03 +0200
-Subject: [PATCH 15/19] mesh: fix DFS deinit/init
-
-The hostapd DFS code deinitializes and initializes the
-AP interface, if a clean channel switch is not possible.
-In this case the AP code paths would deinit the driver, for
-example nl80211, without wpa_supplicant code paths getting
-notice of this.
-
-Therefore add callbacks for wpa_supplicant mesh methods,
-which are called on init/deinit of the AP bss. These
-callbacks are then used to handle the reset in the mesh
-code.
-
-Signed-off-by: Markus Theil <markus.theil@tu-ilmenau.de>
----
- src/ap/dfs.c          |  2 +-
- src/ap/hostapd.c      | 17 ++++++--
- src/ap/hostapd.h      |  6 +++
- wpa_supplicant/mesh.c | 90 +++++++++++++++++++++++++++++++++++++------
- 4 files changed, 100 insertions(+), 15 deletions(-)
-
---- a/src/ap/dfs.c
-+++ b/src/ap/dfs.c
-@@ -1112,7 +1112,7 @@ static int hostapd_dfs_start_channel_swi
- 				      oper_centr_freq_seg0_idx,
- 				      oper_centr_freq_seg1_idx,
- 				      cmode->vht_capab,
--				      &cmode->he_capab[IEEE80211_MODE_AP]);
-+				      &cmode->he_capab[iface->conf->hw_mode]);
- 
- 	if (err) {
- 		wpa_printf(MSG_ERROR, "DFS failed to calculate CSA freq params");
---- a/src/ap/hostapd.c
-+++ b/src/ap/hostapd.c
-@@ -354,7 +354,7 @@ static int hostapd_broadcast_wep_set(str
- #endif /* CONFIG_WEP */
- 
- 
--static void hostapd_free_hapd_data(struct hostapd_data *hapd)
-+void hostapd_free_hapd_data(struct hostapd_data *hapd)
- {
- 	os_free(hapd->probereq_cb);
- 	hapd->probereq_cb = NULL;
-@@ -498,7 +498,7 @@ static void sta_track_deinit(struct host
- }
- 
- 
--static void hostapd_cleanup_iface_partial(struct hostapd_iface *iface)
-+void hostapd_cleanup_iface_partial(struct hostapd_iface *iface)
- {
- 	wpa_printf(MSG_DEBUG, "%s(%p)", __func__, iface);
- #ifdef NEED_AP_MLME
-@@ -626,7 +626,7 @@ static int hostapd_flush_old_stations(st
- }
- 
- 
--static void hostapd_bss_deinit_no_free(struct hostapd_data *hapd)
-+void hostapd_bss_deinit_no_free(struct hostapd_data *hapd)
- {
- 	hostapd_free_stas(hapd);
- 	hostapd_flush_old_stations(hapd, WLAN_REASON_DEAUTH_LEAVING);
-@@ -2690,6 +2690,13 @@ int hostapd_enable_iface(struct hostapd_
- {
- 	size_t j;
- 
-+	if (hapd_iface == NULL)
-+		return -1;
-+
-+	if (hapd_iface->enable_iface_cb != NULL) {
-+		return hapd_iface->enable_iface_cb(hapd_iface);
-+	}
-+
- 	if (hapd_iface->bss[0]->drv_priv != NULL) {
- 		wpa_printf(MSG_ERROR, "Interface %s already enabled",
- 			   hapd_iface->conf->bss[0]->iface);
-@@ -2751,6 +2758,10 @@ int hostapd_disable_iface(struct hostapd
- 	if (hapd_iface == NULL)
- 		return -1;
- 
-+	if (hapd_iface->disable_iface_cb != NULL) {
-+		return hapd_iface->disable_iface_cb(hapd_iface);
-+	}
-+
- 	if (hapd_iface->bss[0]->drv_priv == NULL) {
- 		wpa_printf(MSG_INFO, "Interface %s already disabled",
- 			   hapd_iface->conf->bss[0]->iface);
---- a/src/ap/hostapd.h
-+++ b/src/ap/hostapd.h
-@@ -589,6 +589,9 @@ struct hostapd_iface {
- 
- 	/* Previous WMM element information */
- 	struct hostapd_wmm_ac_params prev_wmm[WMM_AC_NUM];
-+
-+	int (*enable_iface_cb)(struct hostapd_iface *iface);
-+	int (*disable_iface_cb)(struct hostapd_iface *iface);
- };
- 
- /* hostapd.c */
-@@ -617,6 +620,9 @@ void hostapd_interface_deinit_free(struc
- int hostapd_enable_iface(struct hostapd_iface *hapd_iface);
- int hostapd_reload_iface(struct hostapd_iface *hapd_iface);
- int hostapd_disable_iface(struct hostapd_iface *hapd_iface);
-+void hostapd_bss_deinit_no_free(struct hostapd_data *hapd);
-+void hostapd_free_hapd_data(struct hostapd_data *hapd);
-+void hostapd_cleanup_iface_partial(struct hostapd_iface *iface);
- int hostapd_add_iface(struct hapd_interfaces *ifaces, char *buf);
- int hostapd_remove_iface(struct hapd_interfaces *ifaces, char *buf);
- void hostapd_channel_list_updated(struct hostapd_iface *iface, int initiator);
---- a/wpa_supplicant/mesh.c
-+++ b/wpa_supplicant/mesh.c
-@@ -28,15 +28,20 @@
- #include "mesh.h"
- 
- 
--static void wpa_supplicant_mesh_deinit(struct wpa_supplicant *wpa_s)
-+static void wpa_supplicant_mesh_deinit(struct wpa_supplicant *wpa_s, bool also_clear_hostapd)
- {
--	wpa_supplicant_mesh_iface_deinit(wpa_s, wpa_s->ifmsh, true);
--	wpa_s->ifmsh = NULL;
--	wpa_s->current_ssid = NULL;
-+	wpa_supplicant_mesh_iface_deinit(wpa_s, wpa_s->ifmsh, also_clear_hostapd);
-+
-+	if (also_clear_hostapd) {
-+		wpa_s->ifmsh = NULL;
-+		wpa_s->current_ssid = NULL;
-+		os_free(wpa_s->mesh_params);
-+		wpa_s->mesh_params = NULL;
-+	}
-+
- 	os_free(wpa_s->mesh_rsn);
- 	wpa_s->mesh_rsn = NULL;
--	os_free(wpa_s->mesh_params);
--	wpa_s->mesh_params = NULL;
-+
- 	wpa_supplicant_leave_mesh(wpa_s, false);
- }
- 
-@@ -237,7 +242,7 @@ static int wpas_mesh_complete(struct wpa
- 				ifmsh->conf->vht_capab,
- 				he_capab)) {
- 			wpa_printf(MSG_ERROR, "Error updating mesh frequency params.");
--			wpa_supplicant_mesh_deinit(wpa_s);
-+			wpa_supplicant_mesh_deinit(wpa_s, true);
- 			return -1;
- 		}
- 	}
-@@ -246,7 +251,7 @@ static int wpas_mesh_complete(struct wpa
- 	    wpas_mesh_init_rsn(wpa_s)) {
- 		wpa_printf(MSG_ERROR,
- 			   "mesh: RSN initialization failed - deinit mesh");
--		wpa_supplicant_mesh_iface_deinit(wpa_s, wpa_s->ifmsh, false);
-+		wpa_supplicant_mesh_deinit(wpa_s, false);
- 		return -1;
- 	}
- 
-@@ -291,6 +296,67 @@ static void wpas_mesh_complete_cb(void *
- }
- 
- 
-+static int wpa_supplicant_mesh_enable_iface_cb(struct hostapd_iface *ifmsh)
-+{
-+	struct wpa_supplicant *wpa_s = ifmsh->owner;
-+	struct hostapd_data *bss;
-+
-+	ifmsh->mconf = mesh_config_create(wpa_s, wpa_s->current_ssid);
-+
-+	bss = ifmsh->bss[0];
-+	bss->msg_ctx = wpa_s;
-+	os_memcpy(bss->own_addr, wpa_s->own_addr, ETH_ALEN);
-+	bss->driver = wpa_s->driver;
-+	bss->drv_priv = wpa_s->drv_priv;
-+	bss->iface = ifmsh;
-+	bss->mesh_sta_free_cb = mesh_mpm_free_sta;
-+	bss->setup_complete_cb = wpas_mesh_complete_cb;
-+	bss->setup_complete_cb_ctx = wpa_s;
-+
-+	bss->conf->start_disabled = 1;
-+	bss->conf->mesh = MESH_ENABLED;
-+	bss->conf->ap_max_inactivity = wpa_s->conf->mesh_max_inactivity;
-+
-+	if (wpa_drv_init_mesh(wpa_s)) {
-+		wpa_msg(wpa_s, MSG_ERROR, "Failed to init mesh in driver");
-+		return -1;
-+	}
-+
-+	if (hostapd_setup_interface(ifmsh)) {
-+		wpa_printf(MSG_ERROR,
-+			   "Failed to initialize hostapd interface for mesh");
-+		return -1;
-+	}
-+
-+	return 0;
-+}
-+
-+
-+static int wpa_supplicant_mesh_disable_iface_cb(struct hostapd_iface *ifmsh)
-+{
-+	struct wpa_supplicant *wpa_s = ifmsh->owner;
-+	int j;
-+
-+	wpa_supplicant_mesh_deinit(wpa_s, false);
-+
-+#ifdef NEED_AP_MLME
-+	for (j = 0; j < ifmsh->num_bss; j++)
-+		hostapd_cleanup_cs_params(ifmsh->bss[j]);
-+#endif /* NEED_AP_MLME */
-+
-+	/* same as hostapd_interface_deinit without deinitializing ctrl-iface */
-+	for (j = 0; j < ifmsh->num_bss; j++) {
-+		struct hostapd_data *hapd = ifmsh->bss[j];
-+		hostapd_bss_deinit_no_free(hapd);
-+		hostapd_free_hapd_data(hapd);
-+	}
-+
-+	hostapd_cleanup_iface_partial(ifmsh);
-+
-+	return 0;
-+}
-+
-+
- static int wpa_supplicant_mesh_init(struct wpa_supplicant *wpa_s,
- 				    struct wpa_ssid *ssid,
- 				    struct hostapd_freq_params *freq)
-@@ -318,6 +384,8 @@ static int wpa_supplicant_mesh_init(stru
- 	ifmsh->drv_flags = wpa_s->drv_flags;
- 	ifmsh->drv_flags2 = wpa_s->drv_flags2;
- 	ifmsh->num_bss = 1;
-+	ifmsh->enable_iface_cb = wpa_supplicant_mesh_enable_iface_cb;
-+	ifmsh->disable_iface_cb = wpa_supplicant_mesh_disable_iface_cb;
- 	ifmsh->bss = os_calloc(wpa_s->ifmsh->num_bss,
- 			       sizeof(struct hostapd_data *));
- 	if (!ifmsh->bss)
-@@ -451,7 +519,7 @@ static int wpa_supplicant_mesh_init(stru
- 
- 	return 0;
- out_free:
--	wpa_supplicant_mesh_deinit(wpa_s);
-+	wpa_supplicant_mesh_deinit(wpa_s, true);
- 	return -ENOMEM;
- }
- 
-@@ -499,7 +567,7 @@ int wpa_supplicant_join_mesh(struct wpa_
- 		goto out;
- 	}
- 
--	wpa_supplicant_mesh_deinit(wpa_s);
-+	wpa_supplicant_mesh_deinit(wpa_s, true);
- 
- 	wpa_s->pairwise_cipher = WPA_CIPHER_NONE;
- 	wpa_s->group_cipher = WPA_CIPHER_NONE;
-@@ -588,7 +656,7 @@ int wpa_supplicant_leave_mesh(struct wpa
- 
- 	/* Need to send peering close messages first */
- 	if (need_deinit)
--		wpa_supplicant_mesh_deinit(wpa_s);
-+		wpa_supplicant_mesh_deinit(wpa_s, true);
- 
- 	ret = wpa_drv_leave_mesh(wpa_s);
- 	if (ret)
diff --git a/package/network/services/hostapd/patches/016-tests-DFS-test-for-wpa_supplicant-mesh.patch b/package/network/services/hostapd/patches/016-tests-DFS-test-for-wpa_supplicant-mesh.patch
deleted file mode 100644
index b6a51b2f35..0000000000
--- a/package/network/services/hostapd/patches/016-tests-DFS-test-for-wpa_supplicant-mesh.patch
+++ /dev/null
@@ -1,94 +0,0 @@
-From 6ee4e70d469b8ce05013ed524eea32ea303e6563 Mon Sep 17 00:00:00 2001
-From: Markus Theil <markus.theil@tu-ilmenau.de>
-Date: Tue, 30 Jun 2020 14:19:04 +0200
-Subject: [PATCH 16/19] tests: DFS test for wpa_supplicant mesh
-
-Add a test with uses a DFS channel, waits for CAC
-afterwards successfull mesh join and then triggers
-a radar event and check if the mesh comes up again
-on the same device.
-
-Signed-off-by: Markus Theil <markus.theil@tu-ilmenau.de>
----
- tests/hwsim/test_wpas_mesh.py | 56 +++++++++++++++++++++++++++++++++--
- 1 file changed, 54 insertions(+), 2 deletions(-)
-
---- a/tests/hwsim/test_wpas_mesh.py
-+++ b/tests/hwsim/test_wpas_mesh.py
-@@ -80,8 +80,23 @@ def check_mesh_scan(dev, params, other_s
-     if '[MESH]' not in bss['flags']:
-         raise Exception("BSS output did not include MESH flag")
- 
--def check_mesh_group_added(dev):
--    ev = dev.wait_event(["MESH-GROUP-STARTED"])
-+def check_dfs_started(dev, timeout=10):
-+    ev = dev.wait_event(["DFS-CAC-START"], timeout=timeout)
-+    if ev is None:
-+        raise Exception("Test exception: CAC did not start")
-+
-+def check_dfs_finished(dev, timeout=70):
-+    ev = dev.wait_event(["DFS-CAC-COMPLETED"], timeout=timeout)
-+    if ev is None:
-+        raise Exception("Test exception: CAC did not finish")
-+
-+def check_mesh_radar_handling_finished(dev, timeout=75):
-+    ev = dev.wait_event(["CTRL-EVENT-CHANNEL-SWITCH", "MESH-GROUP-STARTED"], timeout=timeout)
-+    if ev is None:
-+        raise Exception("Test exception: Couldn't join mesh")
-+
-+def check_mesh_group_added(dev, timeout=10):
-+    ev = dev.wait_event(["MESH-GROUP-STARTED"], timeout=timeout)
-     if ev is None:
-         raise Exception("Test exception: Couldn't join mesh")
- 
-@@ -91,6 +106,10 @@ def check_mesh_group_removed(dev):
-     if ev is None:
-         raise Exception("Test exception: Couldn't leave mesh")
- 
-+def check_regdom_change(dev, timeout=10):
-+    ev = dev.wait_event(["CTRL-EVENT-REGDOM-CHANGE"], timeout=timeout)
-+    if ev is None:
-+        raise Exception("Test exception: No regdom change happened.")
- 
- def check_mesh_peer_connected(dev, timeout=10):
-     ev = dev.wait_event(["MESH-PEER-CONNECTED"], timeout=timeout)
-@@ -167,6 +186,39 @@ def test_wpas_mesh_group_remove(dev):
-     check_mesh_group_removed(dev[0])
-     dev[0].mesh_group_remove()
- 
-+def dfs_simulate_radar(dev):
-+    logger.info("Trigger a simulated radar event")
-+    phyname = dev.get_driver_status_field("phyname")
-+    radar_file = '/sys/kernel/debug/ieee80211/' + phyname + '/hwsim/dfs_simulate_radar'
-+    with open(radar_file, 'w') as f:
-+        f.write('1')
-+
-+@long_duration_test
-+def test_wpas_mesh_peer_connected_dfs(dev):
-+    """wpa_supplicant MESH peer connected"""
-+    dev[0].set("country", "DE")
-+    dev[1].set("country", "DE")
-+
-+    check_regdom_change(dev[0])
-+    check_regdom_change(dev[1])
-+
-+    check_mesh_support(dev[0])
-+    add_open_mesh_network(dev[0], freq="5500", beacon_int=160)
-+    add_open_mesh_network(dev[1], freq="5500", beacon_int=160)
-+    check_dfs_started(dev[0])
-+    check_dfs_finished(dev[0])
-+    check_mesh_joined_connected(dev, timeout0=10)
-+
-+    dfs_simulate_radar(dev[0])
-+
-+    check_mesh_radar_handling_finished(dev[0], timeout=75)
-+
-+    dev[0].set("country", "00")
-+    dev[1].set("country", "00")
-+
-+    check_regdom_change(dev[0])
-+    check_regdom_change(dev[1])
-+
- def test_wpas_mesh_peer_connected(dev):
-     """wpa_supplicant MESH peer connected"""
-     check_mesh_support(dev[0])
diff --git a/package/network/services/hostapd/patches/017-mesh-fix-mesh_oom-test.patch b/package/network/services/hostapd/patches/017-mesh-fix-mesh_oom-test.patch
deleted file mode 100644
index cc566c7de2..0000000000
--- a/package/network/services/hostapd/patches/017-mesh-fix-mesh_oom-test.patch
+++ /dev/null
@@ -1,24 +0,0 @@
-From 928da9a270deaf4409aee4d87a33a6f61b56c136 Mon Sep 17 00:00:00 2001
-From: Markus Theil <markus.theil@tu-ilmenau.de>
-Date: Tue, 30 Jun 2020 14:19:05 +0200
-Subject: [PATCH 17/19] mesh: fix mesh_oom test
-
-Only change freq params, if ifmsh->freq is set initially, which only
-happens if hostapd_get_hw_features in setup_interface2 succeeds.
-
-Signed-off-by: Markus Theil <markus.theil@tu-ilmenau.de>
----
- wpa_supplicant/mesh.c | 2 +-
- 1 file changed, 1 insertion(+), 1 deletion(-)
-
---- a/wpa_supplicant/mesh.c
-+++ b/wpa_supplicant/mesh.c
-@@ -218,7 +218,7 @@ static int wpas_mesh_complete(struct wpa
- 	 * inspect if channel's been changed since initialized.
- 	 * i.e. DFS radar detection
- 	 */
--	if (ifmsh->freq != params->freq.freq) {
-+	if (ifmsh->freq > 0 && ifmsh->freq != params->freq.freq) {
- 		wpa_s->assoc_freq = ifmsh->freq;
- 		ssid->frequency = ifmsh->freq;
- 		struct he_capabilities *he_capab = NULL;
diff --git a/package/network/services/hostapd/patches/018-mesh-move-mesh-freq-setting-to-own-function.patch b/package/network/services/hostapd/patches/018-mesh-move-mesh-freq-setting-to-own-function.patch
deleted file mode 100644
index 1dd7d37411..0000000000
--- a/package/network/services/hostapd/patches/018-mesh-move-mesh-freq-setting-to-own-function.patch
+++ /dev/null
@@ -1,93 +0,0 @@
-From 1eab0e62920f443f8814bad846f6439843223b69 Mon Sep 17 00:00:00 2001
-From: Markus Theil <markus.theil@tu-ilmenau.de>
-Date: Tue, 30 Jun 2020 14:19:06 +0200
-Subject: [PATCH 18/19] mesh: move mesh freq setting to own function
-
-Signed-off-by: Markus Theil <markus.theil@tu-ilmenau.de>
----
- wpa_supplicant/mesh.c | 59 ++++++++++++++++++++++++++-----------------
- 1 file changed, 36 insertions(+), 23 deletions(-)
-
---- a/wpa_supplicant/mesh.c
-+++ b/wpa_supplicant/mesh.c
-@@ -201,6 +201,40 @@ static int wpas_mesh_init_rsn(struct wpa
- 	return !wpa_s->mesh_rsn ? -1 : 0;
- }
- 
-+
-+static int wpas_mesh_update_freq_params(struct wpa_supplicant *wpa_s)
-+{
-+	struct wpa_driver_mesh_join_params *params = wpa_s->mesh_params;
-+	struct hostapd_iface *ifmsh = wpa_s->ifmsh;
-+	struct he_capabilities *he_capab = NULL;
-+
-+	if (ifmsh->current_mode)
-+		he_capab = &ifmsh->current_mode->he_capab[IEEE80211_MODE_MESH];
-+
-+	if (hostapd_set_freq_params(&params->freq,
-+			ifmsh->conf->hw_mode,
-+			ifmsh->freq,
-+			ifmsh->conf->channel,
-+			ifmsh->conf->enable_edmg,
-+			ifmsh->conf->edmg_channel,
-+			ifmsh->conf->ieee80211n,
-+			ifmsh->conf->ieee80211ac,
-+			ifmsh->conf->ieee80211ax,
-+			ifmsh->conf->secondary_channel,
-+			hostapd_get_oper_chwidth(ifmsh->conf),
-+			hostapd_get_oper_centr_freq_seg0_idx(ifmsh->conf),
-+			hostapd_get_oper_centr_freq_seg1_idx(ifmsh->conf),
-+			ifmsh->conf->vht_capab,
-+			he_capab)) {
-+		wpa_printf(MSG_ERROR, "Error updating mesh frequency params.");
-+		wpa_supplicant_mesh_deinit(wpa_s, true);
-+		return -1;
-+	}
-+
-+	return 0;
-+}
-+
-+
- static int wpas_mesh_complete(struct wpa_supplicant *wpa_s)
- {
- 	struct hostapd_iface *ifmsh = wpa_s->ifmsh;
-@@ -221,30 +255,8 @@ static int wpas_mesh_complete(struct wpa
- 	if (ifmsh->freq > 0 && ifmsh->freq != params->freq.freq) {
- 		wpa_s->assoc_freq = ifmsh->freq;
- 		ssid->frequency = ifmsh->freq;
--		struct he_capabilities *he_capab = NULL;
--
--		if (ifmsh->current_mode)
--			he_capab = &ifmsh->current_mode->he_capab[IEEE80211_MODE_MESH];
--
--		if (hostapd_set_freq_params(&params->freq,
--				ifmsh->conf->hw_mode,
--				ifmsh->freq,
--				ifmsh->conf->channel,
--				ifmsh->conf->enable_edmg,
--				ifmsh->conf->edmg_channel,
--				ifmsh->conf->ieee80211n,
--				ifmsh->conf->ieee80211ac,
--				ifmsh->conf->ieee80211ax,
--				ifmsh->conf->secondary_channel,
--				hostapd_get_oper_chwidth(ifmsh->conf),
--				hostapd_get_oper_centr_freq_seg0_idx(ifmsh->conf),
--				hostapd_get_oper_centr_freq_seg1_idx(ifmsh->conf),
--				ifmsh->conf->vht_capab,
--				he_capab)) {
--			wpa_printf(MSG_ERROR, "Error updating mesh frequency params.");
--			wpa_supplicant_mesh_deinit(wpa_s, true);
-+		if (wpas_mesh_update_freq_params(wpa_s) != 0)
- 			return -1;
--		}
- 	}
- 
- 	if (ifmsh->mconf->security != MESH_CONF_SEC_NONE &&
-@@ -518,6 +530,7 @@ static int wpa_supplicant_mesh_init(stru
- 	}
- 
- 	return 0;
-+
- out_free:
- 	wpa_supplicant_mesh_deinit(wpa_s, true);
- 	return -ENOMEM;
diff --git a/package/network/services/hostapd/patches/019-mesh-use-deterministic-channel-on-channel-switch.patch b/package/network/services/hostapd/patches/019-mesh-use-deterministic-channel-on-channel-switch.patch
deleted file mode 100644
index 8e38a8e53c..0000000000
--- a/package/network/services/hostapd/patches/019-mesh-use-deterministic-channel-on-channel-switch.patch
+++ /dev/null
@@ -1,81 +0,0 @@
-From fc8ea40f6130ac18d9c66797de2cf1d5af55d496 Mon Sep 17 00:00:00 2001
-From: Markus Theil <markus.theil@tu-ilmenau.de>
-Date: Tue, 30 Jun 2020 14:19:07 +0200
-Subject: [PATCH 19/19] mesh: use deterministic channel on channel switch
-
-This patch uses a deterministic channel on DFS channel switch
-in mesh networks. Otherwise, when switching to a usable but not
-available channel, no CSA can be sent and a random channel is choosen
-without notification of other nodes. It is then quite likely, that
-the mesh network gets disconnected.
-
-Fix this by using a deterministic number, based on the sha256 hash
-of the mesh ID, in order to use at least a different number in each
-mesh network.
-
-Signed-off-by: Markus Theil <markus.theil@tu-ilmenau.de>
----
- src/ap/dfs.c                 | 20 +++++++++++++++++++-
- src/drivers/driver_nl80211.c |  4 ++++
- 2 files changed, 23 insertions(+), 1 deletion(-)
-
---- a/src/ap/dfs.c
-+++ b/src/ap/dfs.c
-@@ -17,6 +17,7 @@
- #include "ap_drv_ops.h"
- #include "drivers/driver.h"
- #include "dfs.h"
-+#include "crypto/crypto.h"
- 
- 
- static int dfs_get_used_n_chans(struct hostapd_iface *iface, int *seg1)
-@@ -480,9 +481,14 @@ dfs_get_valid_channel(struct hostapd_ifa
- 	int num_available_chandefs;
- 	int chan_idx, chan_idx2;
- 	int sec_chan_idx_80p80 = -1;
-+	bool is_mesh = false;
- 	int i;
- 	u32 _rand;
- 
-+#ifdef CONFIG_MESH
-+	is_mesh = iface->mconf;
-+#endif
-+
- 	wpa_printf(MSG_DEBUG, "DFS: Selecting random channel");
- 	*secondary_channel = 0;
- 	*oper_centr_freq_seg0_idx = 0;
-@@ -502,8 +508,20 @@ dfs_get_valid_channel(struct hostapd_ifa
- 	if (num_available_chandefs == 0)
- 		return NULL;
- 
--	if (os_get_random((u8 *) &_rand, sizeof(_rand)) < 0)
-+	/* try to use deterministic channel in mesh, so that both sides
-+	 * have a chance to switch to the same channel */
-+	if (is_mesh) {
-+#ifdef CONFIG_MESH
-+		u64 hash[4];
-+		const u8 *meshid[1] = { &iface->mconf->meshid[0] };
-+		const size_t meshid_len = iface->mconf->meshid_len;
-+
-+		sha256_vector(1, meshid, &meshid_len, (u8 *)&hash[0]);
-+		_rand = hash[0] + hash[1] + hash[2] + hash[3];
-+#endif
-+	} else if (os_get_random((u8 *) &_rand, sizeof(_rand)) < 0)
- 		return NULL;
-+
- 	chan_idx = _rand % num_available_chandefs;
- 	dfs_find_channel(iface, &chan, chan_idx, skip_radar);
- 	if (!chan) {
---- a/src/drivers/driver_nl80211.c
-+++ b/src/drivers/driver_nl80211.c
-@@ -9473,6 +9473,10 @@ static int nl80211_switch_channel(void *
- 	if (ret)
- 		goto error;
- 
-+	if (drv->nlmode == NL80211_IFTYPE_MESH_POINT) {
-+		nla_put_flag(msg, NL80211_ATTR_HANDLE_DFS);
-+	}
-+
- 	/* beacon_csa params */
- 	beacon_csa = nla_nest_start(msg, NL80211_ATTR_CSA_IES);
- 	if (!beacon_csa)
diff --git a/package/network/services/hostapd/patches/020-ignore-4addr-mode-enabling-error.patch b/package/network/services/hostapd/patches/020-ignore-4addr-mode-enabling-error.patch
deleted file mode 100644
index f6751829a5..0000000000
--- a/package/network/services/hostapd/patches/020-ignore-4addr-mode-enabling-error.patch
+++ /dev/null
@@ -1,73 +0,0 @@
-From c7cca9b08f3e1e49c4a4a59ec66c47d91448e6ae Mon Sep 17 00:00:00 2001
-From: Jouni Malinen <j@w1.fi>
-Date: Sat, 13 Feb 2021 23:59:28 +0200
-Subject: [PATCH] nl80211: Ignore 4addr mode enabling error if it was already
- enabled
-
-nl80211_set_4addr_mode() could fail when trying to enable 4addr mode on
-an interface that is in a bridge and has 4addr mode already enabled.
-This operation would not have been necessary in the first place and this
-failure results in disconnecting, e.g., when roaming from one backhaul
-BSS to another BSS with Multi AP.
-
-Avoid this issue by ignoring the nl80211 command failure in the case
-where 4addr mode is being enabled while it has already been enabled.
-
-Signed-off-by: Jouni Malinen <j@w1.fi>
----
- src/drivers/driver_nl80211.c | 23 +++++++++++++++++++++++
- 1 file changed, 23 insertions(+)
-
---- a/src/drivers/driver_nl80211.c
-+++ b/src/drivers/driver_nl80211.c
-@@ -617,6 +617,7 @@ struct wiphy_idx_data {
- 	int wiphy_idx;
- 	enum nl80211_iftype nlmode;
- 	u8 *macaddr;
-+	u8 use_4addr;
- };
- 
- 
-@@ -639,6 +640,9 @@ static int netdev_info_handler(struct nl
- 		os_memcpy(info->macaddr, nla_data(tb[NL80211_ATTR_MAC]),
- 			  ETH_ALEN);
- 
-+	if (tb[NL80211_ATTR_4ADDR])
-+		info->use_4addr = nla_get_u8(tb[NL80211_ATTR_4ADDR]);
-+
- 	return NL_SKIP;
- }
- 
-@@ -691,6 +695,20 @@ static int nl80211_get_macaddr(struct i8
- }
- 
- 
-+static int nl80211_get_4addr(struct i802_bss *bss)
-+{
-+	struct nl_msg *msg;
-+	struct wiphy_idx_data data = {
-+		.use_4addr = 0,
-+	};
-+
-+	if (!(msg = nl80211_cmd_msg(bss, 0, NL80211_CMD_GET_INTERFACE)) ||
-+	    send_and_recv_msgs(bss->drv, msg, netdev_info_handler, &data))
-+		return -1;
-+	return data.use_4addr;
-+}
-+
-+
- static int nl80211_register_beacons(struct wpa_driver_nl80211_data *drv,
- 				    struct nl80211_wiphy_data *w)
- {
-@@ -11508,6 +11526,11 @@ static int nl80211_set_4addr_mode(void *
- 
- 	ret = send_and_recv_msgs(drv, msg, NULL, NULL);
- 	msg = NULL;
-+	if (ret && val && nl80211_get_4addr(bss) == 1) {
-+		wpa_printf(MSG_DEBUG,
-+			   "nl80211: 4addr mode was already enabled");
-+		ret = 0;
-+	}
- 	if (!ret) {
- 		if (bridge_ifname[0] && val &&
- 		    i802_check_bridge(drv, bss, bridge_ifname, bss->ifname) < 0)
diff --git a/package/network/services/hostapd/patches/023-ndisc_snoop-call-dl_list_del-before-freeing-ipv6-add.patch b/package/network/services/hostapd/patches/023-ndisc_snoop-call-dl_list_del-before-freeing-ipv6-add.patch
deleted file mode 100644
index 9ff9b2398d..0000000000
--- a/package/network/services/hostapd/patches/023-ndisc_snoop-call-dl_list_del-before-freeing-ipv6-add.patch
+++ /dev/null
@@ -1,19 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Date: Wed, 28 Jul 2021 05:43:29 +0200
-Subject: [PATCH] ndisc_snoop: call dl_list_del before freeing ipv6 addresses
-
-Fixes a segmentation fault on sta disconnect
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
-
---- a/src/ap/ndisc_snoop.c
-+++ b/src/ap/ndisc_snoop.c
-@@ -61,6 +61,7 @@ void sta_ip6addr_del(struct hostapd_data
- 	dl_list_for_each_safe(ip6addr, prev, &sta->ip6addr, struct ip6addr,
- 			      list) {
- 		hostapd_drv_br_delete_ip_neigh(hapd, 6, (u8 *) &ip6addr->addr);
-+		dl_list_del(&ip6addr->list);
- 		os_free(ip6addr);
- 	}
- }
diff --git a/package/network/services/hostapd/patches/030-driver_nl80211-rewrite-neigh-code-to-not-depend-on-l.patch b/package/network/services/hostapd/patches/030-driver_nl80211-rewrite-neigh-code-to-not-depend-on-l.patch
deleted file mode 100644
index f65362fe96..0000000000
--- a/package/network/services/hostapd/patches/030-driver_nl80211-rewrite-neigh-code-to-not-depend-on-l.patch
+++ /dev/null
@@ -1,275 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Date: Wed, 28 Jul 2021 05:49:46 +0200
-Subject: [PATCH] driver_nl80211: rewrite neigh code to not depend on
- libnl3-route
-
-Removes an unnecessary dependency and also makes the code smaller
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
-
---- a/src/drivers/driver_nl80211.c
-+++ b/src/drivers/driver_nl80211.c
-@@ -16,9 +16,6 @@
- #include <net/if.h>
- #include <netlink/genl/genl.h>
- #include <netlink/genl/ctrl.h>
--#ifdef CONFIG_LIBNL3_ROUTE
--#include <netlink/route/neighbour.h>
--#endif /* CONFIG_LIBNL3_ROUTE */
- #include <linux/rtnetlink.h>
- #include <netpacket/packet.h>
- #include <linux/errqueue.h>
-@@ -4965,26 +4962,29 @@ fail:
- 
- static void rtnl_neigh_delete_fdb_entry(struct i802_bss *bss, const u8 *addr)
- {
--#ifdef CONFIG_LIBNL3_ROUTE
- 	struct wpa_driver_nl80211_data *drv = bss->drv;
--	struct rtnl_neigh *rn;
--	struct nl_addr *nl_addr;
-+	struct ndmsg nhdr = {
-+		.ndm_state = NUD_PERMANENT,
-+		.ndm_ifindex = bss->ifindex,
-+		.ndm_family = AF_BRIDGE,
-+	};
-+	struct nl_msg *msg;
- 	int err;
- 
--	rn = rtnl_neigh_alloc();
--	if (!rn)
-+	msg = nlmsg_alloc_simple(RTM_DELNEIGH, NLM_F_CREATE);
-+	if (!msg)
- 		return;
- 
--	rtnl_neigh_set_family(rn, AF_BRIDGE);
--	rtnl_neigh_set_ifindex(rn, bss->ifindex);
--	nl_addr = nl_addr_build(AF_BRIDGE, (void *) addr, ETH_ALEN);
--	if (!nl_addr) {
--		rtnl_neigh_put(rn);
--		return;
--	}
--	rtnl_neigh_set_lladdr(rn, nl_addr);
-+	if (nlmsg_append(msg, &nhdr, sizeof(nhdr), NLMSG_ALIGNTO) < 0)
-+		goto errout;
-+
-+	if (nla_put(msg, NDA_LLADDR, ETH_ALEN, (void *)addr))
-+		goto errout;
-+
-+	if (nl_send_auto_complete(drv->rtnl_sk, msg) < 0)
-+		goto errout;
- 
--	err = rtnl_neigh_delete(drv->rtnl_sk, rn, 0);
-+	err = nl_wait_for_ack(drv->rtnl_sk);
- 	if (err < 0) {
- 		wpa_printf(MSG_DEBUG, "nl80211: bridge FDB entry delete for "
- 			   MACSTR " ifindex=%d failed: %s", MAC2STR(addr),
-@@ -4994,9 +4994,8 @@ static void rtnl_neigh_delete_fdb_entry(
- 			   MACSTR, MAC2STR(addr));
- 	}
- 
--	nl_addr_put(nl_addr);
--	rtnl_neigh_put(rn);
--#endif /* CONFIG_LIBNL3_ROUTE */
-+errout:
-+	nlmsg_free(msg);
- }
- 
- 
-@@ -7337,7 +7336,6 @@ static void *i802_init(struct hostapd_da
- 	    (params->num_bridge == 0 || !params->bridge[0]))
- 		add_ifidx(drv, br_ifindex, drv->ifindex);
- 
--#ifdef CONFIG_LIBNL3_ROUTE
- 	if (bss->added_if_into_bridge || bss->already_in_bridge) {
- 		int err;
- 
-@@ -7354,7 +7352,6 @@ static void *i802_init(struct hostapd_da
- 			goto failed;
- 		}
- 	}
--#endif /* CONFIG_LIBNL3_ROUTE */
- 
- 	if (drv->capa.flags2 & WPA_DRIVER_FLAGS2_CONTROL_PORT_RX) {
- 		wpa_printf(MSG_DEBUG,
-@@ -10238,13 +10235,14 @@ static int wpa_driver_br_add_ip_neigh(vo
- 				      const u8 *ipaddr, int prefixlen,
- 				      const u8 *addr)
- {
--#ifdef CONFIG_LIBNL3_ROUTE
- 	struct i802_bss *bss = priv;
- 	struct wpa_driver_nl80211_data *drv = bss->drv;
--	struct rtnl_neigh *rn;
--	struct nl_addr *nl_ipaddr = NULL;
--	struct nl_addr *nl_lladdr = NULL;
--	int family, addrsize;
-+	struct ndmsg nhdr = {
-+		.ndm_state = NUD_PERMANENT,
-+		.ndm_ifindex = bss->br_ifindex,
-+	};
-+	struct nl_msg *msg;
-+	int addrsize;
- 	int res;
- 
- 	if (!ipaddr || prefixlen == 0 || !addr)
-@@ -10263,85 +10261,66 @@ static int wpa_driver_br_add_ip_neigh(vo
- 	}
- 
- 	if (version == 4) {
--		family = AF_INET;
-+		nhdr.ndm_family = AF_INET;
- 		addrsize = 4;
- 	} else if (version == 6) {
--		family = AF_INET6;
-+		nhdr.ndm_family = AF_INET6;
- 		addrsize = 16;
- 	} else {
- 		return -EINVAL;
- 	}
- 
--	rn = rtnl_neigh_alloc();
--	if (rn == NULL)
-+	msg = nlmsg_alloc_simple(RTM_NEWNEIGH, NLM_F_CREATE);
-+	if (!msg)
- 		return -ENOMEM;
- 
--	/* set the destination ip address for neigh */
--	nl_ipaddr = nl_addr_build(family, (void *) ipaddr, addrsize);
--	if (nl_ipaddr == NULL) {
--		wpa_printf(MSG_DEBUG, "nl80211: nl_ipaddr build failed");
--		res = -ENOMEM;
-+	res = -ENOMEM;
-+	if (nlmsg_append(msg, &nhdr, sizeof(nhdr), NLMSG_ALIGNTO) < 0)
- 		goto errout;
--	}
--	nl_addr_set_prefixlen(nl_ipaddr, prefixlen);
--	res = rtnl_neigh_set_dst(rn, nl_ipaddr);
--	if (res) {
--		wpa_printf(MSG_DEBUG,
--			   "nl80211: neigh set destination addr failed");
-+
-+	if (nla_put(msg, NDA_DST, addrsize, (void *)ipaddr))
- 		goto errout;
--	}
- 
--	/* set the corresponding lladdr for neigh */
--	nl_lladdr = nl_addr_build(AF_BRIDGE, (u8 *) addr, ETH_ALEN);
--	if (nl_lladdr == NULL) {
--		wpa_printf(MSG_DEBUG, "nl80211: neigh set lladdr failed");
--		res = -ENOMEM;
-+	if (nla_put(msg, NDA_LLADDR, ETH_ALEN, (void *)addr))
- 		goto errout;
--	}
--	rtnl_neigh_set_lladdr(rn, nl_lladdr);
- 
--	rtnl_neigh_set_ifindex(rn, bss->br_ifindex);
--	rtnl_neigh_set_state(rn, NUD_PERMANENT);
-+	res = nl_send_auto_complete(drv->rtnl_sk, msg);
-+	if (res < 0)
-+		goto errout;
- 
--	res = rtnl_neigh_add(drv->rtnl_sk, rn, NLM_F_CREATE);
-+	res = nl_wait_for_ack(drv->rtnl_sk);
- 	if (res) {
- 		wpa_printf(MSG_DEBUG,
- 			   "nl80211: Adding bridge ip neigh failed: %s",
- 			   nl_geterror(res));
- 	}
- errout:
--	if (nl_lladdr)
--		nl_addr_put(nl_lladdr);
--	if (nl_ipaddr)
--		nl_addr_put(nl_ipaddr);
--	if (rn)
--		rtnl_neigh_put(rn);
-+	nlmsg_free(msg);
- 	return res;
--#else /* CONFIG_LIBNL3_ROUTE */
--	return -1;
--#endif /* CONFIG_LIBNL3_ROUTE */
- }
- 
- 
- static int wpa_driver_br_delete_ip_neigh(void *priv, u8 version,
- 					 const u8 *ipaddr)
- {
--#ifdef CONFIG_LIBNL3_ROUTE
- 	struct i802_bss *bss = priv;
- 	struct wpa_driver_nl80211_data *drv = bss->drv;
--	struct rtnl_neigh *rn;
--	struct nl_addr *nl_ipaddr;
--	int family, addrsize;
-+	struct ndmsg nhdr = {
-+		.ndm_state = NUD_PERMANENT,
-+		.ndm_ifindex = bss->br_ifindex,
-+	};
-+	struct nl_msg *msg;
-+	int addrsize;
- 	int res;
- 
- 	if (!ipaddr)
- 		return -EINVAL;
- 
- 	if (version == 4) {
--		family = AF_INET;
-+		nhdr.ndm_family = AF_INET;
- 		addrsize = 4;
- 	} else if (version == 6) {
--		family = AF_INET6;
-+		nhdr.ndm_family = AF_INET6;
- 		addrsize = 16;
- 	} else {
- 		return -EINVAL;
-@@ -10359,41 +10338,30 @@ static int wpa_driver_br_delete_ip_neigh
- 		return -1;
- 	}
- 
--	rn = rtnl_neigh_alloc();
--	if (rn == NULL)
-+	msg = nlmsg_alloc_simple(RTM_DELNEIGH, NLM_F_CREATE);
-+	if (!msg)
- 		return -ENOMEM;
- 
--	/* set the destination ip address for neigh */
--	nl_ipaddr = nl_addr_build(family, (void *) ipaddr, addrsize);
--	if (nl_ipaddr == NULL) {
--		wpa_printf(MSG_DEBUG, "nl80211: nl_ipaddr build failed");
--		res = -ENOMEM;
-+	res = -ENOMEM;
-+	if (nlmsg_append(msg, &nhdr, sizeof(nhdr), NLMSG_ALIGNTO) < 0)
- 		goto errout;
--	}
--	res = rtnl_neigh_set_dst(rn, nl_ipaddr);
--	if (res) {
--		wpa_printf(MSG_DEBUG,
--			   "nl80211: neigh set destination addr failed");
-+
-+	if (nla_put(msg, NDA_DST, addrsize, (void *)ipaddr))
- 		goto errout;
--	}
- 
--	rtnl_neigh_set_ifindex(rn, bss->br_ifindex);
-+	res = nl_send_auto_complete(drv->rtnl_sk, msg);
-+	if (res < 0)
-+		goto errout;
- 
--	res = rtnl_neigh_delete(drv->rtnl_sk, rn, 0);
-+	res = nl_wait_for_ack(drv->rtnl_sk);
- 	if (res) {
- 		wpa_printf(MSG_DEBUG,
- 			   "nl80211: Deleting bridge ip neigh failed: %s",
- 			   nl_geterror(res));
- 	}
- errout:
--	if (nl_ipaddr)
--		nl_addr_put(nl_ipaddr);
--	if (rn)
--		rtnl_neigh_put(rn);
-+	nlmsg_free(msg);
- 	return res;
--#else /* CONFIG_LIBNL3_ROUTE */
--	return -1;
--#endif /* CONFIG_LIBNL3_ROUTE */
- }
- 
- 
diff --git a/package/network/services/hostapd/patches/040-mesh-allow-processing-authentication-frames-in-block.patch b/package/network/services/hostapd/patches/040-mesh-allow-processing-authentication-frames-in-block.patch
deleted file mode 100644
index 55dd980cd7..0000000000
--- a/package/network/services/hostapd/patches/040-mesh-allow-processing-authentication-frames-in-block.patch
+++ /dev/null
@@ -1,34 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Date: Mon, 18 Feb 2019 12:57:11 +0100
-Subject: [PATCH] mesh: allow processing authentication frames in blocked state
-
-If authentication fails repeatedly e.g. because of a weak signal, the link
-can end up in blocked state. If one of the nodes tries to establish a link
-again before it is unblocked on the other side, it will block the link to
-that other side. The same happens on the other side when it unblocks the
-link. In that scenario, the link never recovers on its own.
-
-To fix this, allow restarting authentication even if the link is in blocked
-state, but don't initiate the attempt until the blocked period is over.
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
-
---- a/src/ap/ieee802_11.c
-+++ b/src/ap/ieee802_11.c
-@@ -2527,15 +2527,6 @@ static void handle_auth(struct hostapd_d
- 				       seq_ctrl);
- 			return;
- 		}
--#ifdef CONFIG_MESH
--		if ((hapd->conf->mesh & MESH_ENABLED) &&
--		    sta->plink_state == PLINK_BLOCKED) {
--			wpa_printf(MSG_DEBUG, "Mesh peer " MACSTR
--				   " is blocked - drop Authentication frame",
--				   MAC2STR(mgmt->sa));
--			return;
--		}
--#endif /* CONFIG_MESH */
- 	} else {
- #ifdef CONFIG_MESH
- 		if (hapd->conf->mesh & MESH_ENABLED) {
diff --git a/package/network/services/hostapd/patches/050-mesh-make-forwarding-configurable.patch b/package/network/services/hostapd/patches/050-mesh-make-forwarding-configurable.patch
deleted file mode 100644
index 4d64ec8287..0000000000
--- a/package/network/services/hostapd/patches/050-mesh-make-forwarding-configurable.patch
+++ /dev/null
@@ -1,219 +0,0 @@
-From 90fe6429624fc48bc0e5d2d7eeecb7498708b5e3 Mon Sep 17 00:00:00 2001
-From: Daniel Golle <daniel@makrotopia.org>
-Date: Wed, 18 Apr 2018 19:24:31 +0200
-Subject: [PATCH 18/18] mesh: make forwarding configurable
-
-Allow mesh_fwding to be specified in a mesh bss config, pass that
-to the driver (only nl80211 implemented for now) and announce
-forwarding capability accordingly.
-
-Signed-off-by: Daniel Golle <daniel@makrotopia.org>
----
- src/ap/ap_config.h                 | 2 ++
- src/drivers/driver.h               | 2 ++
- src/drivers/driver_nl80211.c       | 3 +++
- wpa_supplicant/config.c            | 4 ++++
- wpa_supplicant/config.h            | 9 +++++++++
- wpa_supplicant/config_file.c       | 4 ++++
- wpa_supplicant/config_ssid.h       | 5 +++++
- wpa_supplicant/mesh.c              | 6 ++++++
- wpa_supplicant/mesh_mpm.c          | 4 ++--
- wpa_supplicant/wpa_supplicant.conf | 3 +++
- 10 files changed, 40 insertions(+), 2 deletions(-)
-
---- a/src/ap/ap_config.h
-+++ b/src/ap/ap_config.h
-@@ -51,6 +51,7 @@ struct mesh_conf {
- 	int dot11MeshRetryTimeout; /* msec */
- 	int dot11MeshConfirmTimeout; /* msec */
- 	int dot11MeshHoldingTimeout; /* msec */
-+	int mesh_fwding;
- };
- 
- #define MAX_STA_COUNT 2007
-@@ -701,6 +702,7 @@ struct hostapd_bss_config {
- 
- #define MESH_ENABLED BIT(0)
- 	int mesh;
-+	int mesh_fwding;
- 
- 	u8 radio_measurements[RRM_CAPABILITIES_IE_LEN];
- 
---- a/src/drivers/driver.h
-+++ b/src/drivers/driver.h
-@@ -1515,6 +1515,7 @@ struct wpa_driver_mesh_bss_params {
- #define WPA_DRIVER_MESH_CONF_FLAG_MAX_PEER_LINKS	0x00000004
- #define WPA_DRIVER_MESH_CONF_FLAG_HT_OP_MODE		0x00000008
- #define WPA_DRIVER_MESH_CONF_FLAG_RSSI_THRESHOLD	0x00000010
-+#define WPA_DRIVER_MESH_CONF_FLAG_FORWARDING		0x00000020
- 	/*
- 	 * TODO: Other mesh configuration parameters would go here.
- 	 * See NL80211_MESHCONF_* for all the mesh config parameters.
-@@ -1524,6 +1525,7 @@ struct wpa_driver_mesh_bss_params {
- 	int peer_link_timeout;
- 	int max_peer_links;
- 	int rssi_threshold;
-+	int forwarding;
- 	u16 ht_opmode;
- };
- 
---- a/src/drivers/driver_nl80211.c
-+++ b/src/drivers/driver_nl80211.c
-@@ -10038,6 +10038,9 @@ static int nl80211_put_mesh_config(struc
- 	if (((params->flags & WPA_DRIVER_MESH_CONF_FLAG_AUTO_PLINKS) &&
- 	     nla_put_u8(msg, NL80211_MESHCONF_AUTO_OPEN_PLINKS,
- 			params->auto_plinks)) ||
-+	    ((params->flags & WPA_DRIVER_MESH_CONF_FLAG_FORWARDING) &&
-+	     nla_put_u8(msg, NL80211_MESHCONF_FORWARDING,
-+			params->forwarding)) ||
- 	    ((params->flags & WPA_DRIVER_MESH_CONF_FLAG_MAX_PEER_LINKS) &&
- 	     nla_put_u16(msg, NL80211_MESHCONF_MAX_PEER_LINKS,
- 			 params->max_peer_links)) ||
---- a/wpa_supplicant/config.c
-+++ b/wpa_supplicant/config.c
-@@ -2473,6 +2473,7 @@ static const struct parse_data ssid_fiel
- #ifdef CONFIG_MESH
- 	{ INT_RANGE(mode, 0, 5) },
- 	{ INT_RANGE(no_auto_peer, 0, 1) },
-+	{ INT_RANGE(mesh_fwding, 0, 1) },
- 	{ INT_RANGE(mesh_rssi_threshold, -255, 1) },
- #else /* CONFIG_MESH */
- 	{ INT_RANGE(mode, 0, 4) },
-@@ -3049,6 +3050,7 @@ void wpa_config_set_network_defaults(str
- 	ssid->dot11MeshRetryTimeout = DEFAULT_MESH_RETRY_TIMEOUT;
- 	ssid->dot11MeshConfirmTimeout = DEFAULT_MESH_CONFIRM_TIMEOUT;
- 	ssid->dot11MeshHoldingTimeout = DEFAULT_MESH_HOLDING_TIMEOUT;
-+	ssid->mesh_fwding = DEFAULT_MESH_FWDING;
- 	ssid->mesh_rssi_threshold = DEFAULT_MESH_RSSI_THRESHOLD;
- #endif /* CONFIG_MESH */
- #ifdef CONFIG_HT_OVERRIDES
-@@ -4276,6 +4278,7 @@ struct wpa_config * wpa_config_alloc_emp
- 	config->user_mpm = DEFAULT_USER_MPM;
- 	config->max_peer_links = DEFAULT_MAX_PEER_LINKS;
- 	config->mesh_max_inactivity = DEFAULT_MESH_MAX_INACTIVITY;
-+	config->mesh_fwding = DEFAULT_MESH_FWDING;
- 	config->dot11RSNASAERetransPeriod =
- 		DEFAULT_DOT11_RSNA_SAE_RETRANS_PERIOD;
- 	config->fast_reauth = DEFAULT_FAST_REAUTH;
-@@ -4914,6 +4917,7 @@ static const struct global_parse_data gl
- 	{ INT(user_mpm), 0 },
- 	{ INT_RANGE(max_peer_links, 0, 255), 0 },
- 	{ INT(mesh_max_inactivity), 0 },
-+	{ INT_RANGE(mesh_fwding, 0, 1), 0 },
- 	{ INT(dot11RSNASAERetransPeriod), 0 },
- #endif /* CONFIG_MESH */
- 	{ INT(disable_scan_offload), 0 },
---- a/wpa_supplicant/config.h
-+++ b/wpa_supplicant/config.h
-@@ -18,6 +18,7 @@
- #define DEFAULT_USER_MPM 1
- #define DEFAULT_MAX_PEER_LINKS 99
- #define DEFAULT_MESH_MAX_INACTIVITY 300
-+#define DEFAULT_MESH_FWDING 1
- /*
-  * The default dot11RSNASAERetransPeriod is defined as 40 ms in the standard,
-  * but use 1000 ms in practice to avoid issues on low power CPUs.
-@@ -1351,6 +1352,14 @@ struct wpa_config {
- 	int mesh_max_inactivity;
- 
- 	/**
-+	 * mesh_fwding - Mesh network layer-2 forwarding
-+	 *
-+	 * This controls whether to enable layer-2 forwarding.
-+	 * By default: 1: enabled
-+	 */
-+	int mesh_fwding;
-+
-+	/**
- 	 * dot11RSNASAERetransPeriod - Timeout to retransmit SAE Auth frame
- 	 *
- 	 * This timeout value is used in mesh STA to retransmit
---- a/wpa_supplicant/config_file.c
-+++ b/wpa_supplicant/config_file.c
-@@ -866,6 +866,7 @@ static void wpa_config_write_network(FIL
- #endif /* IEEE8021X_EAPOL */
- 	INT(mode);
- 	INT(no_auto_peer);
-+	INT(mesh_fwding);
- 	INT(frequency);
- 	INT(enable_edmg);
- 	INT(edmg_channel);
-@@ -1527,6 +1528,9 @@ static void wpa_config_write_global(FILE
- 		fprintf(f, "mesh_max_inactivity=%d\n",
- 			config->mesh_max_inactivity);
- 
-+	if (config->mesh_fwding != DEFAULT_MESH_FWDING)
-+		fprintf(f, "mesh_fwding=%d\n", config->mesh_fwding);
-+
- 	if (config->dot11RSNASAERetransPeriod !=
- 	    DEFAULT_DOT11_RSNA_SAE_RETRANS_PERIOD)
- 		fprintf(f, "dot11RSNASAERetransPeriod=%d\n",
---- a/wpa_supplicant/config_ssid.h
-+++ b/wpa_supplicant/config_ssid.h
-@@ -546,6 +546,11 @@ struct wpa_ssid {
- 	int dot11MeshConfirmTimeout; /* msec */
- 	int dot11MeshHoldingTimeout; /* msec */
- 
-+	/**
-+	 * Mesh network layer-2 forwarding
-+	 */
-+	int mesh_fwding;
-+
- 	int ht;
- 	int ht40;
- 
---- a/wpa_supplicant/mesh.c
-+++ b/wpa_supplicant/mesh.c
-@@ -137,6 +137,7 @@ static struct mesh_conf * mesh_config_cr
- 	conf->mesh_cc_id = 0;
- 	conf->mesh_sp_id = MESH_SYNC_METHOD_NEIGHBOR_OFFSET;
- 	conf->mesh_auth_id = (conf->security & MESH_CONF_SEC_AUTH) ? 1 : 0;
-+	conf->mesh_fwding = ssid->mesh_fwding;
- 	conf->dot11MeshMaxRetries = ssid->dot11MeshMaxRetries;
- 	conf->dot11MeshRetryTimeout = ssid->dot11MeshRetryTimeout;
- 	conf->dot11MeshConfirmTimeout = ssid->dot11MeshConfirmTimeout;
-@@ -434,6 +435,7 @@ static int wpa_supplicant_mesh_init(stru
- 	bss->conf->start_disabled = 1;
- 	bss->conf->mesh = MESH_ENABLED;
- 	bss->conf->ap_max_inactivity = wpa_s->conf->mesh_max_inactivity;
-+	bss->conf->mesh_fwding = wpa_s->conf->mesh_fwding;
- 
- 	if (ieee80211_is_dfs(ssid->frequency, wpa_s->hw.modes,
- 			     wpa_s->hw.num_modes) && wpa_s->conf->country[0]) {
-@@ -647,6 +649,10 @@ int wpa_supplicant_join_mesh(struct wpa_
- 	}
- 	params->conf.peer_link_timeout = wpa_s->conf->mesh_max_inactivity;
- 
-+	/* always explicitely set forwarding to on or off for now */
-+	params->conf.flags |= WPA_DRIVER_MESH_CONF_FLAG_FORWARDING;
-+	params->conf.forwarding = ssid->mesh_fwding;
-+
- 	os_free(wpa_s->mesh_params);
- 	wpa_s->mesh_params = params;
- 	if (wpa_supplicant_mesh_init(wpa_s, ssid, &params->freq)) {
---- a/wpa_supplicant/mesh_mpm.c
-+++ b/wpa_supplicant/mesh_mpm.c
-@@ -303,9 +303,9 @@ static void mesh_mpm_send_plink_action(s
- 		info = (bss->num_plinks > 63 ? 63 : bss->num_plinks) << 1;
- 		/* TODO: Add Connected to Mesh Gate/AS subfields */
- 		wpabuf_put_u8(buf, info);
--		/* always forwarding & accepting plinks for now */
-+		/* set forwarding & always accepting plinks for now */
- 		wpabuf_put_u8(buf, MESH_CAP_ACCEPT_ADDITIONAL_PEER |
--			      MESH_CAP_FORWARDING);
-+			      (conf->mesh_fwding ? MESH_CAP_FORWARDING : 0));
- 	} else {	/* Peer closing frame */
- 		/* IE: Mesh ID */
- 		wpabuf_put_u8(buf, WLAN_EID_MESH_ID);
---- a/wpa_supplicant/wpa_supplicant.conf
-+++ b/wpa_supplicant/wpa_supplicant.conf
-@@ -150,6 +150,9 @@ ap_scan=1
- # This timeout value is used in mesh STA to clean up inactive stations.
- #mesh_max_inactivity=300
- 
-+# Enable 802.11s layer-2 routing and forwarding
-+#mesh_fwding=1
-+
- # cert_in_cb - Whether to include a peer certificate dump in events
- # This controls whether peer certificates for authentication server and
- # its certificate chain are included in EAP peer certificate events. This is
diff --git a/package/network/services/hostapd/patches/060-P2P-Fix-a-corner-case-in-peer-addition-based-on-PD-R.patch b/package/network/services/hostapd/patches/060-P2P-Fix-a-corner-case-in-peer-addition-based-on-PD-R.patch
deleted file mode 100644
index 1202ff3725..0000000000
--- a/package/network/services/hostapd/patches/060-P2P-Fix-a-corner-case-in-peer-addition-based-on-PD-R.patch
+++ /dev/null
@@ -1,45 +0,0 @@
-From 8460e3230988ef2ec13ce6b69b687e941f6cdb32 Mon Sep 17 00:00:00 2001
-From: Jouni Malinen <jouni@codeaurora.org>
-Date: Tue, 8 Dec 2020 23:52:50 +0200
-Subject: [PATCH] P2P: Fix a corner case in peer addition based on PD Request
-
-p2p_add_device() may remove the oldest entry if there is no room in the
-peer table for a new peer. This would result in any pointer to that
-removed entry becoming stale. A corner case with an invalid PD Request
-frame could result in such a case ending up using (read+write) freed
-memory. This could only by triggered when the peer table has reached its
-maximum size and the PD Request frame is received from the P2P Device
-Address of the oldest remaining entry and the frame has incorrect P2P
-Device Address in the payload.
-
-Fix this by fetching the dev pointer again after having called
-p2p_add_device() so that the stale pointer cannot be used.
-
-Fixes: 17bef1e97a50 ("P2P: Add peer entry based on Provision Discovery Request")
-Signed-off-by: Jouni Malinen <jouni@codeaurora.org>
----
- src/p2p/p2p_pd.c | 12 +++++-------
- 1 file changed, 5 insertions(+), 7 deletions(-)
-
---- a/src/p2p/p2p_pd.c
-+++ b/src/p2p/p2p_pd.c
-@@ -595,14 +595,12 @@ void p2p_process_prov_disc_req(struct p2
- 			goto out;
- 		}
- 
-+		dev = p2p_get_device(p2p, sa);
- 		if (!dev) {
--			dev = p2p_get_device(p2p, sa);
--			if (!dev) {
--				p2p_dbg(p2p,
--					"Provision Discovery device not found "
--					MACSTR, MAC2STR(sa));
--				goto out;
--			}
-+			p2p_dbg(p2p,
-+				"Provision Discovery device not found "
-+				MACSTR, MAC2STR(sa));
-+			goto out;
- 		}
- 	} else if (msg.wfd_subelems) {
- 		wpabuf_free(dev->info.wfd_subelems);
diff --git a/package/network/services/hostapd/patches/100-daemonize_fix.patch b/package/network/services/hostapd/patches/100-daemonize_fix.patch
deleted file mode 100644
index 687bd4082d..0000000000
--- a/package/network/services/hostapd/patches/100-daemonize_fix.patch
+++ /dev/null
@@ -1,97 +0,0 @@
---- a/src/utils/os_unix.c
-+++ b/src/utils/os_unix.c
-@@ -10,6 +10,7 @@
- 
- #include <time.h>
- #include <sys/wait.h>
-+#include <fcntl.h>
- 
- #ifdef ANDROID
- #include <sys/capability.h>
-@@ -188,59 +189,46 @@ int os_gmtime(os_time_t t, struct os_tm
- 	return 0;
- }
- 
--
--#ifdef __APPLE__
--#include <fcntl.h>
--static int os_daemon(int nochdir, int noclose)
-+int os_daemonize(const char *pid_file)
- {
--	int devnull;
-+	int pid = 0, i, devnull;
- 
--	if (chdir("/") < 0)
--		return -1;
-+#if defined(__uClinux__) || defined(__sun__)
-+	return -1;
-+#else /* defined(__uClinux__) || defined(__sun__) */
- 
--	devnull = open("/dev/null", O_RDWR);
--	if (devnull < 0)
-+#ifndef __APPLE__
-+	pid = fork();
-+	if (pid < 0)
- 		return -1;
-+#endif
- 
--	if (dup2(devnull, STDIN_FILENO) < 0) {
--		close(devnull);
--		return -1;
-+	if (pid > 0) {
-+		if (pid_file) {
-+			FILE *f = fopen(pid_file, "w");
-+			if (f) {
-+				fprintf(f, "%u\n", pid);
-+				fclose(f);
-+			}
-+		}
-+		_exit(0);
- 	}
- 
--	if (dup2(devnull, STDOUT_FILENO) < 0) {
--		close(devnull);
-+	if (setsid() < 0)
- 		return -1;
--	}
- 
--	if (dup2(devnull, STDERR_FILENO) < 0) {
--		close(devnull);
-+	if (chdir("/") < 0)
- 		return -1;
--	}
--
--	return 0;
--}
--#else /* __APPLE__ */
--#define os_daemon daemon
--#endif /* __APPLE__ */
- 
--
--int os_daemonize(const char *pid_file)
--{
--#if defined(__uClinux__) || defined(__sun__)
--	return -1;
--#else /* defined(__uClinux__) || defined(__sun__) */
--	if (os_daemon(0, 0)) {
--		perror("daemon");
-+	devnull = open("/dev/null", O_RDWR);
-+	if (devnull < 0)
- 		return -1;
--	}
- 
--	if (pid_file) {
--		FILE *f = fopen(pid_file, "w");
--		if (f) {
--			fprintf(f, "%u\n", getpid());
--			fclose(f);
--		}
--	}
-+	for (i = 0; i <= STDERR_FILENO; i++)
-+		dup2(devnull, i);
-+
-+	if (devnull > 2)
-+		close(devnull);
- 
- 	return -0;
- #endif /* defined(__uClinux__) || defined(__sun__) */
diff --git a/package/network/services/hostapd/patches/110-notify-mgmt-frames.patch b/package/network/services/hostapd/patches/110-notify-mgmt-frames.patch
deleted file mode 100644
index c3a66a7115..0000000000
--- a/package/network/services/hostapd/patches/110-notify-mgmt-frames.patch
+++ /dev/null
@@ -1,116 +0,0 @@
-From 53f8fdb534d5222a0e852e38afde3f49832ace06 Mon Sep 17 00:00:00 2001
-From: =?UTF-8?q?Rapha=C3=ABl=20M=C3=A9lotte?= <raphael.melotte@mind.be>
-Date: Thu, 26 Nov 2020 09:27:40 +0100
-Subject: [PATCH] hostapd: Add an option to notify management frames on
- ctrl_iface
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-In some contexts (e.g. Multi-AP) it can be useful to have access to
-some of the management frames in upper layers (e.g. to be able to
-process the content of association requests externally).
-
-Add 'notify_mgmt_frames'. When enabled, it will notify the ctrl_iface
-when a management frame arrives using 'AP_MGMT_FRAME_RECEIVED'.
-
-Note that to avoid completely flooding the ctrl_iface, not all
-management frames are included (e.g. beacons are excluded).
-
-Signed-off-by: Raphaël Mélotte <raphael.melotte@mind.be>
----
- hostapd/config_file.c |  2 ++
- hostapd/hostapd.conf  |  4 ++++
- src/ap/ap_config.h    |  2 ++
- src/ap/ieee802_11.c   | 25 +++++++++++++++++++++++++
- src/common/wpa_ctrl.h |  3 +++
- 5 files changed, 36 insertions(+)
-
---- a/hostapd/config_file.c
-+++ b/hostapd/config_file.c
-@@ -4456,6 +4456,8 @@ static int hostapd_config_fill(struct ho
- 		bss->multicast_to_unicast = atoi(pos);
- 	} else if (os_strcmp(buf, "broadcast_deauth") == 0) {
- 		bss->broadcast_deauth = atoi(pos);
-+	} else if (os_strcmp(buf, "notify_mgmt_frames") == 0) {
-+		conf->notify_mgmt_frames = atoi(pos);
- #ifdef CONFIG_DPP
- 	} else if (os_strcmp(buf, "dpp_name") == 0) {
- 		os_free(bss->dpp_name);
---- a/hostapd/hostapd.conf
-+++ b/hostapd/hostapd.conf
-@@ -571,6 +571,10 @@ wmm_ac_vo_acm=0
- # Default: 1 (enabled)
- #broadcast_deauth=1
- 
-+# Get notifications for management frames:
-+# Default: 0 (disabled)
-+#notify_mgmt_frames=0
-+
- ##### IEEE 802.11n related configuration ######################################
- 
- # ieee80211n: Whether IEEE 802.11n (HT) is enabled
---- a/src/ap/ap_config.h
-+++ b/src/ap/ap_config.h
-@@ -1060,6 +1060,8 @@ struct hostapd_config {
- 	unsigned int airtime_update_interval;
- #define AIRTIME_MODE_MAX (__AIRTIME_MODE_MAX - 1)
- #endif /* CONFIG_AIRTIME_POLICY */
-+
-+	u8 notify_mgmt_frames;
- };
- 
- 
---- a/src/ap/ieee802_11.c
-+++ b/src/ap/ieee802_11.c
-@@ -4869,6 +4869,28 @@ static int handle_action(struct hostapd_
- 	return 1;
- }
- 
-+/**
-+ * notify_mgmt_frame - notify of management frames on the control interface.
-+ * @hapd: hostapd BSS data structure (the BSS to which the management frame was
-+ * sent to)
-+ * @buf: management frame data (starting from IEEE 802.11 header)
-+ * @len: length of frame data in octets
-+ *
-+ * Notify the control interface of any management frame.
-+ */
-+static void notify_mgmt_frame(struct hostapd_data *hapd, const u8 *buf,
-+			      size_t len)
-+{
-+
-+	int hex_len = len * 2 + 1;
-+	char *hex = os_malloc(hex_len);
-+
-+	if (hex) {
-+		wpa_snprintf_hex(hex, hex_len, buf, len);
-+		wpa_msg_ctrl(hapd->msg_ctx, MSG_INFO, AP_MGMT_FRAME_RECEIVED "buf=%s", hex);
-+		os_free(hex);
-+	}
-+}
- 
- /**
-  * ieee802_11_mgmt - process incoming IEEE 802.11 management frames
-@@ -4960,6 +4982,9 @@ int ieee802_11_mgmt(struct hostapd_data
- 	if (hapd->iconf->track_sta_max_num)
- 		sta_track_add(hapd->iface, mgmt->sa, ssi_signal);
- 
-+	if (hapd->iconf->notify_mgmt_frames)
-+		notify_mgmt_frame(hapd, buf, len);
-+
- 	switch (stype) {
- 	case WLAN_FC_STYPE_AUTH:
- 		wpa_printf(MSG_DEBUG, "mgmt::auth");
---- a/src/common/wpa_ctrl.h
-+++ b/src/common/wpa_ctrl.h
-@@ -396,6 +396,9 @@ extern "C" {
- #define BIT(x) (1U << (x))
- #endif
- 
-+/* Event triggered for received management frame */
-+#define AP_MGMT_FRAME_RECEIVED "AP-MGMT-FRAME-RECEIVED "
-+
- /* BSS command information masks */
- 
- #define WPA_BSS_MASK_ALL		0xFFFDFFFF
diff --git a/package/network/services/hostapd/patches/110-wolfssl-compile-fix.patch b/package/network/services/hostapd/patches/110-wolfssl-compile-fix.patch
deleted file mode 100644
index a7b5409602..0000000000
--- a/package/network/services/hostapd/patches/110-wolfssl-compile-fix.patch
+++ /dev/null
@@ -1,10 +0,0 @@
---- a/src/crypto/tls_wolfssl.c
-+++ b/src/crypto/tls_wolfssl.c
-@@ -19,6 +19,7 @@
- #include <wolfssl/ssl.h>
- #include <wolfssl/error-ssl.h>
- #include <wolfssl/wolfcrypt/asn.h>
-+#include <wolfssl/openssl/x509v3.h>
- 
- #if defined(EAP_FAST) || defined(EAP_FAST_DYNAMIC) || defined(EAP_SERVER_FAST)
- #define HAVE_AESGCM
diff --git a/package/network/services/hostapd/patches/120-reconfigure-wps-credentials.patch b/package/network/services/hostapd/patches/120-reconfigure-wps-credentials.patch
deleted file mode 100644
index 1826b6685b..0000000000
--- a/package/network/services/hostapd/patches/120-reconfigure-wps-credentials.patch
+++ /dev/null
@@ -1,178 +0,0 @@
-From b389a77a0f6dccf495dbce5be9476000f6ec06a2 Mon Sep 17 00:00:00 2001
-From: =?UTF-8?q?Rapha=C3=ABl=20M=C3=A9lotte?= <raphael.melotte@mind.be>
-Date: Wed, 9 Dec 2020 19:55:53 +0100
-Subject: [PATCH] wps: reconfigure credentials on reload
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-When new credentials are configured and hostapd is reconfigured using
-SIGHUP (or reload on the ctrl_iface), also update the wps credentials.
-
-Before these changes, when WPS is triggered the registar always serves
-the credentials that were configured when hostapd started.
-
-Signed-off-by: Raphaël Mélotte <raphael.melotte@mind.be>
----
- src/ap/wps_hostapd.c    | 86 +++++++++++++++++++++++++++++++++++++++--
- src/wps/wps.h           |  6 +++
- src/wps/wps_registrar.c | 29 ++++++++++++++
- 3 files changed, 118 insertions(+), 3 deletions(-)
-
---- a/src/ap/wps_hostapd.c
-+++ b/src/ap/wps_hostapd.c
-@@ -1375,6 +1375,43 @@ static void hostapd_wps_nfc_clear(struct
- #endif /* CONFIG_WPS_NFC */
- }
- 
-+int hostapd_wps_update_multi_ap(struct hostapd_data *hapd,
-+				struct wps_registrar *reg) {
-+	struct hostapd_bss_config *conf = hapd->conf;
-+	u8 *multi_ap_backhaul_network_key = NULL;
-+	size_t multi_ap_backhaul_network_key_len = 0;
-+	int ret = -1;
-+
-+	if ((conf->multi_ap & FRONTHAUL_BSS) &&
-+	    conf->multi_ap_backhaul_ssid.ssid_len) {
-+		if (conf->multi_ap_backhaul_ssid.wpa_passphrase) {
-+			multi_ap_backhaul_network_key =
-+				(u8 *) os_strdup(conf->multi_ap_backhaul_ssid.wpa_passphrase);
-+			if (multi_ap_backhaul_network_key == NULL)
-+				return -1;
-+			multi_ap_backhaul_network_key_len =
-+				os_strlen(conf->multi_ap_backhaul_ssid.wpa_passphrase);
-+		} else if (conf->multi_ap_backhaul_ssid.wpa_psk) {
-+			multi_ap_backhaul_network_key = os_malloc(2 * PMK_LEN + 1);
-+			if (multi_ap_backhaul_network_key == NULL)
-+				return -1;
-+			wpa_snprintf_hex((char *) multi_ap_backhaul_network_key,
-+					 2 * PMK_LEN + 1,
-+					 conf->multi_ap_backhaul_ssid.wpa_psk->psk,
-+					 PMK_LEN);
-+			multi_ap_backhaul_network_key_len = 2 * PMK_LEN;
-+		}
-+		ret = wps_registrar_update_multi_ap(reg,
-+						    conf->multi_ap_backhaul_ssid.ssid,
-+						    conf->multi_ap_backhaul_ssid.ssid_len,
-+						    multi_ap_backhaul_network_key,
-+						    multi_ap_backhaul_network_key_len);
-+		os_free(multi_ap_backhaul_network_key);
-+	}
-+	return ret;
-+}
-+
-+
- 
- void hostapd_deinit_wps(struct hostapd_data *hapd)
- {
-@@ -1409,11 +1446,54 @@ void hostapd_update_wps(struct hostapd_d
- 	hapd->wps->upc = hapd->conf->upc;
- #endif /* CONFIG_WPS_UPNP */
- 
--	hostapd_wps_set_vendor_ext(hapd, hapd->wps);
--	hostapd_wps_set_application_ext(hapd, hapd->wps);
-+	struct wps_context *wps = hapd->wps;
-+	struct hostapd_bss_config *conf = hapd->conf;
-+
-+	os_memcpy(wps->ssid, conf->ssid.ssid, conf->ssid.ssid_len);
-+	wps->ssid_len = conf->ssid.ssid_len;
-+
-+	/* Clear wps settings, then fill them again */
-+	os_free(wps->network_key);
-+	wps->network_key = NULL;
-+	wps->network_key_len = 0;
-+	wps->psk_set = 0;
-+	if (conf->ssid.wpa_psk_file) {
-+		/* Use per-device PSKs */
-+	} else if (conf->ssid.wpa_passphrase) {
-+		wps->network_key = (u8 *) os_strdup(conf->ssid.wpa_passphrase);
-+		if (wps->network_key == NULL)
-+			return;
-+		wps->network_key_len = os_strlen(conf->ssid.wpa_passphrase);
-+	} else if (conf->ssid.wpa_psk) {
-+		wps->network_key = os_malloc(2 * PMK_LEN + 1);
-+		if (wps->network_key == NULL)
-+			return;
-+		wpa_snprintf_hex((char *) wps->network_key, 2 * PMK_LEN + 1,
-+				 conf->ssid.wpa_psk->psk, PMK_LEN);
-+		wps->network_key_len = 2 * PMK_LEN;
-+#ifdef CONFIG_WEP
-+	} else if (conf->ssid.wep.keys_set && conf->ssid.wep.key[0]) {
-+		wps->network_key = os_malloc(conf->ssid.wep.len[0]);
-+		if (wps->network_key == NULL)
-+			return;
-+		os_memcpy(wps->network_key, conf->ssid.wep.key[0],
-+			  conf->ssid.wep.len[0]);
-+		wps->network_key_len = conf->ssid.wep.len[0];
-+#endif /* CONFIG_WEP */
-+	}
-+
-+	if (conf->ssid.wpa_psk) {
-+		os_memcpy(wps->psk, conf->ssid.wpa_psk->psk, PMK_LEN);
-+		wps->psk_set = 1;
-+	}
-+
-+	hostapd_wps_update_multi_ap(hapd, wps->registrar);
-+
-+	hostapd_wps_set_vendor_ext(hapd, wps);
-+	hostapd_wps_set_application_ext(hapd, wps);
- 
- 	if (hapd->conf->wps_state)
--		wps_registrar_update_ie(hapd->wps->registrar);
-+		wps_registrar_update_ie(wps->registrar);
- 	else
- 		hostapd_deinit_wps(hapd);
- }
---- a/src/wps/wps.h
-+++ b/src/wps/wps.h
-@@ -938,6 +938,12 @@ struct wpabuf * wps_build_nfc_handover_s
- 					       struct wpabuf *nfc_dh_pubkey,
- 					       struct wpabuf *nfc_dev_pw);
- 
-+int wps_registrar_update_multi_ap(struct wps_registrar *reg,
-+				  const u8 *multi_ap_backhaul_ssid,
-+				  size_t multi_ap_backhaul_ssid_len,
-+				  const u8 *multi_ap_backhaul_network_key,
-+				  size_t multi_ap_backhaul_network_key_len);
-+
- /* ndef.c */
- struct wpabuf * ndef_parse_wifi(const struct wpabuf *buf);
- struct wpabuf * ndef_build_wifi(const struct wpabuf *buf);
---- a/src/wps/wps_registrar.c
-+++ b/src/wps/wps_registrar.c
-@@ -3669,6 +3669,35 @@ int wps_registrar_config_ap(struct wps_r
- }
- 
- 
-+int wps_registrar_update_multi_ap(struct wps_registrar *reg,
-+				  const u8 *multi_ap_backhaul_ssid,
-+				  size_t multi_ap_backhaul_ssid_len,
-+				  const u8 *multi_ap_backhaul_network_key,
-+				  size_t multi_ap_backhaul_network_key_len)
-+{
-+	if (multi_ap_backhaul_ssid != NULL) {
-+		os_memcpy(reg->multi_ap_backhaul_ssid,
-+			  multi_ap_backhaul_ssid,
-+			  multi_ap_backhaul_ssid_len);
-+		reg->multi_ap_backhaul_ssid_len =
-+			multi_ap_backhaul_ssid_len;
-+	}
-+	os_free(reg->multi_ap_backhaul_network_key);
-+	reg->multi_ap_backhaul_network_key = NULL;
-+	reg->multi_ap_backhaul_network_key_len = 0;
-+
-+	if (multi_ap_backhaul_network_key != NULL) {
-+		reg->multi_ap_backhaul_network_key =
-+			os_memdup(multi_ap_backhaul_network_key,
-+				  multi_ap_backhaul_network_key_len);
-+		if (reg->multi_ap_backhaul_network_key == NULL)
-+			return -1;
-+		reg->multi_ap_backhaul_network_key_len =
-+			multi_ap_backhaul_network_key_len;
-+	}
-+	return 0;
-+}
-+
- #ifdef CONFIG_WPS_NFC
- 
- int wps_registrar_add_nfc_pw_token(struct wps_registrar *reg,
diff --git a/package/network/services/hostapd/patches/200-multicall.patch b/package/network/services/hostapd/patches/200-multicall.patch
deleted file mode 100644
index 9119a24c55..0000000000
--- a/package/network/services/hostapd/patches/200-multicall.patch
+++ /dev/null
@@ -1,355 +0,0 @@
---- a/hostapd/Makefile
-+++ b/hostapd/Makefile
-@@ -31,6 +31,7 @@ CFLAGS += -I$(abspath ../src/utils)
- export BINDIR ?= /usr/local/bin/
- 
- -include .config
-+-include $(if $(MULTICALL), ../wpa_supplicant/.config)
- 
- ifndef CONFIG_NO_GITVER
- # Add VERSION_STR postfix for builds from a git repository
-@@ -204,7 +205,8 @@ endif
- 
- ifdef CONFIG_NO_VLAN
- CFLAGS += -DCONFIG_NO_VLAN
--else
-+endif
-+ifneq ($(findstring CONFIG_NO_VLAN,$(CFLAGS)), CONFIG_NO_VLAN)
- OBJS += ../src/ap/vlan_init.o
- OBJS += ../src/ap/vlan_ifconfig.o
- OBJS += ../src/ap/vlan.o
-@@ -354,10 +356,14 @@ CFLAGS += -DCONFIG_MBO
- OBJS += ../src/ap/mbo_ap.o
- endif
- 
-+ifndef MULTICALL
-+CFLAGS += -DNO_SUPPLICANT
-+endif
-+
- include ../src/drivers/drivers.mak
--OBJS += $(DRV_AP_OBJS)
--CFLAGS += $(DRV_AP_CFLAGS)
--LDFLAGS += $(DRV_AP_LDFLAGS)
-+OBJS += $(sort $(DRV_AP_OBJS) $(if $(MULTICALL),$(DRV_WPA_OBJS)))
-+CFLAGS += $(DRV_AP_CFLAGS) $(if $(MULTICALL),$(DRV_WPA_CFLAGS))
-+LDFLAGS += $(DRV_AP_LDFLAGS) $(if $(MULTICALL),$(DRV_WPA_LDFLAGS))
- LIBS += $(DRV_AP_LIBS)
- 
- ifdef CONFIG_L2_PACKET
-@@ -1311,6 +1317,12 @@ install: $(addprefix $(DESTDIR)$(BINDIR)
- 
- BCHECK=../src/drivers/build.hostapd
- 
-+hostapd_multi.a: $(BCHECK) $(OBJS)
-+	$(Q)$(CC) -c -o hostapd_multi.o -Dmain=hostapd_main $(CFLAGS) main.c
-+	@$(E) "  CC " $<
-+	@rm -f $@
-+	@$(AR) cr $@ hostapd_multi.o $(OBJS)
-+
- hostapd: $(BCHECK) $(OBJS)
- 	$(Q)$(CC) $(LDFLAGS) -o hostapd $(OBJS) $(LIBS)
- 	@$(E) "  LD " $@
-@@ -1374,6 +1386,12 @@ SOBJS += ../src/crypto/sha256-kdf.o
- SOBJS += ../src/crypto/sha384-kdf.o
- SOBJS += ../src/crypto/sha512-kdf.o
- 
-+dump_cflags:
-+	@printf "%s " "$(CFLAGS)"
-+
-+dump_ldflags:
-+	@printf "%s " "$(LDFLAGS) $(LIBS) $(EXTRALIBS)"
-+
- nt_password_hash: $(NOBJS)
- 	$(Q)$(CC) $(LDFLAGS) -o nt_password_hash $(NOBJS) $(LIBS_n)
- 	@$(E) "  LD " $@
---- a/wpa_supplicant/Makefile
-+++ b/wpa_supplicant/Makefile
-@@ -27,6 +27,7 @@ CFLAGS += -I$(abspath ../src)
- CFLAGS += -I$(abspath ../src/utils)
- 
- -include .config
-+-include $(if $(MULTICALL),../hostapd/.config)
- 
- ifndef CONFIG_NO_GITVER
- # Add VERSION_STR postfix for builds from a git repository
-@@ -369,7 +370,9 @@ endif
- ifdef CONFIG_IBSS_RSN
- NEED_RSN_AUTHENTICATOR=y
- CFLAGS += -DCONFIG_IBSS_RSN
-+ifndef MULTICALL
- CFLAGS += -DCONFIG_NO_VLAN
-+endif
- OBJS += ibss_rsn.o
- endif
- 
-@@ -890,6 +893,10 @@ ifdef CONFIG_DYNAMIC_EAP_METHODS
- CFLAGS += -DCONFIG_DYNAMIC_EAP_METHODS
- LIBS += -ldl -rdynamic
- endif
-+else
-+  ifdef MULTICALL
-+    OBJS += ../src/eap_common/eap_common.o
-+  endif
- endif
- 
- ifdef CONFIG_AP
-@@ -897,9 +904,11 @@ NEED_EAP_COMMON=y
- NEED_RSN_AUTHENTICATOR=y
- CFLAGS += -DCONFIG_AP
- OBJS += ap.o
-+ifndef MULTICALL
- CFLAGS += -DCONFIG_NO_RADIUS
- CFLAGS += -DCONFIG_NO_ACCOUNTING
- CFLAGS += -DCONFIG_NO_VLAN
-+endif
- OBJS += ../src/ap/hostapd.o
- OBJS += ../src/ap/wpa_auth_glue.o
- OBJS += ../src/ap/utils.o
-@@ -979,6 +988,12 @@ endif
- ifdef CONFIG_HS20
- OBJS += ../src/ap/hs20.o
- endif
-+else
-+  ifdef MULTICALL
-+    OBJS += ../src/eap_server/eap_server.o
-+    OBJS += ../src/eap_server/eap_server_identity.o
-+    OBJS += ../src/eap_server/eap_server_methods.o
-+  endif
- endif
- 
- ifdef CONFIG_MBO
-@@ -987,7 +1002,9 @@ CFLAGS += -DCONFIG_MBO
- endif
- 
- ifdef NEED_RSN_AUTHENTICATOR
-+ifndef MULTICALL
- CFLAGS += -DCONFIG_NO_RADIUS
-+endif
- NEED_AES_WRAP=y
- OBJS += ../src/ap/wpa_auth.o
- OBJS += ../src/ap/wpa_auth_ie.o
-@@ -1897,6 +1914,12 @@ wpa_priv: $(BCHECK) $(OBJS_priv)
- 
- $(OBJS_c) $(OBJS_t) $(OBJS_t2) $(OBJS) $(BCHECK) $(EXTRA_progs): .config
- 
-+wpa_supplicant_multi.a: .config $(BCHECK) $(OBJS) $(EXTRA_progs)
-+	$(Q)$(CC) -c -o wpa_supplicant_multi.o -Dmain=wpa_supplicant_main $(CFLAGS) main.c
-+	@$(E) "  CC " $<
-+	@rm -f $@
-+	@$(AR) cr $@ wpa_supplicant_multi.o $(OBJS)
-+
- wpa_supplicant: $(BCHECK) $(OBJS) $(EXTRA_progs)
- 	$(Q)$(LDO) $(LDFLAGS) -o wpa_supplicant $(OBJS) $(LIBS) $(EXTRALIBS)
- 	@$(E) "  LD " $@
-@@ -1997,6 +2020,12 @@ endif
- 	$(Q)sed -e 's|\@BINDIR\@|$(BINDIR)|g' $< >$@
- 	@$(E) "  sed" $<
- 
-+dump_cflags:
-+	@printf "%s " "$(CFLAGS)"
-+
-+dump_ldflags:
-+	@printf "%s " "$(LDFLAGS) $(LIBS) $(EXTRALIBS)"
-+
- wpa_supplicant.exe: wpa_supplicant
- 	mv -f $< $@
- wpa_cli.exe: wpa_cli
---- a/src/drivers/driver.h
-+++ b/src/drivers/driver.h
-@@ -5886,8 +5886,8 @@ union wpa_event_data {
-  * Driver wrapper code should call this function whenever an event is received
-  * from the driver.
-  */
--void wpa_supplicant_event(void *ctx, enum wpa_event_type event,
--			  union wpa_event_data *data);
-+extern void (*wpa_supplicant_event)(void *ctx, enum wpa_event_type event,
-+				    union wpa_event_data *data);
- 
- /**
-  * wpa_supplicant_event_global - Report a driver event for wpa_supplicant
-@@ -5899,7 +5899,7 @@ void wpa_supplicant_event(void *ctx, enu
-  * Same as wpa_supplicant_event(), but we search for the interface in
-  * wpa_global.
-  */
--void wpa_supplicant_event_global(void *ctx, enum wpa_event_type event,
-+extern void (*wpa_supplicant_event_global)(void *ctx, enum wpa_event_type event,
- 				 union wpa_event_data *data);
- 
- /*
---- a/src/ap/drv_callbacks.c
-+++ b/src/ap/drv_callbacks.c
-@@ -1789,8 +1789,8 @@ err:
- #endif /* CONFIG_OWE */
- 
- 
--void wpa_supplicant_event(void *ctx, enum wpa_event_type event,
--			  union wpa_event_data *data)
-+void hostapd_wpa_event(void *ctx, enum wpa_event_type event,
-+		       union wpa_event_data *data)
- {
- 	struct hostapd_data *hapd = ctx;
- #ifndef CONFIG_NO_STDOUT_DEBUG
-@@ -2035,7 +2035,7 @@ void wpa_supplicant_event(void *ctx, enu
- }
- 
- 
--void wpa_supplicant_event_global(void *ctx, enum wpa_event_type event,
-+void hostapd_wpa_event_global(void *ctx, enum wpa_event_type event,
- 				 union wpa_event_data *data)
- {
- 	struct hapd_interfaces *interfaces = ctx;
---- a/wpa_supplicant/wpa_priv.c
-+++ b/wpa_supplicant/wpa_priv.c
-@@ -1038,8 +1038,8 @@ static void wpa_priv_send_ft_response(st
- }
- 
- 
--void wpa_supplicant_event(void *ctx, enum wpa_event_type event,
--			  union wpa_event_data *data)
-+static void supplicant_event(void *ctx, enum wpa_event_type event,
-+			     union wpa_event_data *data)
- {
- 	struct wpa_priv_interface *iface = ctx;
- 
-@@ -1102,7 +1102,7 @@ void wpa_supplicant_event(void *ctx, enu
- }
- 
- 
--void wpa_supplicant_event_global(void *ctx, enum wpa_event_type event,
-+void supplicant_event_global(void *ctx, enum wpa_event_type event,
- 				 union wpa_event_data *data)
- {
- 	struct wpa_priv_global *global = ctx;
-@@ -1215,6 +1215,8 @@ int main(int argc, char *argv[])
- 	if (os_program_init())
- 		return -1;
- 
-+	wpa_supplicant_event = supplicant_event;
-+	wpa_supplicant_event_global = supplicant_event_global;
- 	wpa_priv_fd_workaround();
- 
- 	os_memset(&global, 0, sizeof(global));
---- a/wpa_supplicant/events.c
-+++ b/wpa_supplicant/events.c
-@@ -4579,8 +4579,8 @@ static void wpas_event_unprot_beacon(str
- }
- 
- 
--void wpa_supplicant_event(void *ctx, enum wpa_event_type event,
--			  union wpa_event_data *data)
-+void supplicant_event(void *ctx, enum wpa_event_type event,
-+		      union wpa_event_data *data)
- {
- 	struct wpa_supplicant *wpa_s = ctx;
- 	int resched;
-@@ -5398,7 +5398,7 @@ void wpa_supplicant_event(void *ctx, enu
- }
- 
- 
--void wpa_supplicant_event_global(void *ctx, enum wpa_event_type event,
-+void supplicant_event_global(void *ctx, enum wpa_event_type event,
- 				 union wpa_event_data *data)
- {
- 	struct wpa_supplicant *wpa_s;
---- a/wpa_supplicant/wpa_supplicant.c
-+++ b/wpa_supplicant/wpa_supplicant.c
-@@ -6594,7 +6594,6 @@ struct wpa_interface * wpa_supplicant_ma
- 	return NULL;
- }
- 
--
- /**
-  * wpa_supplicant_match_existing - Match existing interfaces
-  * @global: Pointer to global data from wpa_supplicant_init()
-@@ -6631,6 +6630,11 @@ static int wpa_supplicant_match_existing
- 
- #endif /* CONFIG_MATCH_IFACE */
- 
-+extern void supplicant_event(void *ctx, enum wpa_event_type event,
-+			     union wpa_event_data *data);
-+
-+extern void supplicant_event_global(void *ctx, enum wpa_event_type event,
-+ 				 union wpa_event_data *data);
- 
- /**
-  * wpa_supplicant_add_iface - Add a new network interface
-@@ -6887,6 +6891,8 @@ struct wpa_global * wpa_supplicant_init(
- #ifndef CONFIG_NO_WPA_MSG
- 	wpa_msg_register_ifname_cb(wpa_supplicant_msg_ifname_cb);
- #endif /* CONFIG_NO_WPA_MSG */
-+	wpa_supplicant_event = supplicant_event;
-+	wpa_supplicant_event_global = supplicant_event_global;
- 
- 	if (params->wpa_debug_file_path)
- 		wpa_debug_open_file(params->wpa_debug_file_path);
---- a/hostapd/main.c
-+++ b/hostapd/main.c
-@@ -590,6 +590,11 @@ fail:
- 	return -1;
- }
- 
-+void hostapd_wpa_event(void *ctx, enum wpa_event_type event,
-+                       union wpa_event_data *data);
-+
-+void hostapd_wpa_event_global(void *ctx, enum wpa_event_type event,
-+ 				 union wpa_event_data *data);
- 
- #ifdef CONFIG_WPS
- static int gen_uuid(const char *txt_addr)
-@@ -684,6 +689,8 @@ int main(int argc, char *argv[])
- 		return -1;
- #endif /* CONFIG_DPP */
- 
-+	wpa_supplicant_event = hostapd_wpa_event;
-+	wpa_supplicant_event_global = hostapd_wpa_event_global;
- 	for (;;) {
- 		c = getopt(argc, argv, "b:Bde:f:hi:KP:sSTtu:vg:G:");
- 		if (c < 0)
---- a/src/drivers/drivers.c
-+++ b/src/drivers/drivers.c
-@@ -10,6 +10,10 @@
- #include "utils/common.h"
- #include "driver.h"
- 
-+void (*wpa_supplicant_event)(void *ctx, enum wpa_event_type event,
-+			     union wpa_event_data *data);
-+void (*wpa_supplicant_event_global)(void *ctx, enum wpa_event_type event,
-+			     union wpa_event_data *data);
- 
- const struct wpa_driver_ops *const wpa_drivers[] =
- {
---- a/wpa_supplicant/eapol_test.c
-+++ b/wpa_supplicant/eapol_test.c
-@@ -30,7 +30,12 @@
- #include "ctrl_iface.h"
- #include "pcsc_funcs.h"
- #include "wpas_glue.h"
-+#include "drivers/driver.h"
- 
-+void (*wpa_supplicant_event)(void *ctx, enum wpa_event_type event,
-+			     union wpa_event_data *data);
-+void (*wpa_supplicant_event_global)(void *ctx, enum wpa_event_type event,
-+			     union wpa_event_data *data);
- 
- const struct wpa_driver_ops *const wpa_drivers[] = { NULL };
- 
-@@ -1292,6 +1297,10 @@ static void usage(void)
- 	       "option several times.\n");
- }
- 
-+extern void supplicant_event(void *ctx, enum wpa_event_type event,
-+			     union wpa_event_data *data);
-+extern void supplicant_event_global(void *ctx, enum wpa_event_type event,
-+			     union wpa_event_data *data);
- 
- int main(int argc, char *argv[])
- {
-@@ -1312,6 +1321,8 @@ int main(int argc, char *argv[])
- 	if (os_program_init())
- 		return -1;
- 
-+	wpa_supplicant_event = supplicant_event;
-+	wpa_supplicant_event_global = supplicant_event_global;
- 	hostapd_logger_register_cb(hostapd_logger_cb);
- 
- 	os_memset(&eapol_test, 0, sizeof(eapol_test));
diff --git a/package/network/services/hostapd/patches/300-noscan.patch b/package/network/services/hostapd/patches/300-noscan.patch
deleted file mode 100644
index 638b76f84e..0000000000
--- a/package/network/services/hostapd/patches/300-noscan.patch
+++ /dev/null
@@ -1,58 +0,0 @@
---- a/hostapd/config_file.c
-+++ b/hostapd/config_file.c
-@@ -3493,6 +3493,10 @@ static int hostapd_config_fill(struct ho
- 		if (bss->ocv && !bss->ieee80211w)
- 			bss->ieee80211w = 1;
- #endif /* CONFIG_OCV */
-+	} else if (os_strcmp(buf, "noscan") == 0) {
-+		conf->noscan = atoi(pos);
-+	} else if (os_strcmp(buf, "ht_coex") == 0) {
-+		conf->no_ht_coex = !atoi(pos);
- 	} else if (os_strcmp(buf, "ieee80211n") == 0) {
- 		conf->ieee80211n = atoi(pos);
- 	} else if (os_strcmp(buf, "ht_capab") == 0) {
---- a/src/ap/ap_config.h
-+++ b/src/ap/ap_config.h
-@@ -984,6 +984,8 @@ struct hostapd_config {
- 
- 	int ht_op_mode_fixed;
- 	u16 ht_capab;
-+	int noscan;
-+	int no_ht_coex;
- 	int ieee80211n;
- 	int secondary_channel;
- 	int no_pri_sec_switch;
---- a/src/ap/hw_features.c
-+++ b/src/ap/hw_features.c
-@@ -500,7 +500,8 @@ static int ieee80211n_check_40mhz(struct
- 	int ret;
- 
- 	/* Check that HT40 is used and PRI / SEC switch is allowed */
--	if (!iface->conf->secondary_channel || iface->conf->no_pri_sec_switch)
-+	if (!iface->conf->secondary_channel || iface->conf->no_pri_sec_switch ||
-+		iface->conf->noscan)
- 		return 0;
- 
- 	hostapd_set_state(iface, HAPD_IFACE_HT_SCAN);
---- a/src/ap/ieee802_11_ht.c
-+++ b/src/ap/ieee802_11_ht.c
-@@ -230,6 +230,9 @@ void hostapd_2040_coex_action(struct hos
- 		return;
- 	}
- 
-+	if (iface->conf->noscan || iface->conf->no_ht_coex)
-+		return;
-+
- 	if (len < IEEE80211_HDRLEN + 2 + sizeof(*bc_ie)) {
- 		wpa_printf(MSG_DEBUG,
- 			   "Ignore too short 20/40 BSS Coexistence Management frame");
-@@ -390,6 +393,9 @@ void ht40_intolerant_add(struct hostapd_
- 	if (iface->current_mode->mode != HOSTAPD_MODE_IEEE80211G)
- 		return;
- 
-+	if (iface->conf->noscan || iface->conf->no_ht_coex)
-+		return;
-+
- 	wpa_printf(MSG_INFO, "HT: Forty MHz Intolerant is set by STA " MACSTR
- 		   " in Association Request", MAC2STR(sta->addr));
- 
diff --git a/package/network/services/hostapd/patches/301-mesh-noscan.patch b/package/network/services/hostapd/patches/301-mesh-noscan.patch
deleted file mode 100644
index f85b72453e..0000000000
--- a/package/network/services/hostapd/patches/301-mesh-noscan.patch
+++ /dev/null
@@ -1,68 +0,0 @@
---- a/wpa_supplicant/config.c
-+++ b/wpa_supplicant/config.c
-@@ -2478,6 +2478,7 @@ static const struct parse_data ssid_fiel
- #else /* CONFIG_MESH */
- 	{ INT_RANGE(mode, 0, 4) },
- #endif /* CONFIG_MESH */
-+	{ INT_RANGE(noscan, 0, 1) },
- 	{ INT_RANGE(proactive_key_caching, 0, 1) },
- 	{ INT_RANGE(disabled, 0, 2) },
- 	{ STR(id_str) },
---- a/wpa_supplicant/config_file.c
-+++ b/wpa_supplicant/config_file.c
-@@ -866,6 +866,7 @@ static void wpa_config_write_network(FIL
- #endif /* IEEE8021X_EAPOL */
- 	INT(mode);
- 	INT(no_auto_peer);
-+	INT(noscan);
- 	INT(mesh_fwding);
- 	INT(frequency);
- 	INT(enable_edmg);
---- a/wpa_supplicant/mesh.c
-+++ b/wpa_supplicant/mesh.c
-@@ -467,6 +467,8 @@ static int wpa_supplicant_mesh_init(stru
- 			   frequency);
- 		goto out_free;
- 	}
-+	if (ssid->noscan)
-+		conf->noscan = 1;
- 
- 	if (ssid->mesh_basic_rates == NULL) {
- 		/*
---- a/wpa_supplicant/wpa_supplicant.c
-+++ b/wpa_supplicant/wpa_supplicant.c
-@@ -2334,12 +2334,12 @@ void ibss_mesh_setup_freq(struct wpa_sup
- 	int ieee80211_mode = wpas_mode_to_ieee80211_mode(ssid->mode);
- 	enum hostapd_hw_mode hw_mode;
- 	struct hostapd_hw_modes *mode = NULL;
--	int ht40plus[] = { 36, 44, 52, 60, 100, 108, 116, 124, 132, 149, 157,
-+	int ht40plus[] = { 1, 2, 3, 4, 5, 6, 36, 44, 52, 60, 100, 108, 116, 124, 132, 149, 157,
- 			   184, 192 };
- 	int vht80[] = { 36, 52, 100, 116, 132, 149 };
- 	struct hostapd_channel_data *pri_chan = NULL, *sec_chan = NULL;
- 	u8 channel;
--	int i, chan_idx, ht40 = -1, res, obss_scan = 1;
-+	int i, chan_idx, ht40 = -1, res, obss_scan = !(ssid->noscan);
- 	unsigned int j, k;
- 	struct hostapd_freq_params vht_freq;
- 	int chwidth, seg0, seg1;
-@@ -2421,7 +2421,7 @@ void ibss_mesh_setup_freq(struct wpa_sup
- #endif /* CONFIG_HE_OVERRIDES */
- 
- 	/* Setup higher BW only for 5 GHz */
--	if (mode->mode != HOSTAPD_MODE_IEEE80211A)
-+	if (mode->mode != HOSTAPD_MODE_IEEE80211A && !(ssid->noscan))
- 		return;
- 
- 	for (chan_idx = 0; chan_idx < mode->num_channels; chan_idx++) {
---- a/wpa_supplicant/config_ssid.h
-+++ b/wpa_supplicant/config_ssid.h
-@@ -971,6 +971,8 @@ struct wpa_ssid {
- 	 */
- 	int no_auto_peer;
- 
-+	int noscan;
-+
- 	/**
- 	 * mesh_rssi_threshold - Set mesh parameter mesh_rssi_threshold (dBm)
- 	 *
diff --git a/package/network/services/hostapd/patches/310-rescan_immediately.patch b/package/network/services/hostapd/patches/310-rescan_immediately.patch
deleted file mode 100644
index 0040b61c6b..0000000000
--- a/package/network/services/hostapd/patches/310-rescan_immediately.patch
+++ /dev/null
@@ -1,11 +0,0 @@
---- a/wpa_supplicant/wpa_supplicant.c
-+++ b/wpa_supplicant/wpa_supplicant.c
-@@ -4949,7 +4949,7 @@ wpa_supplicant_alloc(struct wpa_supplica
- 	if (wpa_s == NULL)
- 		return NULL;
- 	wpa_s->scan_req = INITIAL_SCAN_REQ;
--	wpa_s->scan_interval = 5;
-+	wpa_s->scan_interval = 1;
- 	wpa_s->new_connection = 1;
- 	wpa_s->parent = parent ? parent : wpa_s;
- 	wpa_s->p2pdev = wpa_s->parent;
diff --git a/package/network/services/hostapd/patches/320-optional_rfkill.patch b/package/network/services/hostapd/patches/320-optional_rfkill.patch
deleted file mode 100644
index a703c7e132..0000000000
--- a/package/network/services/hostapd/patches/320-optional_rfkill.patch
+++ /dev/null
@@ -1,61 +0,0 @@
---- a/src/drivers/drivers.mak
-+++ b/src/drivers/drivers.mak
-@@ -50,7 +50,6 @@ NEED_SME=y
- NEED_AP_MLME=y
- NEED_NETLINK=y
- NEED_LINUX_IOCTL=y
--NEED_RFKILL=y
- NEED_RADIOTAP=y
- NEED_LIBNL=y
- endif
-@@ -107,7 +106,6 @@ DRV_WPA_CFLAGS += -DCONFIG_DRIVER_WEXT
- CONFIG_WIRELESS_EXTENSION=y
- NEED_NETLINK=y
- NEED_LINUX_IOCTL=y
--NEED_RFKILL=y
- endif
- 
- ifdef CONFIG_DRIVER_NDIS
-@@ -133,7 +131,6 @@ endif
- ifdef CONFIG_WIRELESS_EXTENSION
- DRV_WPA_CFLAGS += -DCONFIG_WIRELESS_EXTENSION
- DRV_WPA_OBJS += ../src/drivers/driver_wext.o
--NEED_RFKILL=y
- endif
- 
- ifdef NEED_NETLINK
-@@ -142,6 +139,7 @@ endif
- 
- ifdef NEED_RFKILL
- DRV_OBJS += ../src/drivers/rfkill.o
-+DRV_WPA_CFLAGS += -DCONFIG_RFKILL
- endif
- 
- ifdef NEED_RADIOTAP
---- a/src/drivers/rfkill.h
-+++ b/src/drivers/rfkill.h
-@@ -18,8 +18,24 @@ struct rfkill_config {
- 	void (*unblocked_cb)(void *ctx);
- };
- 
-+#ifdef CONFIG_RFKILL
- struct rfkill_data * rfkill_init(struct rfkill_config *cfg);
- void rfkill_deinit(struct rfkill_data *rfkill);
- int rfkill_is_blocked(struct rfkill_data *rfkill);
-+#else
-+static inline struct rfkill_data * rfkill_init(struct rfkill_config *cfg)
-+{
-+	return (void *) 1;
-+}
-+
-+static inline void rfkill_deinit(struct rfkill_data *rfkill)
-+{
-+}
-+
-+static inline int rfkill_is_blocked(struct rfkill_data *rfkill)
-+{
-+	return 0;
-+}
-+#endif
- 
- #endif /* RFKILL_H */
diff --git a/package/network/services/hostapd/patches/330-nl80211_fix_set_freq.patch b/package/network/services/hostapd/patches/330-nl80211_fix_set_freq.patch
deleted file mode 100644
index ccd8589728..0000000000
--- a/package/network/services/hostapd/patches/330-nl80211_fix_set_freq.patch
+++ /dev/null
@@ -1,11 +0,0 @@
---- a/src/drivers/driver_nl80211.c
-+++ b/src/drivers/driver_nl80211.c
-@@ -4661,7 +4661,7 @@ static int nl80211_set_channel(struct i8
- 		   freq->freq, freq->ht_enabled, freq->vht_enabled, freq->he_enabled,
- 		   freq->bandwidth, freq->center_freq1, freq->center_freq2);
- 
--	msg = nl80211_drv_msg(drv, 0, set_chan ? NL80211_CMD_SET_CHANNEL :
-+	msg = nl80211_bss_msg(bss, 0, set_chan ? NL80211_CMD_SET_CHANNEL :
- 			      NL80211_CMD_SET_WIPHY);
- 	if (!msg || nl80211_put_freq_params(msg, freq) < 0) {
- 		nlmsg_free(msg);
diff --git a/package/network/services/hostapd/patches/340-reload_freq_change.patch b/package/network/services/hostapd/patches/340-reload_freq_change.patch
deleted file mode 100644
index e0e62c2a11..0000000000
--- a/package/network/services/hostapd/patches/340-reload_freq_change.patch
+++ /dev/null
@@ -1,75 +0,0 @@
---- a/src/ap/hostapd.c
-+++ b/src/ap/hostapd.c
-@@ -114,6 +114,28 @@ static void hostapd_reload_bss(struct ho
- #endif /* CONFIG_NO_RADIUS */
- 
- 	ssid = &hapd->conf->ssid;
-+
-+	hostapd_set_freq(hapd, hapd->iconf->hw_mode, hapd->iface->freq,
-+			 hapd->iconf->channel,
-+			 hapd->iconf->enable_edmg,
-+			 hapd->iconf->edmg_channel,
-+			 hapd->iconf->ieee80211n,
-+			 hapd->iconf->ieee80211ac,
-+			 hapd->iconf->ieee80211ax,
-+			 hapd->iconf->secondary_channel,
-+			 hostapd_get_oper_chwidth(hapd->iconf),
-+			 hostapd_get_oper_centr_freq_seg0_idx(hapd->iconf),
-+			 hostapd_get_oper_centr_freq_seg1_idx(hapd->iconf));
-+
-+	if (hapd->iface->current_mode) {
-+		if (hostapd_prepare_rates(hapd->iface, hapd->iface->current_mode)) {
-+			wpa_printf(MSG_ERROR, "Failed to prepare rates table.");
-+			hostapd_logger(hapd, NULL, HOSTAPD_MODULE_IEEE80211,
-+				       HOSTAPD_LEVEL_WARNING,
-+				       "Failed to prepare rates table.");
-+		}
-+	}
-+
- 	if (!ssid->wpa_psk_set && ssid->wpa_psk && !ssid->wpa_psk->next &&
- 	    ssid->wpa_passphrase_set && ssid->wpa_passphrase) {
- 		/*
-@@ -215,6 +237,7 @@ int hostapd_reload_config(struct hostapd
- 	struct hostapd_data *hapd = iface->bss[0];
- 	struct hostapd_config *newconf, *oldconf;
- 	size_t j;
-+	int i;
- 
- 	if (iface->config_fname == NULL) {
- 		/* Only in-memory config in use - assume it has been updated */
-@@ -265,24 +288,20 @@ int hostapd_reload_config(struct hostapd
- 	}
- 	iface->conf = newconf;
- 
-+	for (i = 0; i < iface->num_hw_features; i++) {
-+		struct hostapd_hw_modes *mode = &iface->hw_features[i];
-+		if (mode->mode == iface->conf->hw_mode) {
-+			iface->current_mode = mode;
-+			break;
-+		}
-+	}
-+
-+	if (iface->conf->channel)
-+		iface->freq = hostapd_hw_get_freq(hapd, iface->conf->channel);
-+
- 	for (j = 0; j < iface->num_bss; j++) {
- 		hapd = iface->bss[j];
- 		hapd->iconf = newconf;
--		hapd->iconf->channel = oldconf->channel;
--		hapd->iconf->acs = oldconf->acs;
--		hapd->iconf->secondary_channel = oldconf->secondary_channel;
--		hapd->iconf->ieee80211n = oldconf->ieee80211n;
--		hapd->iconf->ieee80211ac = oldconf->ieee80211ac;
--		hapd->iconf->ht_capab = oldconf->ht_capab;
--		hapd->iconf->vht_capab = oldconf->vht_capab;
--		hostapd_set_oper_chwidth(hapd->iconf,
--					 hostapd_get_oper_chwidth(oldconf));
--		hostapd_set_oper_centr_freq_seg0_idx(
--			hapd->iconf,
--			hostapd_get_oper_centr_freq_seg0_idx(oldconf));
--		hostapd_set_oper_centr_freq_seg1_idx(
--			hapd->iconf,
--			hostapd_get_oper_centr_freq_seg1_idx(oldconf));
- 		hapd->conf = newconf->bss[j];
- 		hostapd_reload_bss(hapd);
- 	}
diff --git a/package/network/services/hostapd/patches/341-mesh-ctrl-iface-channel-switch.patch b/package/network/services/hostapd/patches/341-mesh-ctrl-iface-channel-switch.patch
deleted file mode 100644
index 90fa5eff5d..0000000000
--- a/package/network/services/hostapd/patches/341-mesh-ctrl-iface-channel-switch.patch
+++ /dev/null
@@ -1,39 +0,0 @@
---- a/wpa_supplicant/ap.c
-+++ b/wpa_supplicant/ap.c
-@@ -1466,15 +1466,35 @@ int ap_switch_channel(struct wpa_supplic
- 
- 
- #ifdef CONFIG_CTRL_IFACE
-+
-+static int __ap_ctrl_iface_chanswitch(struct hostapd_iface *iface,
-+				      struct csa_settings *settings)
-+{
-+#ifdef NEED_AP_MLME
-+	if (!iface || !iface->bss[0])
-+		return 0;
-+
-+	return hostapd_switch_channel(iface->bss[0], settings);
-+#else
-+	return -1;
-+#endif
-+}
-+
-+
- int ap_ctrl_iface_chanswitch(struct wpa_supplicant *wpa_s, const char *pos)
- {
- 	struct csa_settings settings;
- 	int ret = hostapd_parse_csa_settings(pos, &settings);
- 
-+	if (!(wpa_s->ap_iface && wpa_s->ap_iface->bss[0]) &&
-+	    !(wpa_s->ifmsh && wpa_s->ifmsh->bss[0]))
-+		return -1;
-+
-+	ret = __ap_ctrl_iface_chanswitch(wpa_s->ap_iface, &settings);
- 	if (ret)
- 		return ret;
- 
--	return ap_switch_channel(wpa_s, &settings);
-+	return __ap_ctrl_iface_chanswitch(wpa_s->ifmsh, &settings);
- }
- #endif /* CONFIG_CTRL_IFACE */
- 
diff --git a/package/network/services/hostapd/patches/350-nl80211_del_beacon_bss.patch b/package/network/services/hostapd/patches/350-nl80211_del_beacon_bss.patch
deleted file mode 100644
index 076950fe35..0000000000
--- a/package/network/services/hostapd/patches/350-nl80211_del_beacon_bss.patch
+++ /dev/null
@@ -1,54 +0,0 @@
---- a/src/drivers/driver_nl80211.c
-+++ b/src/drivers/driver_nl80211.c
-@@ -2803,10 +2803,15 @@ static int wpa_driver_nl80211_del_beacon
- 	struct nl_msg *msg;
- 	struct wpa_driver_nl80211_data *drv = bss->drv;
- 
-+	if (!bss->beacon_set)
-+		return 0;
-+
-+	bss->beacon_set = 0;
-+
- 	wpa_printf(MSG_DEBUG, "nl80211: Remove beacon (ifindex=%d)",
--		   drv->ifindex);
-+		   bss->ifindex);
- 	nl80211_put_wiphy_data_ap(bss);
--	msg = nl80211_drv_msg(drv, 0, NL80211_CMD_DEL_BEACON);
-+	msg = nl80211_bss_msg(bss, 0, NL80211_CMD_DEL_BEACON);
- 	return send_and_recv_msgs(drv, msg, NULL, NULL);
- }
- 
-@@ -5278,7 +5283,7 @@ static void nl80211_teardown_ap(struct i
- 		nl80211_mgmt_unsubscribe(bss, "AP teardown");
- 
- 	nl80211_put_wiphy_data_ap(bss);
--	bss->beacon_set = 0;
-+	wpa_driver_nl80211_del_beacon(bss);
- }
- 
- 
-@@ -7694,8 +7699,6 @@ static int wpa_driver_nl80211_if_remove(
- 	} else {
- 		wpa_printf(MSG_DEBUG, "nl80211: First BSS - reassign context");
- 		nl80211_teardown_ap(bss);
--		if (!bss->added_if && !drv->first_bss->next)
--			wpa_driver_nl80211_del_beacon(bss);
- 		nl80211_destroy_bss(bss);
- 		if (!bss->added_if)
- 			i802_set_iface_flags(bss, 0);
-@@ -8089,7 +8092,6 @@ static int wpa_driver_nl80211_deinit_ap(
- 	if (!is_ap_interface(drv->nlmode))
- 		return -1;
- 	wpa_driver_nl80211_del_beacon(bss);
--	bss->beacon_set = 0;
- 
- 	/*
- 	 * If the P2P GO interface was dynamically added, then it is
-@@ -8109,7 +8111,6 @@ static int wpa_driver_nl80211_stop_ap(vo
- 	if (!is_ap_interface(drv->nlmode))
- 		return -1;
- 	wpa_driver_nl80211_del_beacon(bss);
--	bss->beacon_set = 0;
- 	return 0;
- }
- 
diff --git a/package/network/services/hostapd/patches/360-ctrl_iface_reload.patch b/package/network/services/hostapd/patches/360-ctrl_iface_reload.patch
deleted file mode 100644
index 31c5102cb1..0000000000
--- a/package/network/services/hostapd/patches/360-ctrl_iface_reload.patch
+++ /dev/null
@@ -1,106 +0,0 @@
---- a/hostapd/ctrl_iface.c
-+++ b/hostapd/ctrl_iface.c
-@@ -65,6 +65,7 @@
- #include "fst/fst_ctrl_iface.h"
- #include "config_file.h"
- #include "ctrl_iface.h"
-+#include "config_file.h"
- 
- 
- #define HOSTAPD_CLI_DUP_VALUE_MAX_LEN 256
-@@ -80,6 +81,7 @@ static void hostapd_ctrl_iface_send(stru
- 				    enum wpa_msg_type type,
- 				    const char *buf, size_t len);
- 
-+static char *reload_opts = NULL;
- 
- static int hostapd_ctrl_iface_attach(struct hostapd_data *hapd,
- 				     struct sockaddr_storage *from,
-@@ -131,6 +133,61 @@ static int hostapd_ctrl_iface_new_sta(st
- 	return 0;
- }
- 
-+static char *get_option(char *opt, char *str)
-+{
-+	int len = strlen(str);
-+
-+	if (!strncmp(opt, str, len))
-+		return opt + len;
-+	else
-+		return NULL;
-+}
-+
-+static struct hostapd_config *hostapd_ctrl_iface_config_read(const char *fname)
-+{
-+	struct hostapd_config *conf;
-+	char *opt, *val;
-+
-+	conf = hostapd_config_read(fname);
-+	if (!conf)
-+		return NULL;
-+
-+	for (opt = strtok(reload_opts, " ");
-+	     opt;
-+		 opt = strtok(NULL, " ")) {
-+
-+		if ((val = get_option(opt, "channel=")))
-+			conf->channel = atoi(val);
-+		else if ((val = get_option(opt, "ht_capab=")))
-+			conf->ht_capab = atoi(val);
-+		else if ((val = get_option(opt, "ht_capab_mask=")))
-+			conf->ht_capab &= atoi(val);
-+		else if ((val = get_option(opt, "sec_chan=")))
-+			conf->secondary_channel = atoi(val);
-+		else if ((val = get_option(opt, "hw_mode=")))
-+			conf->hw_mode = atoi(val);
-+		else if ((val = get_option(opt, "ieee80211n=")))
-+			conf->ieee80211n = atoi(val);
-+		else
-+			break;
-+	}
-+
-+	return conf;
-+}
-+
-+static int hostapd_ctrl_iface_update(struct hostapd_data *hapd, char *txt)
-+{
-+	struct hostapd_config * (*config_read_cb)(const char *config_fname);
-+	struct hostapd_iface *iface = hapd->iface;
-+
-+	config_read_cb = iface->interfaces->config_read_cb;
-+	iface->interfaces->config_read_cb = hostapd_ctrl_iface_config_read;
-+	reload_opts = txt;
-+
-+	hostapd_reload_config(iface);
-+
-+	iface->interfaces->config_read_cb = config_read_cb;
-+}
- 
- #ifdef NEED_AP_MLME
- static int hostapd_ctrl_iface_sa_query(struct hostapd_data *hapd,
-@@ -3546,6 +3603,8 @@ static int hostapd_ctrl_iface_receive_pr
- 	} else if (os_strncmp(buf, "VENDOR ", 7) == 0) {
- 		reply_len = hostapd_ctrl_iface_vendor(hapd, buf + 7, reply,
- 						      reply_size);
-+	} else if (os_strncmp(buf, "UPDATE ", 7) == 0) {
-+		hostapd_ctrl_iface_update(hapd, buf + 7);
- 	} else if (os_strcmp(buf, "ERP_FLUSH") == 0) {
- 		ieee802_1x_erp_flush(hapd);
- #ifdef RADIUS_SERVER
---- a/src/ap/ctrl_iface_ap.c
-+++ b/src/ap/ctrl_iface_ap.c
-@@ -917,7 +917,13 @@ int hostapd_parse_csa_settings(const cha
- 
- int hostapd_ctrl_iface_stop_ap(struct hostapd_data *hapd)
- {
--	return hostapd_drv_stop_ap(hapd);
-+	struct hostapd_iface *iface = hapd->iface;
-+	int i;
-+
-+	for (i = 0; i < iface->num_bss; i++)
-+		hostapd_drv_stop_ap(iface->bss[i]);
-+
-+	return 0;
- }
- 
- 
diff --git a/package/network/services/hostapd/patches/370-ap_sta_support.patch b/package/network/services/hostapd/patches/370-ap_sta_support.patch
deleted file mode 100644
index 1c5f72ddc0..0000000000
--- a/package/network/services/hostapd/patches/370-ap_sta_support.patch
+++ /dev/null
@@ -1,403 +0,0 @@
---- a/wpa_supplicant/Makefile
-+++ b/wpa_supplicant/Makefile
-@@ -26,6 +26,10 @@ CFLAGS += $(EXTRA_CFLAGS)
- CFLAGS += -I$(abspath ../src)
- CFLAGS += -I$(abspath ../src/utils)
- 
-+ifdef MULTICALL
-+CFLAGS += -DMULTICALL
-+endif
-+
- -include .config
- -include $(if $(MULTICALL),../hostapd/.config)
- 
-@@ -118,6 +122,8 @@ OBJS_c += ../src/utils/common.o
- OBJS_c += ../src/common/cli.o
- OBJS += wmm_ac.o
- 
-+OBJS += ../src/common/wpa_ctrl.o
-+
- ifndef CONFIG_OS
- ifdef CONFIG_NATIVE_WINDOWS
- CONFIG_OS=win32
---- a/wpa_supplicant/bss.c
-+++ b/wpa_supplicant/bss.c
-@@ -11,6 +11,7 @@
- #include "utils/common.h"
- #include "utils/eloop.h"
- #include "common/ieee802_11_defs.h"
-+#include "common/ieee802_11_common.h"
- #include "drivers/driver.h"
- #include "eap_peer/eap.h"
- #include "wpa_supplicant_i.h"
-@@ -294,6 +295,10 @@ void calculate_update_time(const struct
- static void wpa_bss_copy_res(struct wpa_bss *dst, struct wpa_scan_res *src,
- 			     struct os_reltime *fetch_time)
- {
-+	struct ieee80211_ht_capabilities *capab;
-+	struct ieee80211_ht_operation *oper;
-+	struct ieee802_11_elems elems;
-+
- 	dst->flags = src->flags;
- 	os_memcpy(dst->bssid, src->bssid, ETH_ALEN);
- 	dst->freq = src->freq;
-@@ -306,6 +311,15 @@ static void wpa_bss_copy_res(struct wpa_
- 	dst->est_throughput = src->est_throughput;
- 	dst->snr = src->snr;
- 
-+	memset(&elems, 0, sizeof(elems));
-+	ieee802_11_parse_elems((u8 *) (src + 1), src->ie_len, &elems, 0);
-+	capab = (struct ieee80211_ht_capabilities *) elems.ht_capabilities;
-+	oper = (struct ieee80211_ht_operation *) elems.ht_operation;
-+	if (capab)
-+		dst->ht_capab = le_to_host16(capab->ht_capabilities_info);
-+	if (oper)
-+		dst->ht_param = oper->ht_param;
-+
- 	calculate_update_time(fetch_time, src->age, &dst->last_update);
- }
- 
---- a/wpa_supplicant/bss.h
-+++ b/wpa_supplicant/bss.h
-@@ -83,6 +83,10 @@ struct wpa_bss {
- 	u8 ssid[SSID_MAX_LEN];
- 	/** Length of SSID */
- 	size_t ssid_len;
-+	/** HT capabilities */
-+	u16 ht_capab;
-+	/* Five octets of HT Operation Information */
-+	u8 ht_param;
- 	/** Frequency of the channel in MHz (e.g., 2412 = channel 1) */
- 	int freq;
- 	/** Beacon interval in TUs (host byte order) */
---- a/wpa_supplicant/main.c
-+++ b/wpa_supplicant/main.c
-@@ -34,7 +34,7 @@ static void usage(void)
- 	       "vW] [-P<pid file>] "
- 	       "[-g<global ctrl>] \\\n"
- 	       "        [-G<group>] \\\n"
--	       "        -i<ifname> -c<config file> [-C<ctrl>] [-D<driver>] "
-+	       "        -i<ifname> -c<config file> [-C<ctrl>] [-D<driver>] [-H<hostapd path>] "
- 	       "[-p<driver_param>] \\\n"
- 	       "        [-b<br_ifname>] [-e<entropy file>]"
- #ifdef CONFIG_DEBUG_FILE
-@@ -74,6 +74,7 @@ static void usage(void)
- 	       "  -g = global ctrl_interface\n"
- 	       "  -G = global ctrl_interface group\n"
- 	       "  -h = show this help text\n"
-+	       "  -H = connect to a hostapd instance to manage state changes\n"
- 	       "  -i = interface name\n"
- 	       "  -I = additional configuration file\n"
- 	       "  -K = include keys (passwords, etc.) in debug output\n"
-@@ -201,7 +202,7 @@ int main(int argc, char *argv[])
- 
- 	for (;;) {
- 		c = getopt(argc, argv,
--			   "b:Bc:C:D:de:f:g:G:hi:I:KLMm:No:O:p:P:qsTtuvW");
-+			   "b:Bc:C:D:de:f:g:G:hH:i:I:KLMm:No:O:p:P:qsTtuvW");
- 		if (c < 0)
- 			break;
- 		switch (c) {
-@@ -248,6 +249,9 @@ int main(int argc, char *argv[])
- 			usage();
- 			exitcode = 0;
- 			goto out;
-+		case 'H':
-+			iface->hostapd_ctrl = optarg;
-+			break;
- 		case 'i':
- 			iface->ifname = optarg;
- 			break;
---- a/wpa_supplicant/wpa_supplicant.c
-+++ b/wpa_supplicant/wpa_supplicant.c
-@@ -129,6 +129,54 @@ static void wpas_update_fils_connect_par
- static void wpas_update_owe_connect_params(struct wpa_supplicant *wpa_s);
- #endif /* CONFIG_OWE */
- 
-+static int hostapd_stop(struct wpa_supplicant *wpa_s)
-+{
-+	const char *cmd = "STOP_AP";
-+	char buf[256];
-+	size_t len = sizeof(buf);
-+
-+	if (wpa_ctrl_request(wpa_s->hostapd, cmd, os_strlen(cmd), buf, &len, NULL) < 0) {
-+		wpa_printf(MSG_ERROR, "\nFailed to stop hostapd AP interfaces\n");
-+		return -1;
-+	}
-+	return 0;
-+}
-+
-+static int hostapd_reload(struct wpa_supplicant *wpa_s, struct wpa_bss *bss)
-+{
-+	char *cmd = NULL;
-+	char buf[256];
-+	size_t len = sizeof(buf);
-+	enum hostapd_hw_mode hw_mode;
-+	u8 channel;
-+	int sec_chan = 0;
-+	int ret;
-+
-+	if (!bss)
-+		return -1;
-+
-+	if (bss->ht_param & HT_INFO_HT_PARAM_STA_CHNL_WIDTH) {
-+		int sec = bss->ht_param & HT_INFO_HT_PARAM_SECONDARY_CHNL_OFF_MASK;
-+		if (sec == HT_INFO_HT_PARAM_SECONDARY_CHNL_ABOVE)
-+			sec_chan = 1;
-+		else if (sec ==  HT_INFO_HT_PARAM_SECONDARY_CHNL_BELOW)
-+			sec_chan = -1;
-+	}
-+
-+	hw_mode = ieee80211_freq_to_chan(bss->freq, &channel);
-+	if (asprintf(&cmd, "UPDATE channel=%d sec_chan=%d hw_mode=%d",
-+		     channel, sec_chan, hw_mode) < 0)
-+		return -1;
-+
-+	ret = wpa_ctrl_request(wpa_s->hostapd, cmd, os_strlen(cmd), buf, &len, NULL);
-+	free(cmd);
-+
-+	if (ret < 0) {
-+		wpa_printf(MSG_ERROR, "\nFailed to reload hostapd AP interfaces\n");
-+		return -1;
-+	}
-+	return 0;
-+}
- 
- #ifdef CONFIG_WEP
- /* Configure default/group WEP keys for static WEP */
-@@ -991,6 +1039,8 @@ void wpa_supplicant_set_state(struct wpa
- 
- 		sme_sched_obss_scan(wpa_s, 1);
- 
-+		if (wpa_s->hostapd)
-+			hostapd_reload(wpa_s, wpa_s->current_bss);
- #if defined(CONFIG_FILS) && defined(IEEE8021X_EAPOL)
- 		if (!fils_hlp_sent && ssid && ssid->eap.erp)
- 			update_fils_connect_params = true;
-@@ -1001,6 +1051,8 @@ void wpa_supplicant_set_state(struct wpa
- #endif /* CONFIG_OWE */
- 	} else if (state == WPA_DISCONNECTED || state == WPA_ASSOCIATING ||
- 		   state == WPA_ASSOCIATED) {
-+		if (wpa_s->hostapd)
-+			hostapd_stop(wpa_s);
- 		wpa_s->new_connection = 1;
- 		wpa_drv_set_operstate(wpa_s, 0);
- #ifndef IEEE8021X_EAPOL
-@@ -2225,6 +2277,8 @@ void wpa_supplicant_associate(struct wpa
- 			return;
- 		}
- 		wpa_s->current_bss = bss;
-+		if (wpa_s->hostapd)
-+			hostapd_reload(wpa_s, wpa_s->current_bss);
- #else /* CONFIG_MESH */
- 		wpa_msg(wpa_s, MSG_ERROR,
- 			"mesh mode support not included in the build");
-@@ -6207,6 +6261,16 @@ static int wpa_supplicant_init_iface(str
- 			   sizeof(wpa_s->bridge_ifname));
- 	}
- 
-+	if (iface->hostapd_ctrl) {
-+		wpa_s->hostapd = wpa_ctrl_open(iface->hostapd_ctrl);
-+		if (!wpa_s->hostapd) {
-+			wpa_printf(MSG_ERROR, "\nFailed to connect to hostapd\n");
-+			return -1;
-+		}
-+		if (hostapd_stop(wpa_s) < 0)
-+			return -1;
-+	}
-+
- 	/* RSNA Supplicant Key Management - INITIALIZE */
- 	eapol_sm_notify_portEnabled(wpa_s->eapol, false);
- 	eapol_sm_notify_portValid(wpa_s->eapol, false);
-@@ -6540,6 +6604,11 @@ static void wpa_supplicant_deinit_iface(
- 	if (terminate)
- 		wpa_msg(wpa_s, MSG_INFO, WPA_EVENT_TERMINATING);
- 
-+	if (wpa_s->hostapd) {
-+		wpa_ctrl_close(wpa_s->hostapd);
-+		wpa_s->hostapd = NULL;
-+	}
-+
- 	if (wpa_s->ctrl_iface) {
- 		wpa_supplicant_ctrl_iface_deinit(wpa_s->ctrl_iface);
- 		wpa_s->ctrl_iface = NULL;
---- a/wpa_supplicant/wpa_supplicant_i.h
-+++ b/wpa_supplicant/wpa_supplicant_i.h
-@@ -104,6 +104,11 @@ struct wpa_interface {
- 	const char *ifname;
- 
- 	/**
-+	 * hostapd_ctrl - path to hostapd control socket for notification
-+	 */
-+	const char *hostapd_ctrl;
-+
-+	/**
- 	 * bridge_ifname - Optional bridge interface name
- 	 *
- 	 * If the driver interface (ifname) is included in a Linux bridge
-@@ -530,6 +535,8 @@ struct wpa_supplicant {
- #endif /* CONFIG_CTRL_IFACE_BINDER */
- 	char bridge_ifname[16];
- 
-+	struct wpa_ctrl *hostapd;
-+
- 	char *confname;
- 	char *confanother;
- 
---- a/hostapd/ctrl_iface.c
-+++ b/hostapd/ctrl_iface.c
-@@ -2712,6 +2712,11 @@ static int hostapd_ctrl_iface_chan_switc
- 		return 0;
- 	}
- 
-+	if (os_strstr(pos, " auto-ht")) {
-+		settings.freq_params.ht_enabled = iface->conf->ieee80211n;
-+		settings.freq_params.vht_enabled = iface->conf->ieee80211ac;
-+	}
-+
- 	for (i = 0; i < iface->num_bss; i++) {
- 
- 		/* Save CHAN_SWITCH VHT config */
---- a/src/ap/beacon.c
-+++ b/src/ap/beacon.c
-@@ -1468,11 +1468,6 @@ int ieee802_11_set_beacon(struct hostapd
- 	struct wpabuf *beacon, *proberesp, *assocresp;
- 	int res, ret = -1;
- 
--	if (hapd->csa_in_progress) {
--		wpa_printf(MSG_ERROR, "Cannot set beacons during CSA period");
--		return -1;
--	}
--
- 	hapd->beacon_set_done = 1;
- 
- 	if (ieee802_11_build_ap_params(hapd, &params) < 0)
---- a/wpa_supplicant/events.c
-+++ b/wpa_supplicant/events.c
-@@ -4579,6 +4579,60 @@ static void wpas_event_unprot_beacon(str
- }
- 
- 
-+static void
-+supplicant_ch_switch_started(struct wpa_supplicant *wpa_s,
-+			    union wpa_event_data *data)
-+{
-+	char buf[256];
-+	size_t len = sizeof(buf);
-+	char *cmd = NULL;
-+	int width = 20;
-+	int ret;
-+
-+	if (!wpa_s->hostapd)
-+		return;
-+
-+	wpa_msg(wpa_s, MSG_INFO, WPA_EVENT_CHANNEL_SWITCH
-+		"count=%d freq=%d ht_enabled=%d ch_offset=%d ch_width=%s cf1=%d cf2=%d",
-+		data->ch_switch.count,
-+		data->ch_switch.freq,
-+		data->ch_switch.ht_enabled,
-+		data->ch_switch.ch_offset,
-+		channel_width_to_string(data->ch_switch.ch_width),
-+		data->ch_switch.cf1,
-+		data->ch_switch.cf2);
-+
-+	switch (data->ch_switch.ch_width) {
-+	case CHAN_WIDTH_20_NOHT:
-+	case CHAN_WIDTH_20:
-+		width = 20;
-+		break;
-+	case CHAN_WIDTH_40:
-+		width = 40;
-+		break;
-+	case CHAN_WIDTH_80:
-+		width = 80;
-+		break;
-+	case CHAN_WIDTH_160:
-+	case CHAN_WIDTH_80P80:
-+		width = 160;
-+		break;
-+	}
-+
-+	asprintf(&cmd, "CHAN_SWITCH %d %d sec_channel_offset=%d center_freq1=%d center_freq2=%d, bandwidth=%d auto-ht\n",
-+		data->ch_switch.count - 1,
-+		data->ch_switch.freq,
-+		data->ch_switch.ch_offset,
-+		data->ch_switch.cf1,
-+		data->ch_switch.cf2,
-+		width);
-+	ret = wpa_ctrl_request(wpa_s->hostapd, cmd, os_strlen(cmd), buf, &len, NULL);
-+	free(cmd);
-+
-+	if (ret < 0)
-+		wpa_printf(MSG_ERROR, "\nFailed to reload hostapd AP interfaces\n");
-+}
-+
- void supplicant_event(void *ctx, enum wpa_event_type event,
- 		      union wpa_event_data *data)
- {
-@@ -4881,8 +4935,10 @@ void supplicant_event(void *ctx, enum wp
- 			channel_width_to_string(data->ch_switch.ch_width),
- 			data->ch_switch.cf1,
- 			data->ch_switch.cf2);
--		if (event == EVENT_CH_SWITCH_STARTED)
-+		if (event == EVENT_CH_SWITCH_STARTED) {
-+			supplicant_ch_switch_started(wpa_s, data);
- 			break;
-+		}
- 
- 		wpa_s->assoc_freq = data->ch_switch.freq;
- 		wpa_s->current_ssid->frequency = data->ch_switch.freq;
---- a/src/drivers/driver.h
-+++ b/src/drivers/driver.h
-@@ -5690,6 +5690,7 @@ union wpa_event_data {
- 
- 	/**
- 	 * struct ch_switch
-+	 * @count: Count until channel switch activates
- 	 * @freq: Frequency of new channel in MHz
- 	 * @ht_enabled: Whether this is an HT channel
- 	 * @ch_offset: Secondary channel offset
-@@ -5698,6 +5699,7 @@ union wpa_event_data {
- 	 * @cf2: Center frequency 2
- 	 */
- 	struct ch_switch {
-+		int count;
- 		int freq;
- 		int ht_enabled;
- 		int ch_offset;
---- a/src/drivers/driver_nl80211_event.c
-+++ b/src/drivers/driver_nl80211_event.c
-@@ -541,7 +541,7 @@ static void mlme_event_ch_switch(struct
- 				 struct nlattr *ifindex, struct nlattr *freq,
- 				 struct nlattr *type, struct nlattr *bw,
- 				 struct nlattr *cf1, struct nlattr *cf2,
--				 int finished)
-+				 struct nlattr *count, int finished)
- {
- 	struct i802_bss *bss;
- 	union wpa_event_data data;
-@@ -600,6 +600,8 @@ static void mlme_event_ch_switch(struct
- 		data.ch_switch.cf1 = nla_get_u32(cf1);
- 	if (cf2)
- 		data.ch_switch.cf2 = nla_get_u32(cf2);
-+	if (count)
-+		data.ch_switch.count = nla_get_u32(count);
- 
- 	if (finished)
- 		bss->freq = data.ch_switch.freq;
-@@ -2686,6 +2688,7 @@ static void do_process_drv_event(struct
- 				     tb[NL80211_ATTR_CHANNEL_WIDTH],
- 				     tb[NL80211_ATTR_CENTER_FREQ1],
- 				     tb[NL80211_ATTR_CENTER_FREQ2],
-+				     tb[NL80211_ATTR_CH_SWITCH_COUNT],
- 				     0);
- 		break;
- 	case NL80211_CMD_CH_SWITCH_NOTIFY:
-@@ -2696,6 +2699,7 @@ static void do_process_drv_event(struct
- 				     tb[NL80211_ATTR_CHANNEL_WIDTH],
- 				     tb[NL80211_ATTR_CENTER_FREQ1],
- 				     tb[NL80211_ATTR_CENTER_FREQ2],
-+				     NULL,
- 				     1);
- 		break;
- 	case NL80211_CMD_DISCONNECT:
diff --git a/package/network/services/hostapd/patches/380-disable_ctrl_iface_mib.patch b/package/network/services/hostapd/patches/380-disable_ctrl_iface_mib.patch
deleted file mode 100644
index b98b2d0cba..0000000000
--- a/package/network/services/hostapd/patches/380-disable_ctrl_iface_mib.patch
+++ /dev/null
@@ -1,193 +0,0 @@
---- a/hostapd/Makefile
-+++ b/hostapd/Makefile
-@@ -226,6 +226,9 @@ endif
- ifdef CONFIG_NO_CTRL_IFACE
- CFLAGS += -DCONFIG_NO_CTRL_IFACE
- else
-+ifdef CONFIG_CTRL_IFACE_MIB
-+CFLAGS += -DCONFIG_CTRL_IFACE_MIB
-+endif
- ifeq ($(CONFIG_CTRL_IFACE), udp)
- CFLAGS += -DCONFIG_CTRL_IFACE_UDP
- else
---- a/hostapd/ctrl_iface.c
-+++ b/hostapd/ctrl_iface.c
-@@ -3370,6 +3370,7 @@ static int hostapd_ctrl_iface_receive_pr
- 						      reply_size);
- 	} else if (os_strcmp(buf, "STATUS-DRIVER") == 0) {
- 		reply_len = hostapd_drv_status(hapd, reply, reply_size);
-+#ifdef CONFIG_CTRL_IFACE_MIB
- 	} else if (os_strcmp(buf, "MIB") == 0) {
- 		reply_len = ieee802_11_get_mib(hapd, reply, reply_size);
- 		if (reply_len >= 0) {
-@@ -3411,6 +3412,7 @@ static int hostapd_ctrl_iface_receive_pr
- 	} else if (os_strncmp(buf, "STA-NEXT ", 9) == 0) {
- 		reply_len = hostapd_ctrl_iface_sta_next(hapd, buf + 9, reply,
- 							reply_size);
-+#endif
- 	} else if (os_strcmp(buf, "ATTACH") == 0) {
- 		if (hostapd_ctrl_iface_attach(hapd, from, fromlen, NULL))
- 			reply_len = -1;
---- a/wpa_supplicant/Makefile
-+++ b/wpa_supplicant/Makefile
-@@ -952,6 +952,9 @@ ifdef CONFIG_FILS
- OBJS += ../src/ap/fils_hlp.o
- endif
- ifdef CONFIG_CTRL_IFACE
-+ifdef CONFIG_CTRL_IFACE_MIB
-+CFLAGS += -DCONFIG_CTRL_IFACE_MIB
-+endif
- OBJS += ../src/ap/ctrl_iface_ap.o
- endif
- 
---- a/wpa_supplicant/ctrl_iface.c
-+++ b/wpa_supplicant/ctrl_iface.c
-@@ -2267,7 +2267,7 @@ static int wpa_supplicant_ctrl_iface_sta
- 			pos += ret;
- 		}
- 
--#ifdef CONFIG_AP
-+#if defined(CONFIG_AP) && defined(CONFIG_CTRL_IFACE_MIB)
- 		if (wpa_s->ap_iface) {
- 			pos += ap_ctrl_iface_wpa_get_status(wpa_s, pos,
- 							    end - pos,
-@@ -10366,6 +10366,7 @@ char * wpa_supplicant_ctrl_iface_process
- 			reply_len = -1;
- 	} else if (os_strncmp(buf, "NOTE ", 5) == 0) {
- 		wpa_printf(MSG_INFO, "NOTE: %s", buf + 5);
-+#ifdef CONFIG_CTRL_IFACE_MIB
- 	} else if (os_strcmp(buf, "MIB") == 0) {
- 		reply_len = wpa_sm_get_mib(wpa_s->wpa, reply, reply_size);
- 		if (reply_len >= 0) {
-@@ -10378,6 +10379,7 @@ char * wpa_supplicant_ctrl_iface_process
- 				reply_size - reply_len);
- #endif /* CONFIG_MACSEC */
- 		}
-+#endif
- 	} else if (os_strncmp(buf, "STATUS", 6) == 0) {
- 		reply_len = wpa_supplicant_ctrl_iface_status(
- 			wpa_s, buf + 6, reply, reply_size);
-@@ -10862,6 +10864,7 @@ char * wpa_supplicant_ctrl_iface_process
- 		reply_len = wpa_supplicant_ctrl_iface_bss(
- 			wpa_s, buf + 4, reply, reply_size);
- #ifdef CONFIG_AP
-+#ifdef CONFIG_CTRL_IFACE_MIB
- 	} else if (os_strcmp(buf, "STA-FIRST") == 0) {
- 		reply_len = ap_ctrl_iface_sta_first(wpa_s, reply, reply_size);
- 	} else if (os_strncmp(buf, "STA ", 4) == 0) {
-@@ -10870,12 +10873,15 @@ char * wpa_supplicant_ctrl_iface_process
- 	} else if (os_strncmp(buf, "STA-NEXT ", 9) == 0) {
- 		reply_len = ap_ctrl_iface_sta_next(wpa_s, buf + 9, reply,
- 						   reply_size);
-+#endif
-+#ifdef CONFIG_CTRL_IFACE_MIB
- 	} else if (os_strncmp(buf, "DEAUTHENTICATE ", 15) == 0) {
- 		if (ap_ctrl_iface_sta_deauthenticate(wpa_s, buf + 15))
- 			reply_len = -1;
- 	} else if (os_strncmp(buf, "DISASSOCIATE ", 13) == 0) {
- 		if (ap_ctrl_iface_sta_disassociate(wpa_s, buf + 13))
- 			reply_len = -1;
-+#endif
- 	} else if (os_strncmp(buf, "CHAN_SWITCH ", 12) == 0) {
- 		if (ap_ctrl_iface_chanswitch(wpa_s, buf + 12))
- 			reply_len = -1;
---- a/src/ap/ctrl_iface_ap.c
-+++ b/src/ap/ctrl_iface_ap.c
-@@ -25,6 +25,7 @@
- #include "mbo_ap.h"
- #include "taxonomy.h"
- 
-+#ifdef CONFIG_CTRL_IFACE_MIB
- 
- static size_t hostapd_write_ht_mcs_bitmask(char *buf, size_t buflen,
- 					   size_t curr_len, const u8 *mcs_set)
-@@ -451,6 +452,7 @@ int hostapd_ctrl_iface_sta_next(struct h
- 	return hostapd_ctrl_iface_sta_mib(hapd, sta->next, buf, buflen);
- }
- 
-+#endif
- 
- #ifdef CONFIG_P2P_MANAGER
- static int p2p_manager_disconnect(struct hostapd_data *hapd, u16 stype,
-@@ -806,12 +808,12 @@ int hostapd_ctrl_iface_status(struct hos
- 			return len;
- 		len += ret;
- 	}
--
-+#ifdef CONFIG_CTRL_IFACE_MIB
- 	if (iface->conf->ieee80211n && !hapd->conf->disable_11n && mode) {
- 		len = hostapd_write_ht_mcs_bitmask(buf, buflen, len,
- 						   mode->mcs_set);
- 	}
--
-+#endif /* CONFIG_CTRL_IFACE_MIB */
- 	if (iface->current_rates && iface->num_rates) {
- 		ret = os_snprintf(buf + len, buflen - len, "supported_rates=");
- 		if (os_snprintf_error(buflen - len, ret))
---- a/src/ap/ieee802_1x.c
-+++ b/src/ap/ieee802_1x.c
-@@ -2711,6 +2711,7 @@ static const char * bool_txt(bool val)
- 	return val ? "TRUE" : "FALSE";
- }
- 
-+#ifdef CONFIG_CTRL_IFACE_MIB
- 
- int ieee802_1x_get_mib(struct hostapd_data *hapd, char *buf, size_t buflen)
- {
-@@ -2897,6 +2898,7 @@ int ieee802_1x_get_mib_sta(struct hostap
- 	return len;
- }
- 
-+#endif
- 
- #ifdef CONFIG_HS20
- static void ieee802_1x_wnm_notif_send(void *eloop_ctx, void *timeout_ctx)
---- a/src/ap/wpa_auth.c
-+++ b/src/ap/wpa_auth.c
-@@ -4451,6 +4451,7 @@ static const char * wpa_bool_txt(int val
- 	return val ? "TRUE" : "FALSE";
- }
- 
-+#ifdef CONFIG_CTRL_IFACE_MIB
- 
- #define RSN_SUITE "%02x-%02x-%02x-%d"
- #define RSN_SUITE_ARG(s) \
-@@ -4601,7 +4602,7 @@ int wpa_get_mib_sta(struct wpa_state_mac
- 
- 	return len;
- }
--
-+#endif
- 
- void wpa_auth_countermeasures_start(struct wpa_authenticator *wpa_auth)
- {
---- a/src/rsn_supp/wpa.c
-+++ b/src/rsn_supp/wpa.c
-@@ -2728,6 +2728,8 @@ static u32 wpa_key_mgmt_suite(struct wpa
- }
- 
- 
-+#ifdef CONFIG_CTRL_IFACE_MIB
-+
- #define RSN_SUITE "%02x-%02x-%02x-%d"
- #define RSN_SUITE_ARG(s) \
- ((s) >> 24) & 0xff, ((s) >> 16) & 0xff, ((s) >> 8) & 0xff, (s) & 0xff
-@@ -2809,6 +2811,7 @@ int wpa_sm_get_mib(struct wpa_sm *sm, ch
- 
- 	return (int) len;
- }
-+#endif
- #endif /* CONFIG_CTRL_IFACE */
- 
- 
---- a/wpa_supplicant/ap.c
-+++ b/wpa_supplicant/ap.c
-@@ -1324,7 +1324,7 @@ int wpas_ap_wps_nfc_report_handover(stru
- #endif /* CONFIG_WPS */
- 
- 
--#ifdef CONFIG_CTRL_IFACE
-+#if defined(CONFIG_CTRL_IFACE) && defined(CONFIG_CTRL_IFACE_MIB)
- 
- int ap_ctrl_iface_sta_first(struct wpa_supplicant *wpa_s,
- 			    char *buf, size_t buflen)
diff --git a/package/network/services/hostapd/patches/381-hostapd_cli_UNKNOWN-COMMAND.patch b/package/network/services/hostapd/patches/381-hostapd_cli_UNKNOWN-COMMAND.patch
deleted file mode 100644
index d2414faf01..0000000000
--- a/package/network/services/hostapd/patches/381-hostapd_cli_UNKNOWN-COMMAND.patch
+++ /dev/null
@@ -1,11 +0,0 @@
---- a/hostapd/hostapd_cli.c
-+++ b/hostapd/hostapd_cli.c
-@@ -744,7 +744,7 @@ static int wpa_ctrl_command_sta(struct w
- 	}
- 
- 	buf[len] = '\0';
--	if (memcmp(buf, "FAIL", 4) == 0)
-+	if (memcmp(buf, "FAIL", 4) == 0 || memcmp(buf, "UNKNOWN COMMAND", 15) == 0)
- 		return -1;
- 	if (print)
- 		printf("%s", buf);
diff --git a/package/network/services/hostapd/patches/390-wpa_ie_cap_workaround.patch b/package/network/services/hostapd/patches/390-wpa_ie_cap_workaround.patch
deleted file mode 100644
index 9dee2d738e..0000000000
--- a/package/network/services/hostapd/patches/390-wpa_ie_cap_workaround.patch
+++ /dev/null
@@ -1,56 +0,0 @@
---- a/src/common/wpa_common.c
-+++ b/src/common/wpa_common.c
-@@ -2121,6 +2121,31 @@ u32 wpa_akm_to_suite(int akm)
- }
- 
- 
-+static void wpa_fixup_wpa_ie_rsn(u8 *assoc_ie, const u8 *wpa_msg_ie,
-+				 size_t rsn_ie_len)
-+{
-+	int pos, count;
-+
-+	pos = sizeof(struct rsn_ie_hdr) + RSN_SELECTOR_LEN;
-+	if (rsn_ie_len < pos + 2)
-+		return;
-+
-+	count = WPA_GET_LE16(wpa_msg_ie + pos);
-+	pos += 2 + count * RSN_SELECTOR_LEN;
-+	if (rsn_ie_len < pos + 2)
-+		return;
-+
-+	count = WPA_GET_LE16(wpa_msg_ie + pos);
-+	pos += 2 + count * RSN_SELECTOR_LEN;
-+	if (rsn_ie_len < pos + 2)
-+		return;
-+
-+	if (!assoc_ie[pos] && !assoc_ie[pos + 1] &&
-+	    (wpa_msg_ie[pos] || wpa_msg_ie[pos + 1]))
-+		memcpy(&assoc_ie[pos], &wpa_msg_ie[pos], 2);
-+}
-+
-+
- int wpa_compare_rsn_ie(int ft_initial_assoc,
- 		       const u8 *ie1, size_t ie1len,
- 		       const u8 *ie2, size_t ie2len)
-@@ -2128,8 +2153,19 @@ int wpa_compare_rsn_ie(int ft_initial_as
- 	if (ie1 == NULL || ie2 == NULL)
- 		return -1;
- 
--	if (ie1len == ie2len && os_memcmp(ie1, ie2, ie1len) == 0)
--		return 0; /* identical IEs */
-+	if (ie1len == ie2len) {
-+		u8 *ie_tmp;
-+
-+		if (os_memcmp(ie1, ie2, ie1len) == 0)
-+			return 0; /* identical IEs */
-+
-+		ie_tmp = alloca(ie1len);
-+		memcpy(ie_tmp, ie1, ie1len);
-+		wpa_fixup_wpa_ie_rsn(ie_tmp, ie2, ie1len);
-+
-+		if (os_memcmp(ie_tmp, ie2, ie1len) == 0)
-+			return 0; /* only mismatch in RSN capabilties */
-+	}
- 
- #ifdef CONFIG_IEEE80211R
- 	if (ft_initial_assoc) {
diff --git a/package/network/services/hostapd/patches/400-wps_single_auth_enc_type.patch b/package/network/services/hostapd/patches/400-wps_single_auth_enc_type.patch
deleted file mode 100644
index 73a8c7694d..0000000000
--- a/package/network/services/hostapd/patches/400-wps_single_auth_enc_type.patch
+++ /dev/null
@@ -1,23 +0,0 @@
---- a/src/ap/wps_hostapd.c
-+++ b/src/ap/wps_hostapd.c
-@@ -394,9 +394,8 @@ static int hapd_wps_reconfig_in_memory(s
- 				bss->wpa_pairwise |= WPA_CIPHER_GCMP;
- 			else
- 				bss->wpa_pairwise |= WPA_CIPHER_CCMP;
--		}
- #ifndef CONFIG_NO_TKIP
--		if (cred->encr_type & WPS_ENCR_TKIP)
-+		} else if (cred->encr_type & WPS_ENCR_TKIP)
- 			bss->wpa_pairwise |= WPA_CIPHER_TKIP;
- #endif /* CONFIG_NO_TKIP */
- 		bss->rsn_pairwise = bss->wpa_pairwise;
-@@ -1178,8 +1177,7 @@ int hostapd_init_wps(struct hostapd_data
- 					  WPA_CIPHER_GCMP_256)) {
- 			wps->encr_types |= WPS_ENCR_AES;
- 			wps->encr_types_rsn |= WPS_ENCR_AES;
--		}
--		if (conf->rsn_pairwise & WPA_CIPHER_TKIP) {
-+		} else if (conf->rsn_pairwise & WPA_CIPHER_TKIP) {
- #ifdef CONFIG_NO_TKIP
- 			wpa_printf(MSG_INFO, "WPS: TKIP not supported");
- 			goto fail;
diff --git a/package/network/services/hostapd/patches/410-limit_debug_messages.patch b/package/network/services/hostapd/patches/410-limit_debug_messages.patch
deleted file mode 100644
index d2713fc29b..0000000000
--- a/package/network/services/hostapd/patches/410-limit_debug_messages.patch
+++ /dev/null
@@ -1,210 +0,0 @@
---- a/src/utils/wpa_debug.c
-+++ b/src/utils/wpa_debug.c
-@@ -206,7 +206,7 @@ void wpa_debug_close_linux_tracing(void)
-  *
-  * Note: New line '\n' is added to the end of the text when printing to stdout.
-  */
--void wpa_printf(int level, const char *fmt, ...)
-+void _wpa_printf(int level, const char *fmt, ...)
- {
- 	va_list ap;
- 
-@@ -255,7 +255,7 @@ void wpa_printf(int level, const char *f
- }
- 
- 
--static void _wpa_hexdump(int level, const char *title, const u8 *buf,
-+void _wpa_hexdump(int level, const char *title, const u8 *buf,
- 			 size_t len, int show, int only_syslog)
- {
- 	size_t i;
-@@ -382,19 +382,7 @@ static void _wpa_hexdump(int level, cons
- #endif /* CONFIG_ANDROID_LOG */
- }
- 
--void wpa_hexdump(int level, const char *title, const void *buf, size_t len)
--{
--	_wpa_hexdump(level, title, buf, len, 1, 0);
--}
--
--
--void wpa_hexdump_key(int level, const char *title, const void *buf, size_t len)
--{
--	_wpa_hexdump(level, title, buf, len, wpa_debug_show_keys, 0);
--}
--
--
--static void _wpa_hexdump_ascii(int level, const char *title, const void *buf,
-+void _wpa_hexdump_ascii(int level, const char *title, const void *buf,
- 			       size_t len, int show)
- {
- 	size_t i, llen;
-@@ -507,20 +495,6 @@ file_done:
- }
- 
- 
--void wpa_hexdump_ascii(int level, const char *title, const void *buf,
--		       size_t len)
--{
--	_wpa_hexdump_ascii(level, title, buf, len, 1);
--}
--
--
--void wpa_hexdump_ascii_key(int level, const char *title, const void *buf,
--			   size_t len)
--{
--	_wpa_hexdump_ascii(level, title, buf, len, wpa_debug_show_keys);
--}
--
--
- #ifdef CONFIG_DEBUG_FILE
- static char *last_path = NULL;
- #endif /* CONFIG_DEBUG_FILE */
-@@ -636,7 +610,7 @@ void wpa_msg_register_ifname_cb(wpa_msg_
- }
- 
- 
--void wpa_msg(void *ctx, int level, const char *fmt, ...)
-+void _wpa_msg(void *ctx, int level, const char *fmt, ...)
- {
- 	va_list ap;
- 	char *buf;
-@@ -674,7 +648,7 @@ void wpa_msg(void *ctx, int level, const
- }
- 
- 
--void wpa_msg_ctrl(void *ctx, int level, const char *fmt, ...)
-+void _wpa_msg_ctrl(void *ctx, int level, const char *fmt, ...)
- {
- 	va_list ap;
- 	char *buf;
---- a/src/utils/wpa_debug.h
-+++ b/src/utils/wpa_debug.h
-@@ -50,6 +50,17 @@ int wpa_debug_reopen_file(void);
- void wpa_debug_close_file(void);
- void wpa_debug_setup_stdout(void);
- 
-+/* internal */
-+void _wpa_hexdump(int level, const char *title, const u8 *buf,
-+		  size_t len, int show, int only_syslog);
-+void _wpa_hexdump_ascii(int level, const char *title, const void *buf,
-+			size_t len, int show);
-+extern int wpa_debug_show_keys;
-+
-+#ifndef CONFIG_MSG_MIN_PRIORITY
-+#define CONFIG_MSG_MIN_PRIORITY 0
-+#endif
-+
- /**
-  * wpa_debug_printf_timestamp - Print timestamp for debug output
-  *
-@@ -70,9 +81,15 @@ void wpa_debug_print_timestamp(void);
-  *
-  * Note: New line '\n' is added to the end of the text when printing to stdout.
-  */
--void wpa_printf(int level, const char *fmt, ...)
-+void _wpa_printf(int level, const char *fmt, ...)
- PRINTF_FORMAT(2, 3);
- 
-+#define wpa_printf(level, ...)						\
-+	do {								\
-+		if (level >= CONFIG_MSG_MIN_PRIORITY)			\
-+			_wpa_printf(level, __VA_ARGS__);		\
-+	} while(0)
-+
- /**
-  * wpa_hexdump - conditional hex dump
-  * @level: priority level (MSG_*) of the message
-@@ -84,7 +101,13 @@ PRINTF_FORMAT(2, 3);
-  * output may be directed to stdout, stderr, and/or syslog based on
-  * configuration. The contents of buf is printed out has hex dump.
-  */
--void wpa_hexdump(int level, const char *title, const void *buf, size_t len);
-+static inline void wpa_hexdump(int level, const char *title, const void *buf, size_t len)
-+{
-+	if (level < CONFIG_MSG_MIN_PRIORITY)
-+		return;
-+
-+	_wpa_hexdump(level, title, buf, len, 1, 1);
-+}
- 
- static inline void wpa_hexdump_buf(int level, const char *title,
- 				   const struct wpabuf *buf)
-@@ -106,7 +129,13 @@ static inline void wpa_hexdump_buf(int l
-  * like wpa_hexdump(), but by default, does not include secret keys (passwords,
-  * etc.) in debug output.
-  */
--void wpa_hexdump_key(int level, const char *title, const void *buf, size_t len);
-+static inline void wpa_hexdump_key(int level, const char *title, const u8 *buf, size_t len)
-+{
-+	if (level < CONFIG_MSG_MIN_PRIORITY)
-+		return;
-+
-+	_wpa_hexdump(level, title, buf, len, wpa_debug_show_keys, 1);
-+}
- 
- static inline void wpa_hexdump_buf_key(int level, const char *title,
- 				       const struct wpabuf *buf)
-@@ -128,8 +157,14 @@ static inline void wpa_hexdump_buf_key(i
-  * the hex numbers and ASCII characters (for printable range) are shown. 16
-  * bytes per line will be shown.
-  */
--void wpa_hexdump_ascii(int level, const char *title, const void *buf,
--		       size_t len);
-+static inline void wpa_hexdump_ascii(int level, const char *title,
-+				     const u8 *buf, size_t len)
-+{
-+	if (level < CONFIG_MSG_MIN_PRIORITY)
-+		return;
-+
-+	_wpa_hexdump_ascii(level, title, buf, len, 1);
-+}
- 
- /**
-  * wpa_hexdump_ascii_key - conditional hex dump, hide keys
-@@ -145,8 +180,14 @@ void wpa_hexdump_ascii(int level, const
-  * bytes per line will be shown. This works like wpa_hexdump_ascii(), but by
-  * default, does not include secret keys (passwords, etc.) in debug output.
-  */
--void wpa_hexdump_ascii_key(int level, const char *title, const void *buf,
--			   size_t len);
-+static inline void wpa_hexdump_ascii_key(int level, const char *title,
-+					 const u8 *buf, size_t len)
-+{
-+	if (level < CONFIG_MSG_MIN_PRIORITY)
-+		return;
-+
-+	_wpa_hexdump_ascii(level, title, buf, len, wpa_debug_show_keys);
-+}
- 
- /*
-  * wpa_dbg() behaves like wpa_msg(), but it can be removed from build to reduce
-@@ -183,7 +224,12 @@ void wpa_hexdump_ascii_key(int level, co
-  *
-  * Note: New line '\n' is added to the end of the text when printing to stdout.
-  */
--void wpa_msg(void *ctx, int level, const char *fmt, ...) PRINTF_FORMAT(3, 4);
-+void _wpa_msg(void *ctx, int level, const char *fmt, ...) PRINTF_FORMAT(3, 4);
-+#define wpa_msg(ctx, level, ...)					\
-+	do {								\
-+		if (level >= CONFIG_MSG_MIN_PRIORITY)			\
-+			_wpa_msg(ctx, level, __VA_ARGS__);		\
-+	} while(0)
- 
- /**
-  * wpa_msg_ctrl - Conditional printf for ctrl_iface monitors
-@@ -197,8 +243,13 @@ void wpa_msg(void *ctx, int level, const
-  * attached ctrl_iface monitors. In other words, it can be used for frequent
-  * events that do not need to be sent to syslog.
-  */
--void wpa_msg_ctrl(void *ctx, int level, const char *fmt, ...)
-+void _wpa_msg_ctrl(void *ctx, int level, const char *fmt, ...)
- PRINTF_FORMAT(3, 4);
-+#define wpa_msg_ctrl(ctx, level, ...)					\
-+	do {								\
-+		if (level >= CONFIG_MSG_MIN_PRIORITY)			\
-+			_wpa_msg_ctrl(ctx, level, __VA_ARGS__);		\
-+	} while(0)
- 
- /**
-  * wpa_msg_global - Global printf for ctrl_iface monitors
diff --git a/package/network/services/hostapd/patches/420-indicate-features.patch b/package/network/services/hostapd/patches/420-indicate-features.patch
deleted file mode 100644
index 9f216347f4..0000000000
--- a/package/network/services/hostapd/patches/420-indicate-features.patch
+++ /dev/null
@@ -1,62 +0,0 @@
---- a/hostapd/main.c
-+++ b/hostapd/main.c
-@@ -15,6 +15,7 @@
- #include "utils/common.h"
- #include "utils/eloop.h"
- #include "utils/uuid.h"
-+#include "utils/build_features.h"
- #include "crypto/random.h"
- #include "crypto/tls.h"
- #include "common/version.h"
-@@ -692,7 +693,7 @@ int main(int argc, char *argv[])
- 	wpa_supplicant_event = hostapd_wpa_event;
- 	wpa_supplicant_event_global = hostapd_wpa_event_global;
- 	for (;;) {
--		c = getopt(argc, argv, "b:Bde:f:hi:KP:sSTtu:vg:G:");
-+		c = getopt(argc, argv, "b:Bde:f:hi:KP:sSTtu:g:G:v::");
- 		if (c < 0)
- 			break;
- 		switch (c) {
-@@ -729,6 +730,8 @@ int main(int argc, char *argv[])
- 			break;
- #endif /* CONFIG_DEBUG_LINUX_TRACING */
- 		case 'v':
-+			if (optarg)
-+				exit(!has_feature(optarg));
- 			show_version();
- 			exit(1);
- 			break;
---- a/wpa_supplicant/main.c
-+++ b/wpa_supplicant/main.c
-@@ -12,6 +12,7 @@
- #endif /* __linux__ */
- 
- #include "common.h"
-+#include "build_features.h"
- #include "fst/fst.h"
- #include "wpa_supplicant_i.h"
- #include "driver_i.h"
-@@ -202,7 +203,7 @@ int main(int argc, char *argv[])
- 
- 	for (;;) {
- 		c = getopt(argc, argv,
--			   "b:Bc:C:D:de:f:g:G:hH:i:I:KLMm:No:O:p:P:qsTtuvW");
-+			   "b:Bc:C:D:de:f:g:G:hH:i:I:KLMm:No:O:p:P:qsTtuv::W");
- 		if (c < 0)
- 			break;
- 		switch (c) {
-@@ -305,8 +306,12 @@ int main(int argc, char *argv[])
- 			break;
- #endif /* CONFIG_CTRL_IFACE_DBUS_NEW */
- 		case 'v':
--			printf("%s\n", wpa_supplicant_version);
--			exitcode = 0;
-+			if (optarg) {
-+				exitcode = !has_feature(optarg);
-+			} else {
-+				printf("%s\n", wpa_supplicant_version);
-+				exitcode = 0;
-+			}
- 			goto out;
- 		case 'W':
- 			params.wait_for_monitor++;
diff --git a/package/network/services/hostapd/patches/430-hostapd_cli_ifdef.patch b/package/network/services/hostapd/patches/430-hostapd_cli_ifdef.patch
deleted file mode 100644
index 3744464c89..0000000000
--- a/package/network/services/hostapd/patches/430-hostapd_cli_ifdef.patch
+++ /dev/null
@@ -1,56 +0,0 @@
---- a/hostapd/hostapd_cli.c
-+++ b/hostapd/hostapd_cli.c
-@@ -388,7 +388,6 @@ static int hostapd_cli_cmd_disassociate(
- }
- 
- 
--#ifdef CONFIG_TAXONOMY
- static int hostapd_cli_cmd_signature(struct wpa_ctrl *ctrl, int argc,
- 				     char *argv[])
- {
-@@ -401,7 +400,6 @@ static int hostapd_cli_cmd_signature(str
- 	os_snprintf(buf, sizeof(buf), "SIGNATURE %s", argv[0]);
- 	return wpa_ctrl_command(ctrl, buf);
- }
--#endif /* CONFIG_TAXONOMY */
- 
- 
- static int hostapd_cli_cmd_sa_query(struct wpa_ctrl *ctrl, int argc,
-@@ -418,7 +416,6 @@ static int hostapd_cli_cmd_sa_query(stru
- }
- 
- 
--#ifdef CONFIG_WPS
- static int hostapd_cli_cmd_wps_pin(struct wpa_ctrl *ctrl, int argc,
- 				   char *argv[])
- {
-@@ -644,7 +641,6 @@ static int hostapd_cli_cmd_wps_config(st
- 			 ssid_hex, argv[1]);
- 	return wpa_ctrl_command(ctrl, buf);
- }
--#endif /* CONFIG_WPS */
- 
- 
- static int hostapd_cli_cmd_disassoc_imminent(struct wpa_ctrl *ctrl, int argc,
-@@ -1532,13 +1528,10 @@ static const struct hostapd_cli_cmd host
- 	{ "disassociate", hostapd_cli_cmd_disassociate,
- 	  hostapd_complete_stations,
- 	  "<addr> = disassociate a station" },
--#ifdef CONFIG_TAXONOMY
- 	{ "signature", hostapd_cli_cmd_signature, hostapd_complete_stations,
- 	  "<addr> = get taxonomy signature for a station" },
--#endif /* CONFIG_TAXONOMY */
- 	{ "sa_query", hostapd_cli_cmd_sa_query, hostapd_complete_stations,
- 	  "<addr> = send SA Query to a station" },
--#ifdef CONFIG_WPS
- 	{ "wps_pin", hostapd_cli_cmd_wps_pin, NULL,
- 	  "<uuid> <pin> [timeout] [addr] = add WPS Enrollee PIN" },
- 	{ "wps_check_pin", hostapd_cli_cmd_wps_check_pin, NULL,
-@@ -1563,7 +1556,6 @@ static const struct hostapd_cli_cmd host
- 	  "<SSID> <auth> <encr> <key> = configure AP" },
- 	{ "wps_get_status", hostapd_cli_cmd_wps_get_status, NULL,
- 	  "= show current WPS status" },
--#endif /* CONFIG_WPS */
- 	{ "disassoc_imminent", hostapd_cli_cmd_disassoc_imminent, NULL,
- 	  "= send Disassociation Imminent notification" },
- 	{ "ess_disassoc", hostapd_cli_cmd_ess_disassoc, NULL,
diff --git a/package/network/services/hostapd/patches/431-wpa_cli_ifdef.patch b/package/network/services/hostapd/patches/431-wpa_cli_ifdef.patch
deleted file mode 100644
index 65c31c567f..0000000000
--- a/package/network/services/hostapd/patches/431-wpa_cli_ifdef.patch
+++ /dev/null
@@ -1,18 +0,0 @@
---- a/wpa_supplicant/wpa_cli.c
-+++ b/wpa_supplicant/wpa_cli.c
-@@ -26,6 +26,15 @@
- #include <cutils/properties.h>
- #endif /* ANDROID */
- 
-+#ifndef CONFIG_P2P
-+#define CONFIG_P2P
-+#endif
-+#ifndef CONFIG_AP
-+#define CONFIG_AP
-+#endif
-+#ifndef CONFIG_MESH
-+#define CONFIG_MESH
-+#endif
- 
- static const char *const wpa_cli_version =
- "wpa_cli v" VERSION_STR "\n"
diff --git a/package/network/services/hostapd/patches/432-missing-typedef.patch b/package/network/services/hostapd/patches/432-missing-typedef.patch
deleted file mode 100644
index 7a100f1a0d..0000000000
--- a/package/network/services/hostapd/patches/432-missing-typedef.patch
+++ /dev/null
@@ -1,10 +0,0 @@
---- a/src/drivers/linux_wext.h
-+++ b/src/drivers/linux_wext.h
-@@ -26,6 +26,7 @@ typedef int32_t __s32;
- typedef uint16_t __u16;
- typedef int16_t __s16;
- typedef uint8_t __u8;
-+typedef int8_t __s8;
- #ifndef __user
- #define __user
- #endif /* __user */
diff --git a/package/network/services/hostapd/patches/450-scan_wait.patch b/package/network/services/hostapd/patches/450-scan_wait.patch
deleted file mode 100644
index ac874ad66a..0000000000
--- a/package/network/services/hostapd/patches/450-scan_wait.patch
+++ /dev/null
@@ -1,73 +0,0 @@
---- a/hostapd/main.c
-+++ b/hostapd/main.c
-@@ -39,6 +39,8 @@ struct hapd_global {
- };
- 
- static struct hapd_global global;
-+static int daemonize = 0;
-+static char *pid_file = NULL;
- 
- 
- #ifndef CONFIG_NO_HOSTAPD_LOGGER
-@@ -146,6 +148,14 @@ static void hostapd_logger_cb(void *ctx,
- }
- #endif /* CONFIG_NO_HOSTAPD_LOGGER */
- 
-+static void hostapd_setup_complete_cb(void *ctx)
-+{
-+	if (daemonize && os_daemonize(pid_file)) {
-+		perror("daemon");
-+		return;
-+	}
-+	daemonize = 0;
-+}
- 
- /**
-  * hostapd_driver_init - Preparate driver interface
-@@ -164,6 +174,8 @@ static int hostapd_driver_init(struct ho
- 		return -1;
- 	}
- 
-+	hapd->setup_complete_cb = hostapd_setup_complete_cb;
-+
- 	/* Initialize the driver interface */
- 	if (!(b[0] | b[1] | b[2] | b[3] | b[4] | b[5]))
- 		b = NULL;
-@@ -404,8 +416,6 @@ static void hostapd_global_deinit(const
- #endif /* CONFIG_NATIVE_WINDOWS */
- 
- 	eap_server_unregister_methods();
--
--	os_daemonize_terminate(pid_file);
- }
- 
- 
-@@ -431,18 +441,6 @@ static int hostapd_global_run(struct hap
- 	}
- #endif /* EAP_SERVER_TNC */
- 
--	if (daemonize) {
--		if (os_daemonize(pid_file)) {
--			wpa_printf(MSG_ERROR, "daemon: %s", strerror(errno));
--			return -1;
--		}
--		if (eloop_sock_requeue()) {
--			wpa_printf(MSG_ERROR, "eloop_sock_requeue: %s",
--				   strerror(errno));
--			return -1;
--		}
--	}
--
- 	eloop_run();
- 
- 	return 0;
-@@ -645,8 +643,7 @@ int main(int argc, char *argv[])
- 	struct hapd_interfaces interfaces;
- 	int ret = 1;
- 	size_t i, j;
--	int c, debug = 0, daemonize = 0;
--	char *pid_file = NULL;
-+	int c, debug = 0;
- 	const char *log_file = NULL;
- 	const char *entropy_file = NULL;
- 	char **bss_config = NULL, **tmp_bss;
diff --git a/package/network/services/hostapd/patches/460-wpa_supplicant-add-new-config-params-to-be-used-with.patch b/package/network/services/hostapd/patches/460-wpa_supplicant-add-new-config-params-to-be-used-with.patch
deleted file mode 100644
index 99c552821b..0000000000
--- a/package/network/services/hostapd/patches/460-wpa_supplicant-add-new-config-params-to-be-used-with.patch
+++ /dev/null
@@ -1,189 +0,0 @@
-From 4bb69d15477e0f2b00e166845341dc933de47c58 Mon Sep 17 00:00:00 2001
-From: Antonio Quartulli <ordex@autistici.org>
-Date: Sun, 3 Jun 2012 18:22:56 +0200
-Subject: [PATCHv2 601/602] wpa_supplicant: add new config params to be used
- with the ibss join command
-
-Signed-hostap: Antonio Quartulli <ordex@autistici.org>
----
- src/drivers/driver.h            |    6 +++
- wpa_supplicant/config.c         |   96 +++++++++++++++++++++++++++++++++++++++
- wpa_supplicant/config_ssid.h    |    6 +++
- wpa_supplicant/wpa_supplicant.c |   23 +++++++---
- 4 files changed, 124 insertions(+), 7 deletions(-)
-
---- a/src/drivers/driver.h
-+++ b/src/drivers/driver.h
-@@ -19,6 +19,7 @@
- 
- #define WPA_SUPPLICANT_DRIVER_VERSION 4
- 
-+#include "ap/sta_info.h"
- #include "common/defs.h"
- #include "common/ieee802_11_defs.h"
- #include "common/wpa_common.h"
-@@ -850,6 +851,9 @@ struct wpa_driver_associate_params {
- 	 * responsible for selecting with which BSS to associate. */
- 	const u8 *bssid;
- 
-+	unsigned char rates[WLAN_SUPP_RATES_MAX];
-+	int mcast_rate;
-+
- 	/**
- 	 * bssid_hint - BSSID of a proposed AP
- 	 *
---- a/wpa_supplicant/config.c
-+++ b/wpa_supplicant/config.c
-@@ -18,6 +18,7 @@
- #include "eap_peer/eap.h"
- #include "p2p/p2p.h"
- #include "fst/fst.h"
-+#include "ap/sta_info.h"
- #include "config.h"
- 
- 
-@@ -2269,6 +2270,97 @@ static char * wpa_config_write_peerkey(c
- #endif /* NO_CONFIG_WRITE */
- 
- 
-+static int wpa_config_parse_mcast_rate(const struct parse_data *data,
-+				       struct wpa_ssid *ssid, int line,
-+				       const char *value)
-+{
-+	ssid->mcast_rate = (int)(strtod(value, NULL) * 10);
-+
-+	return 0;
-+}
-+
-+#ifndef NO_CONFIG_WRITE
-+static char * wpa_config_write_mcast_rate(const struct parse_data *data,
-+					  struct wpa_ssid *ssid)
-+{
-+	char *value;
-+	int res;
-+
-+	if (!ssid->mcast_rate == 0)
-+		return NULL;
-+
-+	value = os_malloc(6); /* longest: 300.0 */
-+	if (value == NULL)
-+		return NULL;
-+	res = os_snprintf(value, 5, "%.1f", (double)ssid->mcast_rate / 10);
-+	if (res < 0) {
-+		os_free(value);
-+		return NULL;
-+	}
-+	return value;
-+}
-+#endif /* NO_CONFIG_WRITE */
-+
-+static int wpa_config_parse_rates(const struct parse_data *data,
-+				  struct wpa_ssid *ssid, int line,
-+				  const char *value)
-+{
-+	int i;
-+	char *pos, *r, *sptr, *end;
-+	double rate;
-+
-+	pos = (char *)value;
-+	r = strtok_r(pos, ",", &sptr);
-+	i = 0;
-+	while (pos && i < WLAN_SUPP_RATES_MAX) {
-+		rate = 0.0;
-+		if (r)
-+			rate = strtod(r, &end);
-+		ssid->rates[i] = rate * 2;
-+		if (*end != '\0' || rate * 2 != ssid->rates[i])
-+			return 1;
-+
-+		i++;
-+		r = strtok_r(NULL, ",", &sptr);
-+	}
-+
-+	return 0;
-+}
-+
-+#ifndef NO_CONFIG_WRITE
-+static char * wpa_config_write_rates(const struct parse_data *data,
-+				     struct wpa_ssid *ssid)
-+{
-+	char *value, *pos;
-+	int res, i;
-+
-+	if (ssid->rates[0] <= 0)
-+		return NULL;
-+
-+	value = os_malloc(6 * WLAN_SUPP_RATES_MAX + 1);
-+	if (value == NULL)
-+		return NULL;
-+	pos = value;
-+	for (i = 0; i < WLAN_SUPP_RATES_MAX - 1; i++) {
-+		res = os_snprintf(pos, 6, "%.1f,", (double)ssid->rates[i] / 2);
-+		if (res < 0) {
-+			os_free(value);
-+			return NULL;
-+		}
-+		pos += res;
-+	}
-+	res = os_snprintf(pos, 6, "%.1f",
-+			  (double)ssid->rates[WLAN_SUPP_RATES_MAX - 1] / 2);
-+	if (res < 0) {
-+		os_free(value);
-+		return NULL;
-+	}
-+
-+	value[6 * WLAN_SUPP_RATES_MAX] = '\0';
-+	return value;
-+}
-+#endif /* NO_CONFIG_WRITE */
-+
- /* Helper macros for network block parser */
- 
- #ifdef OFFSET
-@@ -2552,6 +2644,8 @@ static const struct parse_data ssid_fiel
- 	{ INT(ap_max_inactivity) },
- 	{ INT(dtim_period) },
- 	{ INT(beacon_int) },
-+	{ FUNC(rates) },
-+	{ FUNC(mcast_rate) },
- #ifdef CONFIG_MACSEC
- 	{ INT_RANGE(macsec_policy, 0, 1) },
- 	{ INT_RANGE(macsec_integ_only, 0, 1) },
---- a/wpa_supplicant/config_ssid.h
-+++ b/wpa_supplicant/config_ssid.h
-@@ -10,8 +10,10 @@
- #define CONFIG_SSID_H
- 
- #include "common/defs.h"
-+#include "ap/sta_info.h"
- #include "utils/list.h"
- #include "eap_peer/eap_config.h"
-+#include "drivers/nl80211_copy.h"
- 
- 
- #define DEFAULT_EAP_WORKAROUND ((unsigned int) -1)
-@@ -843,6 +845,9 @@ struct wpa_ssid {
- 	 */
- 	void *parent_cred;
- 
-+	unsigned char rates[WLAN_SUPP_RATES_MAX];
-+	double mcast_rate;
-+
- #ifdef CONFIG_MACSEC
- 	/**
- 	 * macsec_policy - Determines the policy for MACsec secure session
---- a/wpa_supplicant/wpa_supplicant.c
-+++ b/wpa_supplicant/wpa_supplicant.c
-@@ -3638,6 +3638,12 @@ static void wpas_start_assoc_cb(struct w
- 			params.beacon_int = ssid->beacon_int;
- 		else
- 			params.beacon_int = wpa_s->conf->beacon_int;
-+		int i = 0;
-+		while (i < WLAN_SUPP_RATES_MAX) {
-+			params.rates[i] = ssid->rates[i];
-+			i++;
-+		}
-+		params.mcast_rate = ssid->mcast_rate;
- 	}
- 
- 	if (bss && ssid->enable_edmg)
diff --git a/package/network/services/hostapd/patches/461-driver_nl80211-use-new-parameters-during-ibss-join.patch b/package/network/services/hostapd/patches/461-driver_nl80211-use-new-parameters-during-ibss-join.patch
deleted file mode 100644
index b5dec991d0..0000000000
--- a/package/network/services/hostapd/patches/461-driver_nl80211-use-new-parameters-during-ibss-join.patch
+++ /dev/null
@@ -1,59 +0,0 @@
-From ffc4445958a3ed4064f2e1bf73fa478a61c5cf7b Mon Sep 17 00:00:00 2001
-From: Antonio Quartulli <ordex@autistici.org>
-Date: Sun, 3 Jun 2012 18:42:25 +0200
-Subject: [PATCHv2 602/602] driver_nl80211: use new parameters during ibss join
-
-Signed-hostap: Antonio Quartulli <ordex@autistici.org>
----
- src/drivers/driver_nl80211.c |   33 ++++++++++++++++++++++++++++++++-
- 1 file changed, 32 insertions(+), 1 deletion(-)
-
---- a/src/drivers/driver_nl80211.c
-+++ b/src/drivers/driver_nl80211.c
-@@ -5601,7 +5601,7 @@ static int wpa_driver_nl80211_ibss(struc
- 				   struct wpa_driver_associate_params *params)
- {
- 	struct nl_msg *msg;
--	int ret = -1;
-+	int ret = -1, i;
- 	int count = 0;
- 
- 	wpa_printf(MSG_DEBUG, "nl80211: Join IBSS (ifindex=%d)", drv->ifindex);
-@@ -5628,6 +5628,37 @@ retry:
- 	    nl80211_put_beacon_int(msg, params->beacon_int))
- 		goto fail;
- 
-+	if (params->fixed_freq) {
-+		wpa_printf(MSG_DEBUG, "  * fixed_freq");
-+		nla_put_flag(msg, NL80211_ATTR_FREQ_FIXED);
-+	}
-+
-+	if (params->beacon_int > 0) {
-+		wpa_printf(MSG_DEBUG, "  * beacon_int=%d",
-+			   params->beacon_int);
-+		nla_put_u32(msg, NL80211_ATTR_BEACON_INTERVAL,
-+			    params->beacon_int);
-+	}
-+
-+	if (params->rates[0] > 0) {
-+		wpa_printf(MSG_DEBUG, "  * basic_rates:");
-+		i = 0;
-+		while (i < NL80211_MAX_SUPP_RATES &&
-+		       params->rates[i] > 0) {
-+			wpa_printf(MSG_DEBUG, "    %.1f",
-+				   (double)params->rates[i] / 2);
-+			i++;
-+		}
-+		nla_put(msg, NL80211_ATTR_BSS_BASIC_RATES, i,
-+			params->rates);
-+	}
-+
-+	if (params->mcast_rate > 0) {
-+		wpa_printf(MSG_DEBUG, "  * mcast_rate=%.1f",
-+			   (double)params->mcast_rate / 10);
-+		nla_put_u32(msg, NL80211_ATTR_MCAST_RATE, params->mcast_rate);
-+	}
-+
- 	ret = nl80211_set_conn_keys(params, msg);
- 	if (ret)
- 		goto fail;
diff --git a/package/network/services/hostapd/patches/463-add-mcast_rate-to-11s.patch b/package/network/services/hostapd/patches/463-add-mcast_rate-to-11s.patch
deleted file mode 100644
index 7e21da263d..0000000000
--- a/package/network/services/hostapd/patches/463-add-mcast_rate-to-11s.patch
+++ /dev/null
@@ -1,68 +0,0 @@
-From: Sven Eckelmann <sven.eckelmann@openmesh.com>
-Date: Thu, 11 May 2017 08:21:45 +0200
-Subject: [PATCH] set mcast_rate in mesh mode
-
-The wpa_supplicant code for IBSS allows to set the mcast rate. It is
-recommended to increase this value from 1 or 6 Mbit/s to something higher
-when using a mesh protocol on top which uses the multicast packet loss as
-indicator for the link quality.
-
-This setting was unfortunately not applied for mesh mode. But it would be
-beneficial when wpa_supplicant would behave similar to IBSS mode and set
-this argument during mesh join like authsae already does. At least it is
-helpful for companies/projects which are currently switching to 802.11s
-(without mesh_fwding and with mesh_ttl set to 1) as replacement for IBSS
-because newer drivers seem to support 802.11s but not IBSS anymore.
-
-Signed-off-by: Sven Eckelmann <sven.eckelmann@openmesh.com>
-Tested-by: Simon Wunderlich <simon.wunderlich@openmesh.com>
-
---- a/src/drivers/driver.h
-+++ b/src/drivers/driver.h
-@@ -1549,6 +1549,7 @@ struct wpa_driver_mesh_join_params {
- #define WPA_DRIVER_MESH_FLAG_AMPE	0x00000008
- 	unsigned int flags;
- 	u8 handle_dfs;
-+	int mcast_rate;
- };
- 
- struct wpa_driver_set_key_params {
---- a/src/drivers/driver_nl80211.c
-+++ b/src/drivers/driver_nl80211.c
-@@ -10058,6 +10058,18 @@ static int nl80211_put_mesh_id(struct nl
- }
- 
- 
-+static int nl80211_put_mcast_rate(struct nl_msg *msg, int mcast_rate)
-+{
-+	if (mcast_rate > 0) {
-+		wpa_printf(MSG_DEBUG, "  * mcast_rate=%.1f",
-+			   (double)mcast_rate / 10);
-+		return nla_put_u32(msg, NL80211_ATTR_MCAST_RATE, mcast_rate);
-+	}
-+
-+	return 0;
-+}
-+
-+
- static int nl80211_put_mesh_config(struct nl_msg *msg,
- 				   struct wpa_driver_mesh_bss_params *params)
- {
-@@ -10119,6 +10131,7 @@ static int nl80211_join_mesh(struct i802
- 	    nl80211_put_basic_rates(msg, params->basic_rates) ||
- 	    nl80211_put_mesh_id(msg, params->meshid, params->meshid_len) ||
- 	    nl80211_put_beacon_int(msg, params->beacon_int) ||
-+	    nl80211_put_mcast_rate(msg, params->mcast_rate) ||
- 	    nl80211_put_dtim_period(msg, params->dtim_period))
- 		goto fail;
- 
---- a/wpa_supplicant/mesh.c
-+++ b/wpa_supplicant/mesh.c
-@@ -592,6 +592,7 @@ int wpa_supplicant_join_mesh(struct wpa_
- 
- 	params->meshid = ssid->ssid;
- 	params->meshid_len = ssid->ssid_len;
-+	params->mcast_rate = ssid->mcast_rate;
- 	ibss_mesh_setup_freq(wpa_s, ssid, &params->freq);
- 	wpa_s->mesh_ht_enabled = !!params->freq.ht_enabled;
- 	wpa_s->mesh_vht_enabled = !!params->freq.vht_enabled;
diff --git a/package/network/services/hostapd/patches/464-fix-mesh-obss-check.patch b/package/network/services/hostapd/patches/464-fix-mesh-obss-check.patch
deleted file mode 100644
index 6d48175163..0000000000
--- a/package/network/services/hostapd/patches/464-fix-mesh-obss-check.patch
+++ /dev/null
@@ -1,19 +0,0 @@
---- a/wpa_supplicant/wpa_supplicant.c
-+++ b/wpa_supplicant/wpa_supplicant.c
-@@ -2407,11 +2407,13 @@ void ibss_mesh_setup_freq(struct wpa_sup
- 	for (j = 0; j < wpa_s->last_scan_res_used; j++) {
- 		struct wpa_bss *bss = wpa_s->last_scan_res[j];
- 
--		if (ssid->mode != WPAS_MODE_IBSS)
-+		/* Don't adjust control freq in case of fixed_freq */
-+		if (ssid->fixed_freq) {
-+			obss_scan = 0;
- 			break;
-+		}
- 
--		/* Don't adjust control freq in case of fixed_freq */
--		if (ssid->fixed_freq)
-+		if (ssid->mode != WPAS_MODE_IBSS)
- 			break;
- 
- 		if (!bss_is_ibss(bss))
diff --git a/package/network/services/hostapd/patches/470-survey_data_fallback.patch b/package/network/services/hostapd/patches/470-survey_data_fallback.patch
deleted file mode 100644
index 57a78ee865..0000000000
--- a/package/network/services/hostapd/patches/470-survey_data_fallback.patch
+++ /dev/null
@@ -1,45 +0,0 @@
---- a/src/ap/acs.c
-+++ b/src/ap/acs.c
-@@ -302,18 +302,12 @@ static void acs_fail(struct hostapd_ifac
- static long double
- acs_survey_interference_factor(struct freq_survey *survey, s8 min_nf)
- {
--	long double factor, busy, total;
-+	long double factor, busy = 0, total;
- 
- 	if (survey->filled & SURVEY_HAS_CHAN_TIME_BUSY)
- 		busy = survey->channel_time_busy;
- 	else if (survey->filled & SURVEY_HAS_CHAN_TIME_RX)
- 		busy = survey->channel_time_rx;
--	else {
--		/* This shouldn't really happen as survey data is checked in
--		 * acs_sanity_check() */
--		wpa_printf(MSG_ERROR, "ACS: Survey data missing");
--		return 0;
--	}
- 
- 	total = survey->channel_time;
- 
-@@ -415,20 +409,19 @@ static int acs_usable_vht160_chan(const
- static int acs_survey_is_sufficient(struct freq_survey *survey)
- {
- 	if (!(survey->filled & SURVEY_HAS_NF)) {
-+		survey->nf = -95;
- 		wpa_printf(MSG_INFO, "ACS: Survey is missing noise floor");
--		return 0;
- 	}
- 
- 	if (!(survey->filled & SURVEY_HAS_CHAN_TIME)) {
-+		survey->channel_time = 0;
- 		wpa_printf(MSG_INFO, "ACS: Survey is missing channel time");
--		return 0;
- 	}
- 
- 	if (!(survey->filled & SURVEY_HAS_CHAN_TIME_BUSY) &&
- 	    !(survey->filled & SURVEY_HAS_CHAN_TIME_RX)) {
- 		wpa_printf(MSG_INFO,
- 			   "ACS: Survey is missing RX and busy time (at least one is required)");
--		return 0;
- 	}
- 
- 	return 1;
diff --git a/package/network/services/hostapd/patches/500-lto-jobserver-support.patch b/package/network/services/hostapd/patches/500-lto-jobserver-support.patch
deleted file mode 100644
index 46030859de..0000000000
--- a/package/network/services/hostapd/patches/500-lto-jobserver-support.patch
+++ /dev/null
@@ -1,50 +0,0 @@
---- a/hostapd/Makefile
-+++ b/hostapd/Makefile
-@@ -1327,14 +1327,14 @@ hostapd_multi.a: $(BCHECK) $(OBJS)
- 	@$(AR) cr $@ hostapd_multi.o $(OBJS)
- 
- hostapd: $(BCHECK) $(OBJS)
--	$(Q)$(CC) $(LDFLAGS) -o hostapd $(OBJS) $(LIBS)
-+	+$(Q)$(CC) $(LDFLAGS) -o hostapd $(OBJS) $(LIBS)
- 	@$(E) "  LD " $@
- 
- ifdef CONFIG_WPA_TRACE
- OBJS_c += ../src/utils/trace.o
- endif
- hostapd_cli: $(OBJS_c)
--	$(Q)$(CC) $(LDFLAGS) -o hostapd_cli $(OBJS_c) $(LIBS_c)
-+	+$(Q)$(CC) $(LDFLAGS) -o hostapd_cli $(OBJS_c) $(LIBS_c)
- 	@$(E) "  LD " $@
- 
- NOBJS = nt_password_hash.o ../src/crypto/ms_funcs.o $(SHA1OBJS)
---- a/wpa_supplicant/Makefile
-+++ b/wpa_supplicant/Makefile
-@@ -1930,23 +1930,23 @@ wpa_supplicant_multi.a: .config $(BCHECK
- 	@$(AR) cr $@ wpa_supplicant_multi.o $(OBJS)
- 
- wpa_supplicant: $(BCHECK) $(OBJS) $(EXTRA_progs)
--	$(Q)$(LDO) $(LDFLAGS) -o wpa_supplicant $(OBJS) $(LIBS) $(EXTRALIBS)
-+	+$(Q)$(LDO) $(LDFLAGS) -o wpa_supplicant $(OBJS) $(LIBS) $(EXTRALIBS)
- 	@$(E) "  LD " $@
- 
- eapol_test: $(OBJS_t)
--	$(Q)$(LDO) $(LDFLAGS) -o eapol_test $(OBJS_t) $(LIBS)
-+	+$(Q)$(LDO) $(LDFLAGS) -o eapol_test $(OBJS_t) $(LIBS)
- 	@$(E) "  LD " $@
- 
- preauth_test: $(OBJS_t2)
--	$(Q)$(LDO) $(LDFLAGS) -o preauth_test $(OBJS_t2) $(LIBS)
-+	+$(Q)$(LDO) $(LDFLAGS) -o preauth_test $(OBJS_t2) $(LIBS)
- 	@$(E) "  LD " $@
- 
- wpa_passphrase: $(OBJS_p)
--	$(Q)$(LDO) $(LDFLAGS) -o wpa_passphrase $(OBJS_p) $(LIBS_p) $(LIBS)
-+	+$(Q)$(LDO) $(LDFLAGS) -o wpa_passphrase $(OBJS_p) $(LIBS_p) $(LIBS)
- 	@$(E) "  LD " $@
- 
- wpa_cli: $(OBJS_c)
--	$(Q)$(LDO) $(LDFLAGS) -o wpa_cli $(OBJS_c) $(LIBS_c)
-+	+$(Q)$(LDO) $(LDFLAGS) -o wpa_cli $(OBJS_c) $(LIBS_c)
- 	@$(E) "  LD " $@
- 
- LIBCTRL += ../src/common/wpa_ctrl.o
diff --git a/package/network/services/hostapd/patches/599-wpa_supplicant-fix-warnings.patch b/package/network/services/hostapd/patches/599-wpa_supplicant-fix-warnings.patch
deleted file mode 100644
index e70dc61419..0000000000
--- a/package/network/services/hostapd/patches/599-wpa_supplicant-fix-warnings.patch
+++ /dev/null
@@ -1,19 +0,0 @@
---- a/wpa_supplicant/wps_supplicant.h
-+++ b/wpa_supplicant/wps_supplicant.h
-@@ -9,6 +9,7 @@
- #ifndef WPS_SUPPLICANT_H
- #define WPS_SUPPLICANT_H
- 
-+struct wpa_bss;
- struct wpa_scan_results;
- 
- #ifdef CONFIG_WPS
-@@ -16,8 +17,6 @@ struct wpa_scan_results;
- #include "wps/wps.h"
- #include "wps/wps_defs.h"
- 
--struct wpa_bss;
--
- struct wps_new_ap_settings {
- 	const char *ssid_hex;
- 	const char *auth;
diff --git a/package/network/services/hostapd/patches/600-ubus_support.patch b/package/network/services/hostapd/patches/600-ubus_support.patch
deleted file mode 100644
index 53f521e649..0000000000
--- a/package/network/services/hostapd/patches/600-ubus_support.patch
+++ /dev/null
@@ -1,426 +0,0 @@
---- a/hostapd/Makefile
-+++ b/hostapd/Makefile
-@@ -171,6 +171,11 @@ OBJS += ../src/common/hw_features_common
- 
- OBJS += ../src/eapol_auth/eapol_auth_sm.o
- 
-+ifdef CONFIG_UBUS
-+CFLAGS += -DUBUS_SUPPORT
-+OBJS += ../src/ap/ubus.o
-+LIBS += -lubox -lubus
-+endif
- 
- ifdef CONFIG_CODE_COVERAGE
- CFLAGS += -O0 -fprofile-arcs -ftest-coverage
---- a/src/ap/hostapd.h
-+++ b/src/ap/hostapd.h
-@@ -17,6 +17,7 @@
- #include "utils/list.h"
- #include "ap_config.h"
- #include "drivers/driver.h"
-+#include "ubus.h"
- 
- #define OCE_STA_CFON_ENABLED(hapd) \
- 	((hapd->conf->oce & OCE_STA_CFON) && \
-@@ -80,7 +81,7 @@ struct hapd_interfaces {
- #ifdef CONFIG_CTRL_IFACE_UDP
-        unsigned char ctrl_iface_cookie[CTRL_IFACE_COOKIE_LEN];
- #endif /* CONFIG_CTRL_IFACE_UDP */
--
-+	struct ubus_object ubus;
- };
- 
- enum hostapd_chan_status {
-@@ -154,6 +155,7 @@ struct hostapd_data {
- 	struct hostapd_iface *iface;
- 	struct hostapd_config *iconf;
- 	struct hostapd_bss_config *conf;
-+	struct hostapd_ubus_bss ubus;
- 	int interface_added; /* virtual interface added for this BSS */
- 	unsigned int started:1;
- 	unsigned int disabled:1;
-@@ -606,6 +608,7 @@ hostapd_alloc_bss_data(struct hostapd_if
- 		       struct hostapd_bss_config *bss);
- int hostapd_setup_interface(struct hostapd_iface *iface);
- int hostapd_setup_interface_complete(struct hostapd_iface *iface, int err);
-+void hostapd_set_own_neighbor_report(struct hostapd_data *hapd);
- void hostapd_interface_deinit(struct hostapd_iface *iface);
- void hostapd_interface_free(struct hostapd_iface *iface);
- struct hostapd_iface * hostapd_alloc_iface(void);
---- a/src/ap/hostapd.c
-+++ b/src/ap/hostapd.c
-@@ -395,6 +395,7 @@ void hostapd_free_hapd_data(struct hosta
- 	hapd->beacon_set_done = 0;
- 
- 	wpa_printf(MSG_DEBUG, "%s(%s)", __func__, hapd->conf->iface);
-+	hostapd_ubus_free_bss(hapd);
- 	accounting_deinit(hapd);
- 	hostapd_deinit_wpa(hapd);
- 	vlan_deinit(hapd);
-@@ -1417,6 +1418,8 @@ static int hostapd_setup_bss(struct host
- 	if (hapd->driver && hapd->driver->set_operstate)
- 		hapd->driver->set_operstate(hapd->drv_priv, 1);
- 
-+	hostapd_ubus_add_bss(hapd);
-+
- 	return 0;
- }
- 
-@@ -1999,6 +2002,7 @@ static int hostapd_setup_interface_compl
- 	if (err)
- 		goto fail;
- 
-+	hostapd_ubus_add_iface(iface);
- 	wpa_printf(MSG_DEBUG, "Completing interface initialization");
- 	if (iface->freq) {
- #ifdef NEED_AP_MLME
-@@ -2196,6 +2200,7 @@ dfs_offload:
- 
- fail:
- 	wpa_printf(MSG_ERROR, "Interface initialization failed");
-+	hostapd_ubus_free_iface(iface);
- 	hostapd_set_state(iface, HAPD_IFACE_DISABLED);
- 	wpa_msg(hapd->msg_ctx, MSG_INFO, AP_EVENT_DISABLED);
- #ifdef CONFIG_FST
-@@ -2669,6 +2674,7 @@ void hostapd_interface_deinit_free(struc
- 		   (unsigned int) iface->conf->num_bss);
- 	driver = iface->bss[0]->driver;
- 	drv_priv = iface->bss[0]->drv_priv;
-+	hostapd_ubus_free_iface(iface);
- 	hostapd_interface_deinit(iface);
- 	wpa_printf(MSG_DEBUG, "%s: driver=%p drv_priv=%p -> hapd_deinit",
- 		   __func__, driver, drv_priv);
---- a/src/ap/ieee802_11.c
-+++ b/src/ap/ieee802_11.c
-@@ -2327,13 +2327,18 @@ static void handle_auth(struct hostapd_d
- 	u16 auth_alg, auth_transaction, status_code;
- 	u16 resp = WLAN_STATUS_SUCCESS;
- 	struct sta_info *sta = NULL;
--	int res, reply_res;
-+	int res, reply_res, ubus_resp;
- 	u16 fc;
- 	const u8 *challenge = NULL;
- 	u8 resp_ies[2 + WLAN_AUTH_CHALLENGE_LEN];
- 	size_t resp_ies_len = 0;
- 	u16 seq_ctrl;
- 	struct radius_sta rad_info;
-+	struct hostapd_ubus_request req = {
-+		.type = HOSTAPD_UBUS_AUTH_REQ,
-+		.mgmt_frame = mgmt,
-+		.ssi_signal = rssi,
-+	};
- 
- 	if (len < IEEE80211_HDRLEN + sizeof(mgmt->u.auth)) {
- 		wpa_printf(MSG_INFO, "handle_auth - too short payload (len=%lu)",
-@@ -2493,6 +2498,13 @@ static void handle_auth(struct hostapd_d
- 		resp = WLAN_STATUS_UNSPECIFIED_FAILURE;
- 		goto fail;
- 	}
-+	ubus_resp = hostapd_ubus_handle_event(hapd, &req);
-+	if (ubus_resp) {
-+		wpa_printf(MSG_DEBUG, "Station " MACSTR " rejected by ubus handler.\n",
-+			MAC2STR(mgmt->sa));
-+		resp = ubus_resp > 0 ? (u16) ubus_resp : WLAN_STATUS_UNSPECIFIED_FAILURE;
-+		goto fail;
-+	}
- 	if (res == HOSTAPD_ACL_PENDING)
- 		return;
- 
-@@ -4157,7 +4169,7 @@ static void handle_assoc(struct hostapd_
- 	int resp = WLAN_STATUS_SUCCESS;
- 	u16 reply_res;
- 	const u8 *pos;
--	int left, i;
-+	int left, i, ubus_resp;
- 	struct sta_info *sta;
- 	u8 *tmp = NULL;
- #ifdef CONFIG_FILS
-@@ -4370,6 +4382,11 @@ static void handle_assoc(struct hostapd_
- 		left = res;
- 	}
- #endif /* CONFIG_FILS */
-+	struct hostapd_ubus_request req = {
-+		.type = HOSTAPD_UBUS_ASSOC_REQ,
-+		.mgmt_frame = mgmt,
-+		.ssi_signal = rssi,
-+	};
- 
- 	/* followed by SSID and Supported rates; and HT capabilities if 802.11n
- 	 * is used */
-@@ -4468,6 +4485,14 @@ static void handle_assoc(struct hostapd_
- 	}
- #endif /* CONFIG_FILS */
- 
-+	ubus_resp = hostapd_ubus_handle_event(hapd, &req);
-+	if (ubus_resp) {
-+		wpa_printf(MSG_DEBUG, "Station " MACSTR " assoc rejected by ubus handler.\n",
-+		       MAC2STR(mgmt->sa));
-+		resp = ubus_resp > 0 ? (u16) ubus_resp : WLAN_STATUS_UNSPECIFIED_FAILURE;
-+		goto fail;
-+	}
-+
-  fail:
- 
- 	/*
-@@ -4561,6 +4586,7 @@ static void handle_disassoc(struct hosta
- 	wpa_printf(MSG_DEBUG, "disassocation: STA=" MACSTR " reason_code=%d",
- 		   MAC2STR(mgmt->sa),
- 		   le_to_host16(mgmt->u.disassoc.reason_code));
-+	hostapd_ubus_notify(hapd, "disassoc", mgmt->sa);
- 
- 	sta = ap_get_sta(hapd, mgmt->sa);
- 	if (sta == NULL) {
-@@ -4627,6 +4653,8 @@ static void handle_deauth(struct hostapd
- 		" reason_code=%d",
- 		MAC2STR(mgmt->sa), le_to_host16(mgmt->u.deauth.reason_code));
- 
-+	hostapd_ubus_notify(hapd, "deauth", mgmt->sa);
-+
- 	sta = ap_get_sta(hapd, mgmt->sa);
- 	if (sta == NULL) {
- 		wpa_msg(hapd->msg_ctx, MSG_DEBUG, "Station " MACSTR " trying "
---- a/src/ap/beacon.c
-+++ b/src/ap/beacon.c
-@@ -814,6 +814,12 @@ void handle_probe_req(struct hostapd_dat
- 	u16 csa_offs[2];
- 	size_t csa_offs_len;
- 	struct radius_sta rad_info;
-+	struct hostapd_ubus_request req = {
-+		.type = HOSTAPD_UBUS_PROBE_REQ,
-+		.mgmt_frame = mgmt,
-+		.ssi_signal = ssi_signal,
-+		.elems = &elems,
-+	};
- 
- 	if (len < IEEE80211_HDRLEN)
- 		return;
-@@ -996,6 +1002,12 @@ void handle_probe_req(struct hostapd_dat
- 	}
- #endif /* CONFIG_P2P */
- 
-+	if (hostapd_ubus_handle_event(hapd, &req)) {
-+		wpa_printf(MSG_DEBUG, "Probe request for " MACSTR " rejected by ubus handler.\n",
-+		       MAC2STR(mgmt->sa));
-+		return;
-+	}
-+
- 	/* TODO: verify that supp_rates contains at least one matching rate
- 	 * with AP configuration */
- 
---- a/src/ap/drv_callbacks.c
-+++ b/src/ap/drv_callbacks.c
-@@ -119,6 +119,10 @@ int hostapd_notif_assoc(struct hostapd_d
- 	u16 reason = WLAN_REASON_UNSPECIFIED;
- 	int status = WLAN_STATUS_SUCCESS;
- 	const u8 *p2p_dev_addr = NULL;
-+	struct hostapd_ubus_request req = {
-+		.type = HOSTAPD_UBUS_ASSOC_REQ,
-+		.addr = addr,
-+	};
- 
- 	if (addr == NULL) {
- 		/*
-@@ -211,6 +215,12 @@ int hostapd_notif_assoc(struct hostapd_d
- 		goto fail;
- 	}
- 
-+	if (hostapd_ubus_handle_event(hapd, &req)) {
-+		wpa_printf(MSG_DEBUG, "Station " MACSTR " assoc rejected by ubus handler.\n",
-+			   MAC2STR(req.addr));
-+		goto fail;
-+	}
-+
- #ifdef CONFIG_P2P
- 	if (elems.p2p) {
- 		wpabuf_free(sta->p2p_ie);
---- a/src/ap/sta_info.c
-+++ b/src/ap/sta_info.c
-@@ -423,6 +423,7 @@ void ap_handle_timer(void *eloop_ctx, vo
- 		hostapd_logger(hapd, sta->addr, HOSTAPD_MODULE_IEEE80211,
- 			       HOSTAPD_LEVEL_INFO, "deauthenticated due to "
- 			       "local deauth request");
-+		hostapd_ubus_notify(hapd, "local-deauth", sta->addr);
- 		ap_free_sta(hapd, sta);
- 		return;
- 	}
-@@ -578,6 +579,7 @@ skip_poll:
- 		mlme_deauthenticate_indication(
- 			hapd, sta,
- 			WLAN_REASON_PREV_AUTH_NOT_VALID);
-+		hostapd_ubus_notify(hapd, "inactive-deauth", sta->addr);
- 		ap_free_sta(hapd, sta);
- 		break;
- 	}
-@@ -1294,6 +1296,7 @@ void ap_sta_set_authorized(struct hostap
- 					  buf, ip_addr, keyid_buf);
- 	} else {
- 		wpa_msg(hapd->msg_ctx, MSG_INFO, AP_STA_DISCONNECTED "%s", buf);
-+		hostapd_ubus_notify(hapd, "disassoc", sta->addr);
- 
- 		if (hapd->msg_ctx_parent &&
- 		    hapd->msg_ctx_parent != hapd->msg_ctx)
---- a/src/ap/wpa_auth_glue.c
-+++ b/src/ap/wpa_auth_glue.c
-@@ -259,6 +259,7 @@ static void hostapd_wpa_auth_psk_failure
- 	struct hostapd_data *hapd = ctx;
- 	wpa_msg(hapd->msg_ctx, MSG_INFO, AP_STA_POSSIBLE_PSK_MISMATCH MACSTR,
- 		MAC2STR(addr));
-+	hostapd_ubus_notify(hapd, "key-mismatch", addr);
- }
- 
- 
---- a/wpa_supplicant/Makefile
-+++ b/wpa_supplicant/Makefile
-@@ -190,6 +190,12 @@ ifdef CONFIG_EAPOL_TEST
- CFLAGS += -Werror -DEAPOL_TEST
- endif
- 
-+ifdef CONFIG_UBUS
-+CFLAGS += -DUBUS_SUPPORT
-+OBJS += ubus.o
-+LIBS += -lubox -lubus
-+endif
-+
- ifdef CONFIG_CODE_COVERAGE
- CFLAGS += -O0 -fprofile-arcs -ftest-coverage
- LIBS += -lgcov
-@@ -956,6 +962,9 @@ ifdef CONFIG_CTRL_IFACE_MIB
- CFLAGS += -DCONFIG_CTRL_IFACE_MIB
- endif
- OBJS += ../src/ap/ctrl_iface_ap.o
-+ifdef CONFIG_UBUS
-+OBJS += ../src/ap/ubus.o
-+endif
- endif
- 
- CFLAGS += -DEAP_SERVER -DEAP_SERVER_IDENTITY
---- a/wpa_supplicant/wpa_supplicant.c
-+++ b/wpa_supplicant/wpa_supplicant.c
-@@ -6794,6 +6794,8 @@ struct wpa_supplicant * wpa_supplicant_a
- 	}
- #endif /* CONFIG_P2P */
- 
-+	wpas_ubus_add_bss(wpa_s);
-+
- 	return wpa_s;
- }
- 
-@@ -6820,6 +6822,8 @@ int wpa_supplicant_remove_iface(struct w
- 	struct wpa_supplicant *parent = wpa_s->parent;
- #endif /* CONFIG_MESH */
- 
-+	wpas_ubus_free_bss(wpa_s);
-+
- 	/* Remove interface from the global list of interfaces */
- 	prev = global->ifaces;
- 	if (prev == wpa_s) {
-@@ -7123,8 +7127,12 @@ int wpa_supplicant_run(struct wpa_global
- 	eloop_register_signal_terminate(wpa_supplicant_terminate, global);
- 	eloop_register_signal_reconfig(wpa_supplicant_reconfig, global);
- 
-+	wpas_ubus_add(global);
-+
- 	eloop_run();
- 
-+	wpas_ubus_free(global);
-+
- 	return 0;
- }
- 
---- a/wpa_supplicant/wpa_supplicant_i.h
-+++ b/wpa_supplicant/wpa_supplicant_i.h
-@@ -17,6 +17,7 @@
- #include "wps/wps_defs.h"
- #include "config_ssid.h"
- #include "wmm_ac.h"
-+#include "ubus.h"
- 
- extern const char *const wpa_supplicant_version;
- extern const char *const wpa_supplicant_license;
-@@ -310,6 +311,8 @@ struct wpa_global {
- #endif /* CONFIG_WIFI_DISPLAY */
- 
- 	struct psk_list_entry *add_psk; /* From group formation */
-+
-+	struct ubus_object ubus_global;
- };
- 
- 
-@@ -520,6 +523,7 @@ struct wpa_supplicant {
- 	unsigned char own_addr[ETH_ALEN];
- 	unsigned char perm_addr[ETH_ALEN];
- 	char ifname[100];
-+	struct wpas_ubus_bss ubus;
- #ifdef CONFIG_MATCH_IFACE
- 	int matched;
- #endif /* CONFIG_MATCH_IFACE */
---- a/wpa_supplicant/wps_supplicant.c
-+++ b/wpa_supplicant/wps_supplicant.c
-@@ -33,6 +33,7 @@
- #include "p2p/p2p.h"
- #include "p2p_supplicant.h"
- #include "wps_supplicant.h"
-+#include "ubus.h"
- 
- 
- #ifndef WPS_PIN_SCAN_IGNORE_SEL_REG
-@@ -392,6 +393,8 @@ static int wpa_supplicant_wps_cred(void
- 	wpa_hexdump_key(MSG_DEBUG, "WPS: Received Credential attribute",
- 			cred->cred_attr, cred->cred_attr_len);
- 
-+	wpas_ubus_notify(wpa_s, cred);
-+
- 	if (wpa_s->conf->wps_cred_processing == 1)
- 		return 0;
- 
---- a/hostapd/main.c
-+++ b/hostapd/main.c
-@@ -896,6 +896,7 @@ int main(int argc, char *argv[])
- 	}
- 
- 	hostapd_global_ctrl_iface_init(&interfaces);
-+	hostapd_ubus_add(&interfaces);
- 
- 	if (hostapd_global_run(&interfaces, daemonize, pid_file)) {
- 		wpa_printf(MSG_ERROR, "Failed to start eloop");
-@@ -905,6 +906,7 @@ int main(int argc, char *argv[])
- 	ret = 0;
- 
-  out:
-+	hostapd_ubus_free(&interfaces);
- 	hostapd_global_ctrl_iface_deinit(&interfaces);
- 	/* Deinitialize all interfaces */
- 	for (i = 0; i < interfaces.count; i++) {
---- a/wpa_supplicant/main.c
-+++ b/wpa_supplicant/main.c
-@@ -203,7 +203,7 @@ int main(int argc, char *argv[])
- 
- 	for (;;) {
- 		c = getopt(argc, argv,
--			   "b:Bc:C:D:de:f:g:G:hH:i:I:KLMm:No:O:p:P:qsTtuv::W");
-+			   "b:Bc:C:D:de:f:g:G:hH:i:I:KLMm:nNo:O:p:P:qsTtuv::W");
- 		if (c < 0)
- 			break;
- 		switch (c) {
-@@ -271,6 +271,9 @@ int main(int argc, char *argv[])
- 			params.conf_p2p_dev = optarg;
- 			break;
- #endif /* CONFIG_P2P */
-+		case 'n':
-+			iface_count = 0;
-+			break;
- 		case 'o':
- 			params.override_driver = optarg;
- 			break;
---- a/src/ap/rrm.c
-+++ b/src/ap/rrm.c
-@@ -89,6 +89,9 @@ static void hostapd_handle_beacon_report
- 		return;
- 	wpa_msg(hapd->msg_ctx, MSG_INFO, BEACON_RESP_RX MACSTR " %u %02x %s",
- 		MAC2STR(addr), token, rep_mode, report);
-+	if (len < sizeof(struct rrm_measurement_beacon_report))
-+		return;
-+	hostapd_ubus_notify_beacon_report(hapd, addr, token, rep_mode, (struct rrm_measurement_beacon_report*) pos, len);
- }
- 
- 
diff --git a/package/network/services/hostapd/patches/700-wifi-reload.patch b/package/network/services/hostapd/patches/700-wifi-reload.patch
deleted file mode 100644
index ceb92265dd..0000000000
--- a/package/network/services/hostapd/patches/700-wifi-reload.patch
+++ /dev/null
@@ -1,219 +0,0 @@
---- a/hostapd/config_file.c
-+++ b/hostapd/config_file.c
-@@ -2501,6 +2501,8 @@ static int hostapd_config_fill(struct ho
- 		bss->isolate = atoi(pos);
- 	} else if (os_strcmp(buf, "ap_max_inactivity") == 0) {
- 		bss->ap_max_inactivity = atoi(pos);
-+	} else if (os_strcmp(buf, "config_id") == 0) {
-+		bss->config_id = os_strdup(pos);
- 	} else if (os_strcmp(buf, "skip_inactivity_poll") == 0) {
- 		bss->skip_inactivity_poll = atoi(pos);
- 	} else if (os_strcmp(buf, "country_code") == 0) {
-@@ -3197,6 +3199,8 @@ static int hostapd_config_fill(struct ho
- 		}
- 	} else if (os_strcmp(buf, "acs_exclude_dfs") == 0) {
- 		conf->acs_exclude_dfs = atoi(pos);
-+	} else if (os_strcmp(buf, "radio_config_id") == 0) {
-+			conf->config_id = os_strdup(pos);
- 	} else if (os_strcmp(buf, "op_class") == 0) {
- 		conf->op_class = atoi(pos);
- 	} else if (os_strcmp(buf, "channel") == 0) {
---- a/src/ap/ap_config.c
-+++ b/src/ap/ap_config.c
-@@ -780,6 +780,7 @@ void hostapd_config_free_bss(struct host
- 	os_free(conf->radius_req_attr_sqlite);
- 	os_free(conf->rsn_preauth_interfaces);
- 	os_free(conf->ctrl_interface);
-+	os_free(conf->config_id);
- 	os_free(conf->ca_cert);
- 	os_free(conf->server_cert);
- 	os_free(conf->server_cert2);
-@@ -972,6 +973,7 @@ void hostapd_config_free(struct hostapd_
- 
- 	for (i = 0; i < conf->num_bss; i++)
- 		hostapd_config_free_bss(conf->bss[i]);
-+	os_free(conf->config_id);
- 	os_free(conf->bss);
- 	os_free(conf->supported_rates);
- 	os_free(conf->basic_rates);
---- a/src/ap/ap_config.h
-+++ b/src/ap/ap_config.h
-@@ -871,6 +871,7 @@ struct hostapd_bss_config {
- 	 */
- 	u8 mka_psk_set;
- #endif /* CONFIG_MACSEC */
-+	char *config_id;
- };
- 
- /**
-@@ -1062,6 +1063,7 @@ struct hostapd_config {
- 	unsigned int airtime_update_interval;
- #define AIRTIME_MODE_MAX (__AIRTIME_MODE_MAX - 1)
- #endif /* CONFIG_AIRTIME_POLICY */
-+	char *config_id;
- 
- 	u8 notify_mgmt_frames;
- };
---- a/src/ap/hostapd.c
-+++ b/src/ap/hostapd.c
-@@ -218,6 +218,10 @@ static int hostapd_iface_conf_changed(st
- {
- 	size_t i;
- 
-+	if (newconf->config_id != oldconf->config_id)
-+		if (strcmp(newconf->config_id, oldconf->config_id))
-+			return 1;
-+
- 	if (newconf->num_bss != oldconf->num_bss)
- 		return 1;
- 
-@@ -231,7 +235,7 @@ static int hostapd_iface_conf_changed(st
- }
- 
- 
--int hostapd_reload_config(struct hostapd_iface *iface)
-+int hostapd_reload_config(struct hostapd_iface *iface, int reconf)
- {
- 	struct hapd_interfaces *interfaces = iface->interfaces;
- 	struct hostapd_data *hapd = iface->bss[0];
-@@ -254,13 +258,16 @@ int hostapd_reload_config(struct hostapd
- 	if (newconf == NULL)
- 		return -1;
- 
--	hostapd_clear_old(iface);
--
- 	oldconf = hapd->iconf;
- 	if (hostapd_iface_conf_changed(newconf, oldconf)) {
- 		char *fname;
- 		int res;
- 
-+		if (reconf)
-+			return -1;
-+
-+		hostapd_clear_old(iface);
-+
- 		wpa_printf(MSG_DEBUG,
- 			   "Configuration changes include interface/BSS modification - force full disable+enable sequence");
- 		fname = os_strdup(iface->config_fname);
-@@ -285,6 +292,24 @@ int hostapd_reload_config(struct hostapd
- 			wpa_printf(MSG_ERROR,
- 				   "Failed to enable interface on config reload");
- 		return res;
-+	} else {
-+		for (j = 0; j < iface->num_bss; j++) {
-+			hapd = iface->bss[j];
-+			if (!hapd->config_id || strcmp(hapd->config_id, newconf->bss[j]->config_id)) {
-+				hostapd_flush_old_stations(iface->bss[j],
-+							   WLAN_REASON_PREV_AUTH_NOT_VALID);
-+#ifdef CONFIG_WEP
-+				hostapd_broadcast_wep_clear(iface->bss[j]);
-+#endif
-+
-+#ifndef CONFIG_NO_RADIUS
-+				/* TODO: update dynamic data based on changed configuration
-+				 * items (e.g., open/close sockets, etc.) */
-+				radius_client_flush(iface->bss[j]->radius, 0);
-+#endif /* CONFIG_NO_RADIUS */
-+				wpa_printf(MSG_INFO, "bss %zu changed", j);
-+			}
-+		}
- 	}
- 	iface->conf = newconf;
- 
-@@ -301,6 +326,12 @@ int hostapd_reload_config(struct hostapd
- 
- 	for (j = 0; j < iface->num_bss; j++) {
- 		hapd = iface->bss[j];
-+		if (hapd->config_id) {
-+			os_free(hapd->config_id);
-+			hapd->config_id = NULL;
-+		}
-+		if (newconf->bss[j]->config_id)
-+			hapd->config_id = strdup(newconf->bss[j]->config_id);
- 		hapd->iconf = newconf;
- 		hapd->conf = newconf->bss[j];
- 		hostapd_reload_bss(hapd);
-@@ -2366,6 +2397,10 @@ hostapd_alloc_bss_data(struct hostapd_if
- 	hapd->iconf = conf;
- 	hapd->conf = bss;
- 	hapd->iface = hapd_iface;
-+	if (bss && bss->config_id)
-+		hapd->config_id = strdup(bss->config_id);
-+	else
-+		hapd->config_id = NULL;
- 	if (conf)
- 		hapd->driver = conf->driver;
- 	hapd->ctrl_sock = -1;
---- a/src/ap/hostapd.h
-+++ b/src/ap/hostapd.h
-@@ -46,7 +46,7 @@ struct mesh_conf;
- struct hostapd_iface;
- 
- struct hapd_interfaces {
--	int (*reload_config)(struct hostapd_iface *iface);
-+	int (*reload_config)(struct hostapd_iface *iface, int reconf);
- 	struct hostapd_config * (*config_read_cb)(const char *config_fname);
- 	int (*ctrl_iface_init)(struct hostapd_data *hapd);
- 	void (*ctrl_iface_deinit)(struct hostapd_data *hapd);
-@@ -156,6 +156,7 @@ struct hostapd_data {
- 	struct hostapd_config *iconf;
- 	struct hostapd_bss_config *conf;
- 	struct hostapd_ubus_bss ubus;
-+	char *config_id;
- 	int interface_added; /* virtual interface added for this BSS */
- 	unsigned int started:1;
- 	unsigned int disabled:1;
-@@ -600,7 +601,7 @@ struct hostapd_iface {
- int hostapd_for_each_interface(struct hapd_interfaces *interfaces,
- 			       int (*cb)(struct hostapd_iface *iface,
- 					 void *ctx), void *ctx);
--int hostapd_reload_config(struct hostapd_iface *iface);
-+int hostapd_reload_config(struct hostapd_iface *iface, int reconf);
- void hostapd_reconfig_encryption(struct hostapd_data *hapd);
- struct hostapd_data *
- hostapd_alloc_bss_data(struct hostapd_iface *hapd_iface,
---- a/src/drivers/driver_nl80211.c
-+++ b/src/drivers/driver_nl80211.c
-@@ -4508,6 +4508,9 @@ static int wpa_driver_nl80211_set_ap(voi
- 	if (ret) {
- 		wpa_printf(MSG_DEBUG, "nl80211: Beacon set failed: %d (%s)",
- 			   ret, strerror(-ret));
-+		if (!bss->beacon_set)
-+			ret = 0;
-+		bss->beacon_set = 0;
- 	} else {
- 		bss->beacon_set = 1;
- 		nl80211_set_bss(bss, params->cts_protect, params->preamble,
---- a/hostapd/ctrl_iface.c
-+++ b/hostapd/ctrl_iface.c
-@@ -184,7 +184,7 @@ static int hostapd_ctrl_iface_update(str
- 	iface->interfaces->config_read_cb = hostapd_ctrl_iface_config_read;
- 	reload_opts = txt;
- 
--	hostapd_reload_config(iface);
-+	hostapd_reload_config(iface, 0);
- 
- 	iface->interfaces->config_read_cb = config_read_cb;
- }
---- a/hostapd/main.c
-+++ b/hostapd/main.c
-@@ -317,7 +317,7 @@ static void handle_term(int sig, void *s
- 
- static int handle_reload_iface(struct hostapd_iface *iface, void *ctx)
- {
--	if (hostapd_reload_config(iface) < 0) {
-+	if (hostapd_reload_config(iface, 0) < 0) {
- 		wpa_printf(MSG_WARNING, "Failed to read new configuration "
- 			   "file - continuing with old.");
- 	}
---- a/src/ap/wps_hostapd.c
-+++ b/src/ap/wps_hostapd.c
-@@ -315,7 +315,7 @@ static void wps_reload_config(void *eloo
- 
- 	wpa_printf(MSG_DEBUG, "WPS: Reload configuration data");
- 	if (iface->interfaces == NULL ||
--	    iface->interfaces->reload_config(iface) < 0) {
-+	    iface->interfaces->reload_config(iface, 1) < 0) {
- 		wpa_printf(MSG_WARNING, "WPS: Failed to reload the updated "
- 			   "configuration");
- 	}
diff --git a/package/network/services/hostapd/patches/710-vlan_no_bridge.patch b/package/network/services/hostapd/patches/710-vlan_no_bridge.patch
deleted file mode 100644
index 7de4e2c1d4..0000000000
--- a/package/network/services/hostapd/patches/710-vlan_no_bridge.patch
+++ /dev/null
@@ -1,33 +0,0 @@
---- a/src/ap/ap_config.h
-+++ b/src/ap/ap_config.h
-@@ -115,6 +115,7 @@ struct hostapd_ssid {
- #define DYNAMIC_VLAN_OPTIONAL 1
- #define DYNAMIC_VLAN_REQUIRED 2
- 	int dynamic_vlan;
-+	int vlan_no_bridge;
- #define DYNAMIC_VLAN_NAMING_WITHOUT_DEVICE 0
- #define DYNAMIC_VLAN_NAMING_WITH_DEVICE 1
- #define DYNAMIC_VLAN_NAMING_END 2
---- a/src/ap/vlan_full.c
-+++ b/src/ap/vlan_full.c
-@@ -466,6 +466,9 @@ void vlan_newlink(const char *ifname, st
- 
- 	wpa_printf(MSG_DEBUG, "VLAN: vlan_newlink(%s)", ifname);
- 
-+	if (hapd->conf->ssid.vlan_no_bridge)
-+		return;
-+
- 	for (vlan = hapd->conf->vlan; vlan; vlan = vlan->next) {
- 		if (vlan->configured ||
- 		    os_strcmp(ifname, vlan->ifname) != 0)
---- a/hostapd/config_file.c
-+++ b/hostapd/config_file.c
-@@ -3400,6 +3400,8 @@ static int hostapd_config_fill(struct ho
- #ifndef CONFIG_NO_VLAN
- 	} else if (os_strcmp(buf, "dynamic_vlan") == 0) {
- 		bss->ssid.dynamic_vlan = atoi(pos);
-+	} else if (os_strcmp(buf, "vlan_no_bridge") == 0) {
-+		bss->ssid.vlan_no_bridge = atoi(pos);
- 	} else if (os_strcmp(buf, "per_sta_vif") == 0) {
- 		bss->ssid.per_sta_vif = atoi(pos);
- 	} else if (os_strcmp(buf, "vlan_file") == 0) {
diff --git a/package/network/services/hostapd/patches/711-wds_bridge_force.patch b/package/network/services/hostapd/patches/711-wds_bridge_force.patch
deleted file mode 100644
index 01507b6d36..0000000000
--- a/package/network/services/hostapd/patches/711-wds_bridge_force.patch
+++ /dev/null
@@ -1,22 +0,0 @@
---- a/hostapd/config_file.c
-+++ b/hostapd/config_file.c
-@@ -2405,6 +2405,8 @@ static int hostapd_config_fill(struct ho
- 			   sizeof(conf->bss[0]->iface));
- 	} else if (os_strcmp(buf, "bridge") == 0) {
- 		os_strlcpy(bss->bridge, pos, sizeof(bss->bridge));
-+		if (!bss->wds_bridge[0])
-+			os_strlcpy(bss->wds_bridge, pos, sizeof(bss->wds_bridge));
- 	} else if (os_strcmp(buf, "vlan_bridge") == 0) {
- 		os_strlcpy(bss->vlan_bridge, pos, sizeof(bss->vlan_bridge));
- 	} else if (os_strcmp(buf, "wds_bridge") == 0) {
---- a/src/ap/ap_drv_ops.c
-+++ b/src/ap/ap_drv_ops.c
-@@ -340,8 +340,6 @@ int hostapd_set_wds_sta(struct hostapd_d
- 		return -1;
- 	if (hapd->conf->wds_bridge[0])
- 		bridge = hapd->conf->wds_bridge;
--	else if (hapd->conf->bridge[0])
--		bridge = hapd->conf->bridge;
- 	return hapd->driver->set_wds_sta(hapd->drv_priv, addr, aid, val,
- 					 bridge, ifname_wds);
- }
diff --git a/package/network/services/hostapd/patches/730-ft_iface.patch b/package/network/services/hostapd/patches/730-ft_iface.patch
deleted file mode 100644
index c1adf1ffcf..0000000000
--- a/package/network/services/hostapd/patches/730-ft_iface.patch
+++ /dev/null
@@ -1,38 +0,0 @@
---- a/hostapd/config_file.c
-+++ b/hostapd/config_file.c
-@@ -3069,6 +3069,8 @@ static int hostapd_config_fill(struct ho
- 		wpa_printf(MSG_INFO,
- 			   "Line %d: Obsolete peerkey parameter ignored", line);
- #ifdef CONFIG_IEEE80211R_AP
-+	} else if (os_strcmp(buf, "ft_iface") == 0) {
-+		os_strlcpy(bss->ft_iface, pos, sizeof(bss->ft_iface));
- 	} else if (os_strcmp(buf, "mobility_domain") == 0) {
- 		if (os_strlen(pos) != 2 * MOBILITY_DOMAIN_ID_LEN ||
- 		    hexstr2bin(pos, bss->mobility_domain,
---- a/src/ap/ap_config.h
-+++ b/src/ap/ap_config.h
-@@ -284,6 +284,7 @@ struct airtime_sta_weight {
- struct hostapd_bss_config {
- 	char iface[IFNAMSIZ + 1];
- 	char bridge[IFNAMSIZ + 1];
-+	char ft_iface[IFNAMSIZ + 1];
- 	char vlan_bridge[IFNAMSIZ + 1];
- 	char wds_bridge[IFNAMSIZ + 1];
- 
---- a/src/ap/wpa_auth_glue.c
-+++ b/src/ap/wpa_auth_glue.c
-@@ -1511,8 +1511,12 @@ int hostapd_setup_wpa(struct hostapd_dat
- 	    wpa_key_mgmt_ft(hapd->conf->wpa_key_mgmt)) {
- 		const char *ft_iface;
- 
--		ft_iface = hapd->conf->bridge[0] ? hapd->conf->bridge :
--			   hapd->conf->iface;
-+		if (hapd->conf->ft_iface[0])
-+			ft_iface = hapd->conf->ft_iface;
-+		else if (hapd->conf->bridge[0])
-+			ft_iface = hapd->conf->bridge;
-+		else
-+			ft_iface = hapd->conf->iface;
- 		hapd->l2 = l2_packet_init(ft_iface, NULL, ETH_P_RRB,
- 					  hostapd_rrb_receive, hapd, 1);
- 		if (!hapd->l2) {
diff --git a/package/network/services/hostapd/patches/740-snoop_iface.patch b/package/network/services/hostapd/patches/740-snoop_iface.patch
deleted file mode 100644
index 15aaf4b8e4..0000000000
--- a/package/network/services/hostapd/patches/740-snoop_iface.patch
+++ /dev/null
@@ -1,66 +0,0 @@
---- a/src/ap/ap_config.h
-+++ b/src/ap/ap_config.h
-@@ -285,6 +285,7 @@ struct hostapd_bss_config {
- 	char iface[IFNAMSIZ + 1];
- 	char bridge[IFNAMSIZ + 1];
- 	char ft_iface[IFNAMSIZ + 1];
-+	char snoop_iface[IFNAMSIZ + 1];
- 	char vlan_bridge[IFNAMSIZ + 1];
- 	char wds_bridge[IFNAMSIZ + 1];
- 
---- a/src/ap/x_snoop.c
-+++ b/src/ap/x_snoop.c
-@@ -31,14 +31,16 @@ int x_snoop_init(struct hostapd_data *ha
- 		return -1;
- 	}
- 
--	if (hostapd_drv_br_port_set_attr(hapd, DRV_BR_PORT_ATTR_HAIRPIN_MODE,
-+	if (!conf->snoop_iface[0] &&
-+	    hostapd_drv_br_port_set_attr(hapd, DRV_BR_PORT_ATTR_HAIRPIN_MODE,
- 					 1)) {
- 		wpa_printf(MSG_DEBUG,
- 			   "x_snoop: Failed to enable hairpin_mode on the bridge port");
- 		return -1;
- 	}
- 
--	if (hostapd_drv_br_port_set_attr(hapd, DRV_BR_PORT_ATTR_PROXYARP, 1)) {
-+	if (!conf->snoop_iface[0] &&
-+	    hostapd_drv_br_port_set_attr(hapd, DRV_BR_PORT_ATTR_PROXYARP, 1)) {
- 		wpa_printf(MSG_DEBUG,
- 			   "x_snoop: Failed to enable proxyarp on the bridge port");
- 		return -1;
-@@ -52,7 +54,8 @@ int x_snoop_init(struct hostapd_data *ha
- 	}
- 
- #ifdef CONFIG_IPV6
--	if (hostapd_drv_br_set_net_param(hapd, DRV_BR_MULTICAST_SNOOPING, 1)) {
-+	if (!conf->snoop_iface[0] &&
-+	    hostapd_drv_br_set_net_param(hapd, DRV_BR_MULTICAST_SNOOPING, 1)) {
- 		wpa_printf(MSG_DEBUG,
- 			   "x_snoop: Failed to enable multicast snooping on the bridge");
- 		return -1;
-@@ -71,8 +74,12 @@ x_snoop_get_l2_packet(struct hostapd_dat
- {
- 	struct hostapd_bss_config *conf = hapd->conf;
- 	struct l2_packet_data *l2;
-+	const char *ifname = conf->bridge;
- 
--	l2 = l2_packet_init(conf->bridge, NULL, ETH_P_ALL, handler, hapd, 1);
-+	if (conf->snoop_iface[0])
-+		ifname = conf->snoop_iface;
-+
-+	l2 = l2_packet_init(ifname, NULL, ETH_P_ALL, handler, hapd, 1);
- 	if (l2 == NULL) {
- 		wpa_printf(MSG_DEBUG,
- 			   "x_snoop: Failed to initialize L2 packet processing %s",
---- a/hostapd/config_file.c
-+++ b/hostapd/config_file.c
-@@ -2407,6 +2407,8 @@ static int hostapd_config_fill(struct ho
- 		os_strlcpy(bss->bridge, pos, sizeof(bss->bridge));
- 		if (!bss->wds_bridge[0])
- 			os_strlcpy(bss->wds_bridge, pos, sizeof(bss->wds_bridge));
-+	} else if (os_strcmp(buf, "snoop_iface") == 0) {
-+		os_strlcpy(bss->snoop_iface, pos, sizeof(bss->snoop_iface));
- 	} else if (os_strcmp(buf, "vlan_bridge") == 0) {
- 		os_strlcpy(bss->vlan_bridge, pos, sizeof(bss->vlan_bridge));
- 	} else if (os_strcmp(buf, "wds_bridge") == 0) {
diff --git a/package/network/services/hostapd/patches/750-qos_map_set_without_interworking.patch b/package/network/services/hostapd/patches/750-qos_map_set_without_interworking.patch
deleted file mode 100644
index 94f4a2b297..0000000000
--- a/package/network/services/hostapd/patches/750-qos_map_set_without_interworking.patch
+++ /dev/null
@@ -1,112 +0,0 @@
---- a/hostapd/config_file.c
-+++ b/hostapd/config_file.c
-@@ -1711,6 +1711,8 @@ static int parse_anqp_elem(struct hostap
- 	return 0;
- }
- 
-+#endif /* CONFIG_INTERWORKING */
-+
- 
- static int parse_qos_map_set(struct hostapd_bss_config *bss,
- 			     char *buf, int line)
-@@ -1752,8 +1754,6 @@ static int parse_qos_map_set(struct host
- 	return 0;
- }
- 
--#endif /* CONFIG_INTERWORKING */
--
- 
- #ifdef CONFIG_HS20
- static int hs20_parse_conn_capab(struct hostapd_bss_config *bss, char *buf,
-@@ -4050,10 +4050,10 @@ static int hostapd_config_fill(struct ho
- 		bss->gas_frag_limit = val;
- 	} else if (os_strcmp(buf, "gas_comeback_delay") == 0) {
- 		bss->gas_comeback_delay = atoi(pos);
-+#endif /* CONFIG_INTERWORKING */
- 	} else if (os_strcmp(buf, "qos_map_set") == 0) {
- 		if (parse_qos_map_set(bss, pos, line) < 0)
- 			return 1;
--#endif /* CONFIG_INTERWORKING */
- #ifdef CONFIG_RADIUS_TEST
- 	} else if (os_strcmp(buf, "dump_msk_file") == 0) {
- 		os_free(bss->dump_msk_file);
---- a/src/ap/hostapd.c
-+++ b/src/ap/hostapd.c
-@@ -1386,6 +1386,7 @@ static int hostapd_setup_bss(struct host
- 		wpa_printf(MSG_ERROR, "GAS server initialization failed");
- 		return -1;
- 	}
-+#endif /* CONFIG_INTERWORKING */
- 
- 	if (conf->qos_map_set_len &&
- 	    hostapd_drv_set_qos_map(hapd, conf->qos_map_set,
-@@ -1393,7 +1394,6 @@ static int hostapd_setup_bss(struct host
- 		wpa_printf(MSG_ERROR, "Failed to initialize QoS Map");
- 		return -1;
- 	}
--#endif /* CONFIG_INTERWORKING */
- 
- 	if (conf->bss_load_update_period && bss_load_update_init(hapd)) {
- 		wpa_printf(MSG_ERROR, "BSS Load initialization failed");
---- a/src/ap/drv_callbacks.c
-+++ b/src/ap/drv_callbacks.c
-@@ -245,12 +245,10 @@ int hostapd_notif_assoc(struct hostapd_d
- 	}
- #endif /* NEED_AP_MLME */
- 
--#ifdef CONFIG_INTERWORKING
- 	if (elems.ext_capab && elems.ext_capab_len > 4) {
- 		if (elems.ext_capab[4] & 0x01)
- 			sta->qos_map_enabled = 1;
- 	}
--#endif /* CONFIG_INTERWORKING */
- 
- #ifdef CONFIG_HS20
- 	wpabuf_free(sta->hs20_ie);
---- a/src/ap/ieee802_11.c
-+++ b/src/ap/ieee802_11.c
-@@ -2875,13 +2875,11 @@ static u16 copy_supp_rates(struct hostap
- static u16 check_ext_capab(struct hostapd_data *hapd, struct sta_info *sta,
- 			   const u8 *ext_capab_ie, size_t ext_capab_ie_len)
- {
--#ifdef CONFIG_INTERWORKING
- 	/* check for QoS Map support */
- 	if (ext_capab_ie_len >= 5) {
- 		if (ext_capab_ie[4] & 0x01)
- 			sta->qos_map_enabled = 1;
- 	}
--#endif /* CONFIG_INTERWORKING */
- 
- 	if (ext_capab_ie_len > 0) {
- 		sta->ecsa_supported = !!(ext_capab_ie[0] & BIT(2));
---- a/wpa_supplicant/events.c
-+++ b/wpa_supplicant/events.c
-@@ -2500,8 +2500,6 @@ void wnm_bss_keep_alive_deinit(struct wp
- }
- 
- 
--#ifdef CONFIG_INTERWORKING
--
- static int wpas_qos_map_set(struct wpa_supplicant *wpa_s, const u8 *qos_map,
- 			    size_t len)
- {
-@@ -2534,8 +2532,6 @@ static void interworking_process_assoc_r
- 	}
- }
- 
--#endif /* CONFIG_INTERWORKING */
--
- 
- static void multi_ap_process_assoc_resp(struct wpa_supplicant *wpa_s,
- 					const u8 *ies, size_t ies_len)
-@@ -2669,10 +2665,8 @@ static int wpa_supplicant_event_associnf
- 		wnm_process_assoc_resp(wpa_s, data->assoc_info.resp_ies,
- 				       data->assoc_info.resp_ies_len);
- #endif /* CONFIG_WNM */
--#ifdef CONFIG_INTERWORKING
- 		interworking_process_assoc_resp(wpa_s, data->assoc_info.resp_ies,
- 						data->assoc_info.resp_ies_len);
--#endif /* CONFIG_INTERWORKING */
- 		if (wpa_s->hw_capab == CAPAB_VHT &&
- 		    get_ie(data->assoc_info.resp_ies,
- 			   data->assoc_info.resp_ies_len, WLAN_EID_VHT_CAP))
diff --git a/package/network/services/hostapd/patches/800-dfs-enter-DFS-state-if-no-available-channel-is-found.patch b/package/network/services/hostapd/patches/800-dfs-enter-DFS-state-if-no-available-channel-is-found.patch
deleted file mode 100644
index 3e4638d7ff..0000000000
--- a/package/network/services/hostapd/patches/800-dfs-enter-DFS-state-if-no-available-channel-is-found.patch
+++ /dev/null
@@ -1,37 +0,0 @@
-From cefc52e6b93731c713f1bba1cb5e7e92105b758b Mon Sep 17 00:00:00 2001
-From: David Bauer <mail@david-bauer.net>
-Date: Fri, 3 Jul 2020 23:00:34 +0200
-Subject: [PATCH] dfs: enter DFS state if no available channel is found
-
-Previously hostapd would not stop transmitting when a DFS event was
-detected and no available channel to switch to was available.
-
-Disable and re-enable the interface to enter DFS state. This way, TX
-does not happen until the kernel notifies hostapd about the NOP
-expiring.
-
-Signed-off-by: David Bauer <mail@david-bauer.net>
----
- src/ap/dfs.c | 11 +++++++++--
- 1 file changed, 9 insertions(+), 2 deletions(-)
-
---- a/src/ap/dfs.c
-+++ b/src/ap/dfs.c
-@@ -1086,8 +1086,15 @@ static int hostapd_dfs_start_channel_swi
- 						  &oper_centr_freq_seg0_idx,
- 						  &oper_centr_freq_seg1_idx,
- 						  &skip_radar);
--		if (!channel)
--			return err;
-+		if (!channel) {
-+			/*
-+			 * Toggle interface state to enter DFS state
-+			 * until NOP is finished.
-+			 */
-+			hostapd_disable_iface(iface);
-+			hostapd_enable_iface(iface);
-+			return 0;
-+		}
- 		if (!skip_radar) {
- 			iface->freq = channel->freq;
- 			iface->conf->channel = channel->chan;
diff --git a/package/network/services/hostapd/patches/801-P2P-Fix-copying-of-secondary-device-types-for-P2P-gr.patch b/package/network/services/hostapd/patches/801-P2P-Fix-copying-of-secondary-device-types-for-P2P-gr.patch
deleted file mode 100644
index 944f7d71c9..0000000000
--- a/package/network/services/hostapd/patches/801-P2P-Fix-copying-of-secondary-device-types-for-P2P-gr.patch
+++ /dev/null
@@ -1,33 +0,0 @@
-From 947272febe24a8f0ea828b5b2f35f13c3821901e Mon Sep 17 00:00:00 2001
-From: Jouni Malinen <jouni@codeaurora.org>
-Date: Mon, 9 Nov 2020 11:43:12 +0200
-Subject: [PATCH] P2P: Fix copying of secondary device types for P2P group
- client
-
-Parsing and copying of WPS secondary device types list was verifying
-that the contents is not too long for the internal maximum in the case
-of WPS messages, but similar validation was missing from the case of P2P
-group information which encodes this information in a different
-attribute. This could result in writing beyond the memory area assigned
-for these entries and corrupting memory within an instance of struct
-p2p_device. This could result in invalid operations and unexpected
-behavior when trying to free pointers from that corrupted memory.
-
-Credit to OSS-Fuzz: https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=27269
-Fixes: e57ae6e19edf ("P2P: Keep track of secondary device types for peers")
-Signed-off-by: Jouni Malinen <jouni@codeaurora.org>
----
- src/p2p/p2p.c | 2 ++
- 1 file changed, 2 insertions(+)
-
---- a/src/p2p/p2p.c
-+++ b/src/p2p/p2p.c
-@@ -453,6 +453,8 @@ static void p2p_copy_client_info(struct
- 	dev->info.config_methods = cli->config_methods;
- 	os_memcpy(dev->info.pri_dev_type, cli->pri_dev_type, 8);
- 	dev->info.wps_sec_dev_type_list_len = 8 * cli->num_sec_dev_types;
-+	if (dev->info.wps_sec_dev_type_list_len > WPS_SEC_DEV_TYPE_MAX_LEN)
-+		dev->info.wps_sec_dev_type_list_len = WPS_SEC_DEV_TYPE_MAX_LEN;
- 	os_memcpy(dev->info.wps_sec_dev_type_list, cli->sec_dev_types,
- 		  dev->info.wps_sec_dev_type_list_len);
- }
diff --git a/package/network/services/hostapd/patches/802-wolfssl-init-RNG-with-ECC-key.patch b/package/network/services/hostapd/patches/802-wolfssl-init-RNG-with-ECC-key.patch
deleted file mode 100644
index 84fc1c9351..0000000000
--- a/package/network/services/hostapd/patches/802-wolfssl-init-RNG-with-ECC-key.patch
+++ /dev/null
@@ -1,43 +0,0 @@
-From 21ce83b4ae2b9563175fdb4fc4312096cc399cf8 Mon Sep 17 00:00:00 2001
-From: David Bauer <mail@david-bauer.net>
-Date: Wed, 5 May 2021 00:44:34 +0200
-Subject: [PATCH] wolfssl: add RNG to EC key
-
-Since upstream commit 6467de5a8840 ("Randomize z ordinates in
-scalar mult when timing resistant") WolfSSL requires a RNG for
-the EC key when built hardened which is the default.
-
-Set the RNG for the EC key to fix connections for OWE clients.
-
-Signed-off-by: David Bauer <mail@david-bauer.net>
----
- src/crypto/crypto_wolfssl.c | 4 ++++
- 1 file changed, 4 insertions(+)
-
---- a/src/crypto/crypto_wolfssl.c
-+++ b/src/crypto/crypto_wolfssl.c
-@@ -1303,6 +1303,7 @@ int ecc_projective_add_point(ecc_point *
- 
- struct crypto_ec {
- 	ecc_key key;
-+	WC_RNG rng;
- 	mp_int a;
- 	mp_int prime;
- 	mp_int order;
-@@ -1357,6 +1358,8 @@ struct crypto_ec * crypto_ec_init(int gr
- 		return NULL;
- 
- 	if (wc_ecc_init(&e->key) != 0 ||
-+	    wc_InitRng(&e->rng) != 0 ||
-+	    wc_ecc_set_rng(&e->key, &e->rng) != 0 ||
- 	    wc_ecc_set_curve(&e->key, 0, curve_id) != 0 ||
- 	    mp_init(&e->a) != MP_OKAY ||
- 	    mp_init(&e->prime) != MP_OKAY ||
-@@ -1388,6 +1391,7 @@ void crypto_ec_deinit(struct crypto_ec*
- 	mp_clear(&e->order);
- 	mp_clear(&e->prime);
- 	mp_clear(&e->a);
-+	wc_FreeRng(&e->rng);
- 	wc_ecc_free(&e->key);
- 	os_free(e);
- }
diff --git a/package/network/services/hostapd/src/src/ap/ubus.c b/package/network/services/hostapd/src/src/ap/ubus.c
deleted file mode 100644
index 0575fe2572..0000000000
--- a/package/network/services/hostapd/src/src/ap/ubus.c
+++ /dev/null
@@ -1,1557 +0,0 @@
-/*
- * hostapd / ubus support
- * Copyright (c) 2013, Felix Fietkau <nbd@nbd.name>
- *
- * This software may be distributed under the terms of the BSD license.
- * See README for more details.
- */
-
-#include "utils/includes.h"
-#include "utils/common.h"
-#include "utils/eloop.h"
-#include "utils/wpabuf.h"
-#include "common/ieee802_11_defs.h"
-#include "hostapd.h"
-#include "neighbor_db.h"
-#include "wps_hostapd.h"
-#include "sta_info.h"
-#include "ubus.h"
-#include "ap_drv_ops.h"
-#include "beacon.h"
-#include "rrm.h"
-#include "wnm_ap.h"
-#include "taxonomy.h"
-
-static struct ubus_context *ctx;
-static struct blob_buf b;
-static int ctx_ref;
-
-static inline struct hapd_interfaces *get_hapd_interfaces_from_object(struct ubus_object *obj)
-{
-	return container_of(obj, struct hapd_interfaces, ubus);
-}
-
-static inline struct hostapd_data *get_hapd_from_object(struct ubus_object *obj)
-{
-	return container_of(obj, struct hostapd_data, ubus.obj);
-}
-
-struct ubus_banned_client {
-	struct avl_node avl;
-	u8 addr[ETH_ALEN];
-};
-
-static void ubus_receive(int sock, void *eloop_ctx, void *sock_ctx)
-{
-	struct ubus_context *ctx = eloop_ctx;
-	ubus_handle_event(ctx);
-}
-
-static void ubus_reconnect_timeout(void *eloop_data, void *user_ctx)
-{
-	if (ubus_reconnect(ctx, NULL)) {
-		eloop_register_timeout(1, 0, ubus_reconnect_timeout, ctx, NULL);
-		return;
-	}
-
-	eloop_register_read_sock(ctx->sock.fd, ubus_receive, ctx, NULL);
-}
-
-static void hostapd_ubus_connection_lost(struct ubus_context *ctx)
-{
-	eloop_unregister_read_sock(ctx->sock.fd);
-	eloop_register_timeout(1, 0, ubus_reconnect_timeout, ctx, NULL);
-}
-
-static bool hostapd_ubus_init(void)
-{
-	if (ctx)
-		return true;
-
-	ctx = ubus_connect(NULL);
-	if (!ctx)
-		return false;
-
-	ctx->connection_lost = hostapd_ubus_connection_lost;
-	eloop_register_read_sock(ctx->sock.fd, ubus_receive, ctx, NULL);
-	return true;
-}
-
-static void hostapd_ubus_ref_inc(void)
-{
-	ctx_ref++;
-}
-
-static void hostapd_ubus_ref_dec(void)
-{
-	ctx_ref--;
-	if (!ctx)
-		return;
-
-	if (ctx_ref)
-		return;
-
-	eloop_unregister_read_sock(ctx->sock.fd);
-	ubus_free(ctx);
-	ctx = NULL;
-}
-
-void hostapd_ubus_add_iface(struct hostapd_iface *iface)
-{
-	if (!hostapd_ubus_init())
-		return;
-}
-
-void hostapd_ubus_free_iface(struct hostapd_iface *iface)
-{
-	if (!ctx)
-		return;
-}
-
-static void hostapd_notify_ubus(struct ubus_object *obj, char *bssname, char *event)
-{
-	char *event_type;
-
-	if (!ctx || !obj)
-		return;
-
-	if (asprintf(&event_type, "bss.%s", event) < 0)
-		return;
-
-	blob_buf_init(&b, 0);
-	blobmsg_add_string(&b, "name", bssname);
-	ubus_notify(ctx, obj, event_type, b.head, -1);
-	free(event_type);
-}
-
-static void hostapd_send_procd_event(char *bssname, char *event)
-{
-	char *name, *s;
-	uint32_t id;
-	void *v;
-
-	if (!ctx || ubus_lookup_id(ctx, "service", &id))
-		return;
-
-	if (asprintf(&name, "hostapd.%s.%s", bssname, event) < 0)
-		return;
-
-	blob_buf_init(&b, 0);
-
-	s = blobmsg_alloc_string_buffer(&b, "type", strlen(name) + 1);
-	sprintf(s, "%s", name);
-	blobmsg_add_string_buffer(&b);
-
-	v = blobmsg_open_table(&b, "data");
-	blobmsg_close_table(&b, v);
-
-	ubus_invoke(ctx, id, "event", b.head, NULL, NULL, 1000);
-
-	free(name);
-}
-
-static void hostapd_send_shared_event(struct ubus_object *obj, char *bssname, char *event)
-{
-	hostapd_send_procd_event(bssname, event);
-	hostapd_notify_ubus(obj, bssname, event);
-}
-
-static void
-hostapd_bss_del_ban(void *eloop_data, void *user_ctx)
-{
-	struct ubus_banned_client *ban = eloop_data;
-	struct hostapd_data *hapd = user_ctx;
-
-	avl_delete(&hapd->ubus.banned, &ban->avl);
-	free(ban);
-}
-
-static void
-hostapd_bss_ban_client(struct hostapd_data *hapd, u8 *addr, int time)
-{
-	struct ubus_banned_client *ban;
-
-	if (time < 0)
-		time = 0;
-
-	ban = avl_find_element(&hapd->ubus.banned, addr, ban, avl);
-	if (!ban) {
-		if (!time)
-			return;
-
-		ban = os_zalloc(sizeof(*ban));
-		memcpy(ban->addr, addr, sizeof(ban->addr));
-		ban->avl.key = ban->addr;
-		avl_insert(&hapd->ubus.banned, &ban->avl);
-	} else {
-		eloop_cancel_timeout(hostapd_bss_del_ban, ban, hapd);
-		if (!time) {
-			hostapd_bss_del_ban(ban, hapd);
-			return;
-		}
-	}
-
-	eloop_register_timeout(0, time * 1000, hostapd_bss_del_ban, ban, hapd);
-}
-
-static int
-hostapd_bss_reload(struct ubus_context *ctx, struct ubus_object *obj,
-		   struct ubus_request_data *req, const char *method,
-		   struct blob_attr *msg)
-{
-	struct hostapd_data *hapd = container_of(obj, struct hostapd_data, ubus.obj);
-	int ret = hostapd_reload_config(hapd->iface, 1);
-
-	hostapd_send_shared_event(&hapd->iface->interfaces->ubus, hapd->conf->iface, "reload");
-	return ret;
-}
-
-
-static void
-hostapd_parse_vht_map_blobmsg(uint16_t map)
-{
-	char label[4];
-	int16_t val;
-	int i;
-
-	for (i = 0; i < 8; i++) {
-		snprintf(label, 4, "%dss", i + 1);
-
-		val = (map & (BIT(1) | BIT(0))) + 7;
-		blobmsg_add_u16(&b, label, val == 10 ? -1 : val);
-		map = map >> 2;
-	}
-}
-
-static void
-hostapd_parse_vht_capab_blobmsg(struct ieee80211_vht_capabilities *vhtc)
-{
-	void *supported_mcs;
-	void *map;
-	int i;
-
-	static const struct {
-		const char *name;
-		uint32_t flag;
-	} vht_capas[] = {
-		{ "su_beamformee", VHT_CAP_SU_BEAMFORMEE_CAPABLE },
-		{ "mu_beamformee", VHT_CAP_MU_BEAMFORMEE_CAPABLE },
-	};
-
-	for (i = 0; i < ARRAY_SIZE(vht_capas); i++)
-		blobmsg_add_u8(&b, vht_capas[i].name,
-				!!(vhtc->vht_capabilities_info & vht_capas[i].flag));
-
-	supported_mcs = blobmsg_open_table(&b, "mcs_map");
-
-	/* RX map */
-	map = blobmsg_open_table(&b, "rx");
-	hostapd_parse_vht_map_blobmsg(le_to_host16(vhtc->vht_supported_mcs_set.rx_map));
-	blobmsg_close_table(&b, map);
-
-	/* TX map */
-	map = blobmsg_open_table(&b, "tx");
-	hostapd_parse_vht_map_blobmsg(le_to_host16(vhtc->vht_supported_mcs_set.tx_map));
-	blobmsg_close_table(&b, map);
-
-	blobmsg_close_table(&b, supported_mcs);
-}
-
-static void
-hostapd_parse_capab_blobmsg(struct sta_info *sta)
-{
-	void *r, *v;
-
-	v = blobmsg_open_table(&b, "capabilities");
-
-	if (sta->vht_capabilities) {
-		r = blobmsg_open_table(&b, "vht");
-		hostapd_parse_vht_capab_blobmsg(sta->vht_capabilities);
-		blobmsg_close_table(&b, r);
-	}
-
-	/* ToDo: Add HT / HE capability parsing */
-
-	blobmsg_close_table(&b, v);
-}
-
-static int
-hostapd_bss_get_clients(struct ubus_context *ctx, struct ubus_object *obj,
-			struct ubus_request_data *req, const char *method,
-			struct blob_attr *msg)
-{
-	struct hostapd_data *hapd = container_of(obj, struct hostapd_data, ubus.obj);
-	struct hostap_sta_driver_data sta_driver_data;
-	struct sta_info *sta;
-	void *list, *c;
-	char mac_buf[20];
-	static const struct {
-		const char *name;
-		uint32_t flag;
-	} sta_flags[] = {
-		{ "auth", WLAN_STA_AUTH },
-		{ "assoc", WLAN_STA_ASSOC },
-		{ "authorized", WLAN_STA_AUTHORIZED },
-		{ "preauth", WLAN_STA_PREAUTH },
-		{ "wds", WLAN_STA_WDS },
-		{ "wmm", WLAN_STA_WMM },
-		{ "ht", WLAN_STA_HT },
-		{ "vht", WLAN_STA_VHT },
-		{ "wps", WLAN_STA_WPS },
-		{ "mfp", WLAN_STA_MFP },
-	};
-
-	blob_buf_init(&b, 0);
-	blobmsg_add_u32(&b, "freq", hapd->iface->freq);
-	list = blobmsg_open_table(&b, "clients");
-	for (sta = hapd->sta_list; sta; sta = sta->next) {
-		void *r;
-		int i;
-
-		sprintf(mac_buf, MACSTR, MAC2STR(sta->addr));
-		c = blobmsg_open_table(&b, mac_buf);
-		for (i = 0; i < ARRAY_SIZE(sta_flags); i++)
-			blobmsg_add_u8(&b, sta_flags[i].name,
-				       !!(sta->flags & sta_flags[i].flag));
-
-		r = blobmsg_open_array(&b, "rrm");
-		for (i = 0; i < ARRAY_SIZE(sta->rrm_enabled_capa); i++)
-			blobmsg_add_u32(&b, "", sta->rrm_enabled_capa[i]);
-		blobmsg_close_array(&b, r);
-		blobmsg_add_u32(&b, "aid", sta->aid);
-#ifdef CONFIG_TAXONOMY
-		r = blobmsg_alloc_string_buffer(&b, "signature", 1024);
-		if (retrieve_sta_taxonomy(hapd, sta, r, 1024) > 0)
-			blobmsg_add_string_buffer(&b);
-#endif
-
-		/* Driver information */
-		if (hostapd_drv_read_sta_data(hapd, &sta_driver_data, sta->addr) >= 0) {
-			r = blobmsg_open_table(&b, "bytes");
-			blobmsg_add_u64(&b, "rx", sta_driver_data.rx_bytes);
-			blobmsg_add_u64(&b, "tx", sta_driver_data.tx_bytes);
-			blobmsg_close_table(&b, r);
-			r = blobmsg_open_table(&b, "airtime");
-			blobmsg_add_u64(&b, "rx", sta_driver_data.rx_airtime);
-			blobmsg_add_u64(&b, "tx", sta_driver_data.tx_airtime);
-			blobmsg_close_table(&b, r);
-			r = blobmsg_open_table(&b, "packets");
-			blobmsg_add_u32(&b, "rx", sta_driver_data.rx_packets);
-			blobmsg_add_u32(&b, "tx", sta_driver_data.tx_packets);
-			blobmsg_close_table(&b, r);
-			r = blobmsg_open_table(&b, "rate");
-			/* Rate in kbits */
-			blobmsg_add_u32(&b, "rx", sta_driver_data.current_rx_rate * 100);
-			blobmsg_add_u32(&b, "tx", sta_driver_data.current_tx_rate * 100);
-			blobmsg_close_table(&b, r);
-			blobmsg_add_u32(&b, "signal", sta_driver_data.signal);
-		}
-
-		hostapd_parse_capab_blobmsg(sta);
-
-		blobmsg_close_table(&b, c);
-	}
-	blobmsg_close_array(&b, list);
-	ubus_send_reply(ctx, req, b.head);
-
-	return 0;
-}
-
-static int
-hostapd_bss_get_features(struct ubus_context *ctx, struct ubus_object *obj,
-			struct ubus_request_data *req, const char *method,
-			struct blob_attr *msg)
-{
-	struct hostapd_data *hapd = container_of(obj, struct hostapd_data, ubus.obj);
-
-	blob_buf_init(&b, 0);
-	blobmsg_add_u8(&b, "ht_supported", ht_supported(hapd->iface->hw_features));
-	blobmsg_add_u8(&b, "vht_supported", vht_supported(hapd->iface->hw_features));
-	ubus_send_reply(ctx, req, b.head);
-
-	return 0;
-}
-
-static int
-hostapd_bss_get_status(struct ubus_context *ctx, struct ubus_object *obj,
-		       struct ubus_request_data *req, const char *method,
-		       struct blob_attr *msg)
-{
-	struct hostapd_data *hapd = container_of(obj, struct hostapd_data, ubus.obj);
-	void *airtime_table, *dfs_table;
-	struct os_reltime now;
-	char phy_name[17];
-	char mac_buf[20];
-
-	blob_buf_init(&b, 0);
-	blobmsg_add_string(&b, "status", hostapd_state_text(hapd->iface->state));
-	blobmsg_add_u32(&b, "freq", hapd->iface->freq);
-
-	snprintf(phy_name, 17, "%s", hapd->iface->phy);
-	blobmsg_add_string(&b, "phy", phy_name);
-
-	/* Airtime */
-	airtime_table = blobmsg_open_table(&b, "airtime");
-	blobmsg_add_u64(&b, "time", hapd->iface->last_channel_time);
-	blobmsg_add_u64(&b, "time_busy", hapd->iface->last_channel_time_busy);
-	blobmsg_add_u16(&b, "utilization", hapd->iface->channel_utilization);
-	blobmsg_close_table(&b, airtime_table);
-
-	/* DFS */
-	dfs_table = blobmsg_open_table(&b, "dfs");
-	blobmsg_add_u32(&b, "cac_seconds", hapd->iface->dfs_cac_ms / 1000);
-	blobmsg_add_u8(&b, "cac_active", !!(hapd->iface->cac_started));
-	os_reltime_age(&hapd->iface->dfs_cac_start, &now);
-	blobmsg_add_u32(&b, "cac_seconds_left",
-			hapd->iface->cac_started ? hapd->iface->dfs_cac_ms / 1000 - now.sec : 0);
-	blobmsg_close_table(&b, dfs_table);
-
-	ubus_send_reply(ctx, req, b.head);
-
-	return 0;
-}
-
-enum {
-	NOTIFY_RESPONSE,
-	__NOTIFY_MAX
-};
-
-static const struct blobmsg_policy notify_policy[__NOTIFY_MAX] = {
-	[NOTIFY_RESPONSE] = { "notify_response", BLOBMSG_TYPE_INT32 },
-};
-
-static int
-hostapd_notify_response(struct ubus_context *ctx, struct ubus_object *obj,
-			struct ubus_request_data *req, const char *method,
-			struct blob_attr *msg)
-{
-	struct blob_attr *tb[__NOTIFY_MAX];
-	struct hostapd_data *hapd = get_hapd_from_object(obj);
-	struct wpabuf *elems;
-	const char *pos;
-	size_t len;
-
-	blobmsg_parse(notify_policy, __NOTIFY_MAX, tb,
-		      blob_data(msg), blob_len(msg));
-
-	if (!tb[NOTIFY_RESPONSE])
-		return UBUS_STATUS_INVALID_ARGUMENT;
-
-	hapd->ubus.notify_response = blobmsg_get_u32(tb[NOTIFY_RESPONSE]);
-
-	return UBUS_STATUS_OK;
-}
-
-enum {
-	DEL_CLIENT_ADDR,
-	DEL_CLIENT_REASON,
-	DEL_CLIENT_DEAUTH,
-	DEL_CLIENT_BAN_TIME,
-	__DEL_CLIENT_MAX
-};
-
-static const struct blobmsg_policy del_policy[__DEL_CLIENT_MAX] = {
-	[DEL_CLIENT_ADDR] = { "addr", BLOBMSG_TYPE_STRING },
-	[DEL_CLIENT_REASON] = { "reason", BLOBMSG_TYPE_INT32 },
-	[DEL_CLIENT_DEAUTH] = { "deauth", BLOBMSG_TYPE_INT8 },
-	[DEL_CLIENT_BAN_TIME] = { "ban_time", BLOBMSG_TYPE_INT32 },
-};
-
-static int
-hostapd_bss_del_client(struct ubus_context *ctx, struct ubus_object *obj,
-			struct ubus_request_data *req, const char *method,
-			struct blob_attr *msg)
-{
-	struct blob_attr *tb[__DEL_CLIENT_MAX];
-	struct hostapd_data *hapd = container_of(obj, struct hostapd_data, ubus.obj);
-	struct sta_info *sta;
-	bool deauth = false;
-	int reason;
-	u8 addr[ETH_ALEN];
-
-	blobmsg_parse(del_policy, __DEL_CLIENT_MAX, tb, blob_data(msg), blob_len(msg));
-
-	if (!tb[DEL_CLIENT_ADDR])
-		return UBUS_STATUS_INVALID_ARGUMENT;
-
-	if (hwaddr_aton(blobmsg_data(tb[DEL_CLIENT_ADDR]), addr))
-		return UBUS_STATUS_INVALID_ARGUMENT;
-
-	if (tb[DEL_CLIENT_REASON])
-		reason = blobmsg_get_u32(tb[DEL_CLIENT_REASON]);
-
-	if (tb[DEL_CLIENT_DEAUTH])
-		deauth = blobmsg_get_bool(tb[DEL_CLIENT_DEAUTH]);
-
-	sta = ap_get_sta(hapd, addr);
-	if (sta) {
-		if (deauth) {
-			hostapd_drv_sta_deauth(hapd, addr, reason);
-			ap_sta_deauthenticate(hapd, sta, reason);
-		} else {
-			hostapd_drv_sta_disassoc(hapd, addr, reason);
-			ap_sta_disassociate(hapd, sta, reason);
-		}
-	}
-
-	if (tb[DEL_CLIENT_BAN_TIME])
-		hostapd_bss_ban_client(hapd, addr, blobmsg_get_u32(tb[DEL_CLIENT_BAN_TIME]));
-
-	return 0;
-}
-
-static void
-blobmsg_add_macaddr(struct blob_buf *buf, const char *name, const u8 *addr)
-{
-	char *s;
-
-	s = blobmsg_alloc_string_buffer(buf, name, 20);
-	sprintf(s, MACSTR, MAC2STR(addr));
-	blobmsg_add_string_buffer(buf);
-}
-
-static int
-hostapd_bss_list_bans(struct ubus_context *ctx, struct ubus_object *obj,
-		      struct ubus_request_data *req, const char *method,
-		      struct blob_attr *msg)
-{
-	struct hostapd_data *hapd = container_of(obj, struct hostapd_data, ubus.obj);
-	struct ubus_banned_client *ban;
-	void *c;
-
-	blob_buf_init(&b, 0);
-	c = blobmsg_open_array(&b, "clients");
-	avl_for_each_element(&hapd->ubus.banned, ban, avl)
-		blobmsg_add_macaddr(&b, NULL, ban->addr);
-	blobmsg_close_array(&b, c);
-	ubus_send_reply(ctx, req, b.head);
-
-	return 0;
-}
-
-#ifdef CONFIG_WPS
-static int
-hostapd_bss_wps_start(struct ubus_context *ctx, struct ubus_object *obj,
-			struct ubus_request_data *req, const char *method,
-			struct blob_attr *msg)
-{
-	int rc;
-	struct hostapd_data *hapd = container_of(obj, struct hostapd_data, ubus.obj);
-
-	rc = hostapd_wps_button_pushed(hapd, NULL);
-
-	if (rc != 0)
-		return UBUS_STATUS_NOT_SUPPORTED;
-
-	return 0;
-}
-
-
-static const char * pbc_status_enum_str(enum pbc_status status)
-{
-	switch (status) {
-	case WPS_PBC_STATUS_DISABLE:
-		return "Disabled";
-	case WPS_PBC_STATUS_ACTIVE:
-		return "Active";
-	case WPS_PBC_STATUS_TIMEOUT:
-		return "Timed-out";
-	case WPS_PBC_STATUS_OVERLAP:
-		return "Overlap";
-	default:
-		return "Unknown";
-	}
-}
-
-static int
-hostapd_bss_wps_status(struct ubus_context *ctx, struct ubus_object *obj,
-			struct ubus_request_data *req, const char *method,
-			struct blob_attr *msg)
-{
-	int rc;
-	struct hostapd_data *hapd = container_of(obj, struct hostapd_data, ubus.obj);
-
-	blob_buf_init(&b, 0);
-
-	blobmsg_add_string(&b, "pbc_status", pbc_status_enum_str(hapd->wps_stats.pbc_status));
-	blobmsg_add_string(&b, "last_wps_result",
-			   (hapd->wps_stats.status == WPS_STATUS_SUCCESS ?
-			    "Success":
-			    (hapd->wps_stats.status == WPS_STATUS_FAILURE ?
-			     "Failed" : "None")));
-
-	/* If status == Failure - Add possible Reasons */
-	if(hapd->wps_stats.status == WPS_STATUS_FAILURE &&
-	   hapd->wps_stats.failure_reason > 0)
-		blobmsg_add_string(&b, "reason", wps_ei_str(hapd->wps_stats.failure_reason));
-
-	if (hapd->wps_stats.status)
-		blobmsg_printf(&b, "peer_address", MACSTR, MAC2STR(hapd->wps_stats.peer_addr));
-
-	ubus_send_reply(ctx, req, b.head);
-
-	return 0;
-}
-
-static int
-hostapd_bss_wps_cancel(struct ubus_context *ctx, struct ubus_object *obj,
-			struct ubus_request_data *req, const char *method,
-			struct blob_attr *msg)
-{
-	int rc;
-	struct hostapd_data *hapd = container_of(obj, struct hostapd_data, ubus.obj);
-
-	rc = hostapd_wps_cancel(hapd);
-
-	if (rc != 0)
-		return UBUS_STATUS_NOT_SUPPORTED;
-
-	return 0;
-}
-#endif /* CONFIG_WPS */
-
-static int
-hostapd_bss_update_beacon(struct ubus_context *ctx, struct ubus_object *obj,
-			struct ubus_request_data *req, const char *method,
-			struct blob_attr *msg)
-{
-	int rc;
-	struct hostapd_data *hapd = container_of(obj, struct hostapd_data, ubus.obj);
-
-	rc = ieee802_11_set_beacon(hapd);
-
-	if (rc != 0)
-		return UBUS_STATUS_NOT_SUPPORTED;
-
-	return 0;
-}
-
-enum {
-	CONFIG_IFACE,
-	CONFIG_FILE,
-	__CONFIG_MAX
-};
-
-static const struct blobmsg_policy config_add_policy[__CONFIG_MAX] = {
-	[CONFIG_IFACE] = { "iface", BLOBMSG_TYPE_STRING },
-	[CONFIG_FILE] = { "config", BLOBMSG_TYPE_STRING },
-};
-
-static int
-hostapd_config_add(struct ubus_context *ctx, struct ubus_object *obj,
-		   struct ubus_request_data *req, const char *method,
-		   struct blob_attr *msg)
-{
-	struct blob_attr *tb[__CONFIG_MAX];
-	struct hapd_interfaces *interfaces = get_hapd_interfaces_from_object(obj);
-	char buf[128];
-
-	blobmsg_parse(config_add_policy, __CONFIG_MAX, tb, blob_data(msg), blob_len(msg));
-
-	if (!tb[CONFIG_FILE] || !tb[CONFIG_IFACE])
-		return UBUS_STATUS_INVALID_ARGUMENT;
-
-	snprintf(buf, sizeof(buf), "bss_config=%s:%s",
-		blobmsg_get_string(tb[CONFIG_IFACE]),
-		blobmsg_get_string(tb[CONFIG_FILE]));
-
-	if (hostapd_add_iface(interfaces, buf))
-		return UBUS_STATUS_INVALID_ARGUMENT;
-
-	blob_buf_init(&b, 0);
-	blobmsg_add_u32(&b, "pid", getpid());
-	ubus_send_reply(ctx, req, b.head);
-
-	return UBUS_STATUS_OK;
-}
-
-enum {
-	CONFIG_REM_IFACE,
-	__CONFIG_REM_MAX
-};
-
-static const struct blobmsg_policy config_remove_policy[__CONFIG_REM_MAX] = {
-	[CONFIG_REM_IFACE] = { "iface", BLOBMSG_TYPE_STRING },
-};
-
-static int
-hostapd_config_remove(struct ubus_context *ctx, struct ubus_object *obj,
-		      struct ubus_request_data *req, const char *method,
-		      struct blob_attr *msg)
-{
-	struct blob_attr *tb[__CONFIG_REM_MAX];
-	struct hapd_interfaces *interfaces = get_hapd_interfaces_from_object(obj);
-	char buf[128];
-
-	blobmsg_parse(config_remove_policy, __CONFIG_REM_MAX, tb, blob_data(msg), blob_len(msg));
-
-	if (!tb[CONFIG_REM_IFACE])
-		return UBUS_STATUS_INVALID_ARGUMENT;
-
-	if (hostapd_remove_iface(interfaces, blobmsg_get_string(tb[CONFIG_REM_IFACE])))
-		return UBUS_STATUS_INVALID_ARGUMENT;
-
-	return UBUS_STATUS_OK;
-}
-
-enum {
-	CSA_FREQ,
-	CSA_BCN_COUNT,
-	CSA_CENTER_FREQ1,
-	CSA_CENTER_FREQ2,
-	CSA_BANDWIDTH,
-	CSA_SEC_CHANNEL_OFFSET,
-	CSA_HT,
-	CSA_VHT,
-	CSA_BLOCK_TX,
-	__CSA_MAX
-};
-
-static const struct blobmsg_policy csa_policy[__CSA_MAX] = {
-	[CSA_FREQ] = { "freq", BLOBMSG_TYPE_INT32 },
-	[CSA_BCN_COUNT] = { "bcn_count", BLOBMSG_TYPE_INT32 },
-	[CSA_CENTER_FREQ1] = { "center_freq1", BLOBMSG_TYPE_INT32 },
-	[CSA_CENTER_FREQ2] = { "center_freq2", BLOBMSG_TYPE_INT32 },
-	[CSA_BANDWIDTH] = { "bandwidth", BLOBMSG_TYPE_INT32 },
-	[CSA_SEC_CHANNEL_OFFSET] = { "sec_channel_offset", BLOBMSG_TYPE_INT32 },
-	[CSA_HT] = { "ht", BLOBMSG_TYPE_BOOL },
-	[CSA_VHT] = { "vht", BLOBMSG_TYPE_BOOL },
-	[CSA_BLOCK_TX] = { "block_tx", BLOBMSG_TYPE_BOOL },
-};
-
-#ifdef NEED_AP_MLME
-static int
-hostapd_switch_chan(struct ubus_context *ctx, struct ubus_object *obj,
-		    struct ubus_request_data *req, const char *method,
-		    struct blob_attr *msg)
-{
-	struct blob_attr *tb[__CSA_MAX];
-	struct hostapd_data *hapd = get_hapd_from_object(obj);
-	struct csa_settings css;
-
-	blobmsg_parse(csa_policy, __CSA_MAX, tb, blob_data(msg), blob_len(msg));
-
-	if (!tb[CSA_FREQ])
-		return UBUS_STATUS_INVALID_ARGUMENT;
-
-	memset(&css, 0, sizeof(css));
-	css.freq_params.freq = blobmsg_get_u32(tb[CSA_FREQ]);
-
-#define SET_CSA_SETTING(name, field, type) \
-	do { \
-		if (tb[name]) \
-			css.field = blobmsg_get_ ## type(tb[name]); \
-	} while(0)
-
-	SET_CSA_SETTING(CSA_BCN_COUNT, cs_count, u32);
-	SET_CSA_SETTING(CSA_CENTER_FREQ1, freq_params.center_freq1, u32);
-	SET_CSA_SETTING(CSA_CENTER_FREQ2, freq_params.center_freq2, u32);
-	SET_CSA_SETTING(CSA_BANDWIDTH, freq_params.bandwidth, u32);
-	SET_CSA_SETTING(CSA_SEC_CHANNEL_OFFSET, freq_params.sec_channel_offset, u32);
-	SET_CSA_SETTING(CSA_HT, freq_params.ht_enabled, bool);
-	SET_CSA_SETTING(CSA_VHT, freq_params.vht_enabled, bool);
-	SET_CSA_SETTING(CSA_BLOCK_TX, block_tx, bool);
-
-
-	if (hostapd_switch_channel(hapd, &css) != 0)
-		return UBUS_STATUS_NOT_SUPPORTED;
-	return UBUS_STATUS_OK;
-#undef SET_CSA_SETTING
-}
-#endif
-
-enum {
-	VENDOR_ELEMENTS,
-	__VENDOR_ELEMENTS_MAX
-};
-
-static const struct blobmsg_policy ve_policy[__VENDOR_ELEMENTS_MAX] = {
-	/* vendor elements are provided as hex-string */
-	[VENDOR_ELEMENTS] = { "vendor_elements", BLOBMSG_TYPE_STRING },
-};
-
-static int
-hostapd_vendor_elements(struct ubus_context *ctx, struct ubus_object *obj,
-			struct ubus_request_data *req, const char *method,
-			struct blob_attr *msg)
-{
-	struct blob_attr *tb[__VENDOR_ELEMENTS_MAX];
-	struct hostapd_data *hapd = get_hapd_from_object(obj);
-	struct hostapd_bss_config *bss = hapd->conf;
-	struct wpabuf *elems;
-	const char *pos;
-	size_t len;
-
-	blobmsg_parse(ve_policy, __VENDOR_ELEMENTS_MAX, tb,
-		      blob_data(msg), blob_len(msg));
-
-	if (!tb[VENDOR_ELEMENTS])
-		return UBUS_STATUS_INVALID_ARGUMENT;
-
-	pos = blobmsg_data(tb[VENDOR_ELEMENTS]);
-	len = os_strlen(pos);
-	if (len & 0x01)
-			return UBUS_STATUS_INVALID_ARGUMENT;
-
-	len /= 2;
-	if (len == 0) {
-		wpabuf_free(bss->vendor_elements);
-		bss->vendor_elements = NULL;
-		return 0;
-	}
-
-	elems = wpabuf_alloc(len);
-	if (elems == NULL)
-		return 1;
-
-	if (hexstr2bin(pos, wpabuf_put(elems, len), len)) {
-		wpabuf_free(elems);
-		return UBUS_STATUS_INVALID_ARGUMENT;
-	}
-
-	wpabuf_free(bss->vendor_elements);
-	bss->vendor_elements = elems;
-
-	/* update beacons if vendor elements were set successfully */
-	if (ieee802_11_update_beacons(hapd->iface) != 0)
-		return UBUS_STATUS_NOT_SUPPORTED;
-	return UBUS_STATUS_OK;
-}
-
-static void
-hostapd_rrm_print_nr(struct hostapd_neighbor_entry *nr)
-{
-	const u8 *data;
-	char *str;
-	int len;
-
-	blobmsg_printf(&b, "", MACSTR, MAC2STR(nr->bssid));
-
-	str = blobmsg_alloc_string_buffer(&b, "", nr->ssid.ssid_len + 1);
-	memcpy(str, nr->ssid.ssid, nr->ssid.ssid_len);
-	str[nr->ssid.ssid_len] = 0;
-	blobmsg_add_string_buffer(&b);
-
-	len = wpabuf_len(nr->nr);
-	str = blobmsg_alloc_string_buffer(&b, "", 2 * len + 1);
-	wpa_snprintf_hex(str, 2 * len + 1, wpabuf_head_u8(nr->nr), len);
-	blobmsg_add_string_buffer(&b);
-}
-
-enum {
-	BSS_MGMT_EN_NEIGHBOR,
-	BSS_MGMT_EN_BEACON,
-#ifdef CONFIG_WNM_AP
-	BSS_MGMT_EN_BSS_TRANSITION,
-#endif
-	__BSS_MGMT_EN_MAX
-};
-
-static bool
-__hostapd_bss_mgmt_enable_f(struct hostapd_data *hapd, int flag)
-{
-	struct hostapd_bss_config *bss = hapd->conf;
-	uint32_t flags;
-
-	switch (flag) {
-	case BSS_MGMT_EN_NEIGHBOR:
-		if (bss->radio_measurements[0] &
-		    WLAN_RRM_CAPS_NEIGHBOR_REPORT)
-			return false;
-
-		bss->radio_measurements[0] |=
-			WLAN_RRM_CAPS_NEIGHBOR_REPORT;
-		hostapd_neighbor_set_own_report(hapd);
-		return true;
-	case BSS_MGMT_EN_BEACON:
-		flags = WLAN_RRM_CAPS_BEACON_REPORT_PASSIVE |
-			WLAN_RRM_CAPS_BEACON_REPORT_ACTIVE |
-			WLAN_RRM_CAPS_BEACON_REPORT_TABLE;
-
-		if (bss->radio_measurements[0] & flags == flags)
-			return false;
-
-		bss->radio_measurements[0] |= (u8) flags;
-		return true;
-#ifdef CONFIG_WNM_AP
-	case BSS_MGMT_EN_BSS_TRANSITION:
-		if (bss->bss_transition)
-			return false;
-
-		bss->bss_transition = 1;
-		return true;
-#endif
-	}
-}
-
-static void
-__hostapd_bss_mgmt_enable(struct hostapd_data *hapd, uint32_t flags)
-{
-	bool update = false;
-	int i;
-
-	for (i = 0; i < __BSS_MGMT_EN_MAX; i++) {
-		if (!(flags & (1 << i)))
-			continue;
-
-		update |= __hostapd_bss_mgmt_enable_f(hapd, i);
-	}
-
-	if (update)
-		ieee802_11_update_beacons(hapd->iface);
-}
-
-
-static const struct blobmsg_policy bss_mgmt_enable_policy[__BSS_MGMT_EN_MAX] = {
-	[BSS_MGMT_EN_NEIGHBOR] = { "neighbor_report", BLOBMSG_TYPE_BOOL },
-	[BSS_MGMT_EN_BEACON] = { "beacon_report", BLOBMSG_TYPE_BOOL },
-#ifdef CONFIG_WNM_AP
-	[BSS_MGMT_EN_BSS_TRANSITION] = { "bss_transition", BLOBMSG_TYPE_BOOL },
-#endif
-};
-
-static int
-hostapd_bss_mgmt_enable(struct ubus_context *ctx, struct ubus_object *obj,
-		   struct ubus_request_data *req, const char *method,
-		   struct blob_attr *msg)
-
-{
-	struct hostapd_data *hapd = get_hapd_from_object(obj);
-	struct blob_attr *tb[__BSS_MGMT_EN_MAX];
-	struct blob_attr *cur;
-	uint32_t flags = 0;
-	int i;
-	bool neigh = false, beacon = false;
-
-	blobmsg_parse(bss_mgmt_enable_policy, __BSS_MGMT_EN_MAX, tb, blob_data(msg), blob_len(msg));
-
-	for (i = 0; i < ARRAY_SIZE(tb); i++) {
-		if (!tb[i] || !blobmsg_get_bool(tb[i]))
-			continue;
-
-		flags |= (1 << i);
-	}
-
-	__hostapd_bss_mgmt_enable(hapd, flags);
-}
-
-
-static void
-hostapd_rrm_nr_enable(struct hostapd_data *hapd)
-{
-	__hostapd_bss_mgmt_enable(hapd, 1 << BSS_MGMT_EN_NEIGHBOR);
-}
-
-static int
-hostapd_rrm_nr_get_own(struct ubus_context *ctx, struct ubus_object *obj,
-		       struct ubus_request_data *req, const char *method,
-		       struct blob_attr *msg)
-{
-	struct hostapd_data *hapd = get_hapd_from_object(obj);
-	struct hostapd_neighbor_entry *nr;
-	void *c;
-
-	hostapd_rrm_nr_enable(hapd);
-
-	nr = hostapd_neighbor_get(hapd, hapd->own_addr, NULL);
-	if (!nr)
-		return UBUS_STATUS_NOT_FOUND;
-
-	blob_buf_init(&b, 0);
-
-	c = blobmsg_open_array(&b, "value");
-	hostapd_rrm_print_nr(nr);
-	blobmsg_close_array(&b, c);
-
-	ubus_send_reply(ctx, req, b.head);
-
-	return 0;
-}
-
-static int
-hostapd_rrm_nr_list(struct ubus_context *ctx, struct ubus_object *obj,
-		    struct ubus_request_data *req, const char *method,
-		    struct blob_attr *msg)
-{
-	struct hostapd_data *hapd = get_hapd_from_object(obj);
-	struct hostapd_neighbor_entry *nr;
-	void *c;
-
-	hostapd_rrm_nr_enable(hapd);
-	blob_buf_init(&b, 0);
-
-	c = blobmsg_open_array(&b, "list");
-	dl_list_for_each(nr, &hapd->nr_db, struct hostapd_neighbor_entry, list) {
-		void *cur;
-
-		if (!memcmp(nr->bssid, hapd->own_addr, ETH_ALEN))
-			continue;
-
-		cur = blobmsg_open_array(&b, NULL);
-		hostapd_rrm_print_nr(nr);
-		blobmsg_close_array(&b, cur);
-	}
-	blobmsg_close_array(&b, c);
-
-	ubus_send_reply(ctx, req, b.head);
-
-	return 0;
-}
-
-enum {
-	NR_SET_LIST,
-	__NR_SET_LIST_MAX
-};
-
-static const struct blobmsg_policy nr_set_policy[__NR_SET_LIST_MAX] = {
-	[NR_SET_LIST] = { "list", BLOBMSG_TYPE_ARRAY },
-};
-
-
-static void
-hostapd_rrm_nr_clear(struct hostapd_data *hapd)
-{
-	struct hostapd_neighbor_entry *nr;
-
-restart:
-	dl_list_for_each(nr, &hapd->nr_db, struct hostapd_neighbor_entry, list) {
-		if (!memcmp(nr->bssid, hapd->own_addr, ETH_ALEN))
-			continue;
-
-		hostapd_neighbor_remove(hapd, nr->bssid, &nr->ssid);
-		goto restart;
-	}
-}
-
-static int
-hostapd_rrm_nr_set(struct ubus_context *ctx, struct ubus_object *obj,
-		   struct ubus_request_data *req, const char *method,
-		   struct blob_attr *msg)
-{
-	static const struct blobmsg_policy nr_e_policy[] = {
-		{ .type = BLOBMSG_TYPE_STRING },
-		{ .type = BLOBMSG_TYPE_STRING },
-		{ .type = BLOBMSG_TYPE_STRING },
-	};
-	struct hostapd_data *hapd = get_hapd_from_object(obj);
-	struct blob_attr *tb_l[__NR_SET_LIST_MAX];
-	struct blob_attr *tb[ARRAY_SIZE(nr_e_policy)];
-	struct blob_attr *cur;
-	int rem;
-
-	hostapd_rrm_nr_enable(hapd);
-
-	blobmsg_parse(nr_set_policy, __NR_SET_LIST_MAX, tb_l, blob_data(msg), blob_len(msg));
-	if (!tb_l[NR_SET_LIST])
-		return UBUS_STATUS_INVALID_ARGUMENT;
-
-	hostapd_rrm_nr_clear(hapd);
-	blobmsg_for_each_attr(cur, tb_l[NR_SET_LIST], rem) {
-		struct wpa_ssid_value ssid;
-		struct wpabuf *data;
-		u8 bssid[ETH_ALEN];
-		char *s, *nr_s;
-
-		blobmsg_parse_array(nr_e_policy, ARRAY_SIZE(nr_e_policy), tb, blobmsg_data(cur), blobmsg_data_len(cur));
-		if (!tb[0] || !tb[1] || !tb[2])
-			goto invalid;
-
-		/* Neighbor Report binary */
-		nr_s = blobmsg_get_string(tb[2]);
-		data = wpabuf_parse_bin(nr_s);
-		if (!data)
-			goto invalid;
-
-		/* BSSID */
-		s = blobmsg_get_string(tb[0]);
-		if (strlen(s) == 0) {
-			/* Copy BSSID from neighbor report */
-			if (hwaddr_compact_aton(nr_s, bssid))
-				goto invalid;
-		} else if (hwaddr_aton(s, bssid)) {
-			goto invalid;
-		}
-
-		/* SSID */
-		s = blobmsg_get_string(tb[1]);
-		if (strlen(s) == 0) {
-			/* Copy SSID from hostapd BSS conf */
-			memcpy(&ssid, &hapd->conf->ssid, sizeof(ssid));
-		} else {
-			ssid.ssid_len = strlen(s);
-			if (ssid.ssid_len > sizeof(ssid.ssid))
-				goto invalid;
-
-			memcpy(&ssid, s, ssid.ssid_len);
-		}
-
-		hostapd_neighbor_set(hapd, bssid, &ssid, data, NULL, NULL, 0);
-		wpabuf_free(data);
-		continue;
-
-invalid:
-		return UBUS_STATUS_INVALID_ARGUMENT;
-	}
-
-	return 0;
-}
-
-enum {
-	BEACON_REQ_ADDR,
-	BEACON_REQ_MODE,
-	BEACON_REQ_OP_CLASS,
-	BEACON_REQ_CHANNEL,
-	BEACON_REQ_DURATION,
-	BEACON_REQ_BSSID,
-	BEACON_REQ_SSID,
-	__BEACON_REQ_MAX,
-};
-
-static const struct blobmsg_policy beacon_req_policy[__BEACON_REQ_MAX] = {
-	[BEACON_REQ_ADDR] = { "addr", BLOBMSG_TYPE_STRING },
-	[BEACON_REQ_OP_CLASS] { "op_class", BLOBMSG_TYPE_INT32 },
-	[BEACON_REQ_CHANNEL] { "channel", BLOBMSG_TYPE_INT32 },
-	[BEACON_REQ_DURATION] { "duration", BLOBMSG_TYPE_INT32 },
-	[BEACON_REQ_MODE] { "mode", BLOBMSG_TYPE_INT32 },
-	[BEACON_REQ_BSSID] { "bssid", BLOBMSG_TYPE_STRING },
-	[BEACON_REQ_SSID] { "ssid", BLOBMSG_TYPE_STRING },
-};
-
-static int
-hostapd_rrm_beacon_req(struct ubus_context *ctx, struct ubus_object *obj,
-		       struct ubus_request_data *ureq, const char *method,
-		       struct blob_attr *msg)
-{
-	struct hostapd_data *hapd = container_of(obj, struct hostapd_data, ubus.obj);
-	struct blob_attr *tb[__BEACON_REQ_MAX];
-	struct blob_attr *cur;
-	struct wpabuf *req;
-	u8 bssid[ETH_ALEN] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
-	u8 addr[ETH_ALEN];
-	int mode, rem, ret;
-	int buf_len = 13;
-
-	blobmsg_parse(beacon_req_policy, __BEACON_REQ_MAX, tb, blob_data(msg), blob_len(msg));
-
-	if (!tb[BEACON_REQ_ADDR] || !tb[BEACON_REQ_MODE] || !tb[BEACON_REQ_DURATION] ||
-	    !tb[BEACON_REQ_OP_CLASS] || !tb[BEACON_REQ_CHANNEL])
-		return UBUS_STATUS_INVALID_ARGUMENT;
-
-	if (tb[BEACON_REQ_SSID])
-		buf_len += blobmsg_data_len(tb[BEACON_REQ_SSID]) + 2 - 1;
-
-	mode = blobmsg_get_u32(tb[BEACON_REQ_MODE]);
-	if (hwaddr_aton(blobmsg_data(tb[BEACON_REQ_ADDR]), addr))
-		return UBUS_STATUS_INVALID_ARGUMENT;
-
-	if (tb[BEACON_REQ_BSSID] &&
-	    hwaddr_aton(blobmsg_data(tb[BEACON_REQ_BSSID]), bssid))
-		return UBUS_STATUS_INVALID_ARGUMENT;
-
-	req = wpabuf_alloc(buf_len);
-	if (!req)
-		return UBUS_STATUS_UNKNOWN_ERROR;
-
-	/* 1: regulatory class */
-	wpabuf_put_u8(req, blobmsg_get_u32(tb[BEACON_REQ_OP_CLASS]));
-
-	/* 2: channel number */
-	wpabuf_put_u8(req, blobmsg_get_u32(tb[BEACON_REQ_CHANNEL]));
-
-	/* 3-4: randomization interval */
-	wpabuf_put_le16(req, 0);
-
-	/* 5-6: duration */
-	wpabuf_put_le16(req, blobmsg_get_u32(tb[BEACON_REQ_DURATION]));
-
-	/* 7: mode */
-	wpabuf_put_u8(req, blobmsg_get_u32(tb[BEACON_REQ_MODE]));
-
-	/* 8-13: BSSID */
-	wpabuf_put_data(req, bssid, ETH_ALEN);
-
-	if ((cur = tb[BEACON_REQ_SSID]) != NULL) {
-		wpabuf_put_u8(req, WLAN_EID_SSID);
-		wpabuf_put_u8(req, blobmsg_data_len(cur) - 1);
-		wpabuf_put_data(req, blobmsg_data(cur), blobmsg_data_len(cur) - 1);
-	}
-
-	ret = hostapd_send_beacon_req(hapd, addr, 0, req);
-	if (ret < 0)
-		return -ret;
-
-	return 0;
-}
-
-
-#ifdef CONFIG_WNM_AP
-enum {
-	WNM_DISASSOC_ADDR,
-	WNM_DISASSOC_DURATION,
-	WNM_DISASSOC_NEIGHBORS,
-	WNM_DISASSOC_ABRIDGED,
-	__WNM_DISASSOC_MAX,
-};
-
-static const struct blobmsg_policy wnm_disassoc_policy[__WNM_DISASSOC_MAX] = {
-	[WNM_DISASSOC_ADDR] = { "addr", BLOBMSG_TYPE_STRING },
-	[WNM_DISASSOC_DURATION] { "duration", BLOBMSG_TYPE_INT32 },
-	[WNM_DISASSOC_NEIGHBORS] { "neighbors", BLOBMSG_TYPE_ARRAY },
-	[WNM_DISASSOC_ABRIDGED] { "abridged", BLOBMSG_TYPE_BOOL },
-};
-
-static int
-hostapd_wnm_disassoc_imminent(struct ubus_context *ctx, struct ubus_object *obj,
-			      struct ubus_request_data *ureq, const char *method,
-			      struct blob_attr *msg)
-{
-	struct hostapd_data *hapd = container_of(obj, struct hostapd_data, ubus.obj);
-	struct blob_attr *tb[__WNM_DISASSOC_MAX];
-	struct blob_attr *cur;
-	struct sta_info *sta;
-	int duration = 10;
-	int rem;
-	int nr_len = 0;
-	u8 *nr = NULL;
-	u8 req_mode = WNM_BSS_TM_REQ_DISASSOC_IMMINENT;
-	u8 addr[ETH_ALEN];
-
-	blobmsg_parse(wnm_disassoc_policy, __WNM_DISASSOC_MAX, tb, blob_data(msg), blob_len(msg));
-
-	if (!tb[WNM_DISASSOC_ADDR])
-		return UBUS_STATUS_INVALID_ARGUMENT;
-
-	if (hwaddr_aton(blobmsg_data(tb[WNM_DISASSOC_ADDR]), addr))
-		return UBUS_STATUS_INVALID_ARGUMENT;
-
-	if ((cur = tb[WNM_DISASSOC_DURATION]) != NULL)
-		duration = blobmsg_get_u32(cur);
-
-	sta = ap_get_sta(hapd, addr);
-	if (!sta)
-		return UBUS_STATUS_NOT_FOUND;
-
-	if (tb[WNM_DISASSOC_NEIGHBORS]) {
-		u8 *nr_cur;
-
-		if (blobmsg_check_array(tb[WNM_DISASSOC_NEIGHBORS],
-					BLOBMSG_TYPE_STRING) < 0)
-			return UBUS_STATUS_INVALID_ARGUMENT;
-
-		blobmsg_for_each_attr(cur, tb[WNM_DISASSOC_NEIGHBORS], rem) {
-			int len = strlen(blobmsg_get_string(cur));
-
-			if (len % 2)
-				return UBUS_STATUS_INVALID_ARGUMENT;
-
-			nr_len += (len / 2) + 2;
-		}
-
-		if (nr_len) {
-			nr = os_zalloc(nr_len);
-			if (!nr)
-				return UBUS_STATUS_UNKNOWN_ERROR;
-		}
-
-		nr_cur = nr;
-		blobmsg_for_each_attr(cur, tb[WNM_DISASSOC_NEIGHBORS], rem) {
-			int len = strlen(blobmsg_get_string(cur)) / 2;
-
-			*nr_cur++ = WLAN_EID_NEIGHBOR_REPORT;
-			*nr_cur++ = (u8) len;
-			if (hexstr2bin(blobmsg_data(cur), nr_cur, len)) {
-				free(nr);
-				return UBUS_STATUS_INVALID_ARGUMENT;
-			}
-
-			nr_cur += len;
-		}
-	}
-
-	if (nr)
-		req_mode |= WNM_BSS_TM_REQ_PREF_CAND_LIST_INCLUDED;
-
-	if (tb[WNM_DISASSOC_ABRIDGED] && blobmsg_get_bool(tb[WNM_DISASSOC_ABRIDGED]))
-		req_mode |= WNM_BSS_TM_REQ_ABRIDGED;
-
-	if (wnm_send_bss_tm_req(hapd, sta, req_mode, duration, duration, NULL,
-				NULL, nr, nr_len, NULL, 0))
-		return UBUS_STATUS_UNKNOWN_ERROR;
-
-	return 0;
-}
-#endif
-
-static const struct ubus_method bss_methods[] = {
-	UBUS_METHOD_NOARG("reload", hostapd_bss_reload),
-	UBUS_METHOD_NOARG("get_clients", hostapd_bss_get_clients),
-	UBUS_METHOD_NOARG("get_status", hostapd_bss_get_status),
-	UBUS_METHOD("del_client", hostapd_bss_del_client, del_policy),
-	UBUS_METHOD_NOARG("list_bans", hostapd_bss_list_bans),
-#ifdef CONFIG_WPS
-	UBUS_METHOD_NOARG("wps_start", hostapd_bss_wps_start),
-	UBUS_METHOD_NOARG("wps_status", hostapd_bss_wps_status),
-	UBUS_METHOD_NOARG("wps_cancel", hostapd_bss_wps_cancel),
-#endif
-	UBUS_METHOD_NOARG("update_beacon", hostapd_bss_update_beacon),
-	UBUS_METHOD_NOARG("get_features", hostapd_bss_get_features),
-#ifdef NEED_AP_MLME
-	UBUS_METHOD("switch_chan", hostapd_switch_chan, csa_policy),
-#endif
-	UBUS_METHOD("set_vendor_elements", hostapd_vendor_elements, ve_policy),
-	UBUS_METHOD("notify_response", hostapd_notify_response, notify_policy),
-	UBUS_METHOD("bss_mgmt_enable", hostapd_bss_mgmt_enable, bss_mgmt_enable_policy),
-	UBUS_METHOD_NOARG("rrm_nr_get_own", hostapd_rrm_nr_get_own),
-	UBUS_METHOD_NOARG("rrm_nr_list", hostapd_rrm_nr_list),
-	UBUS_METHOD("rrm_nr_set", hostapd_rrm_nr_set, nr_set_policy),
-	UBUS_METHOD("rrm_beacon_req", hostapd_rrm_beacon_req, beacon_req_policy),
-#ifdef CONFIG_WNM_AP
-	UBUS_METHOD("wnm_disassoc_imminent", hostapd_wnm_disassoc_imminent, wnm_disassoc_policy),
-#endif
-};
-
-static struct ubus_object_type bss_object_type =
-	UBUS_OBJECT_TYPE("hostapd_bss", bss_methods);
-
-static int avl_compare_macaddr(const void *k1, const void *k2, void *ptr)
-{
-	return memcmp(k1, k2, ETH_ALEN);
-}
-
-void hostapd_ubus_add_bss(struct hostapd_data *hapd)
-{
-	struct ubus_object *obj = &hapd->ubus.obj;
-	char *name;
-	int ret;
-
-#ifdef CONFIG_MESH
-	if (hapd->conf->mesh & MESH_ENABLED)
-		return;
-#endif
-
-	if (!hostapd_ubus_init())
-		return;
-
-	if (asprintf(&name, "hostapd.%s", hapd->conf->iface) < 0)
-		return;
-
-	avl_init(&hapd->ubus.banned, avl_compare_macaddr, false, NULL);
-	obj->name = name;
-	obj->type = &bss_object_type;
-	obj->methods = bss_object_type.methods;
-	obj->n_methods = bss_object_type.n_methods;
-	ret = ubus_add_object(ctx, obj);
-	hostapd_ubus_ref_inc();
-
-	hostapd_send_shared_event(&hapd->iface->interfaces->ubus, hapd->conf->iface, "add");
-}
-
-void hostapd_ubus_free_bss(struct hostapd_data *hapd)
-{
-	struct ubus_object *obj = &hapd->ubus.obj;
-	char *name = (char *) obj->name;
-
-#ifdef CONFIG_MESH
-	if (hapd->conf->mesh & MESH_ENABLED)
-		return;
-#endif
-
-	if (!ctx)
-		return;
-
-	hostapd_send_shared_event(&hapd->iface->interfaces->ubus, hapd->conf->iface, "remove");
-
-	if (obj->id) {
-		ubus_remove_object(ctx, obj);
-		hostapd_ubus_ref_dec();
-	}
-
-	free(name);
-}
-
-static const struct ubus_method daemon_methods[] = {
-	UBUS_METHOD("config_add", hostapd_config_add, config_add_policy),
-	UBUS_METHOD("config_remove", hostapd_config_remove, config_remove_policy),
-};
-
-static struct ubus_object_type daemon_object_type =
-	UBUS_OBJECT_TYPE("hostapd", daemon_methods);
-
-void hostapd_ubus_add(struct hapd_interfaces *interfaces)
-{
-	struct ubus_object *obj = &interfaces->ubus;
-	int ret;
-
-	if (!hostapd_ubus_init())
-		return;
-
-	obj->name = strdup("hostapd");
-
-	obj->type = &daemon_object_type;
-	obj->methods = daemon_object_type.methods;
-	obj->n_methods = daemon_object_type.n_methods;
-	ret = ubus_add_object(ctx, obj);
-	hostapd_ubus_ref_inc();
-}
-
-void hostapd_ubus_free(struct hapd_interfaces *interfaces)
-{
-	struct ubus_object *obj = &interfaces->ubus;
-	char *name = (char *) obj->name;
-
-	if (!ctx)
-		return;
-
-	if (obj->id) {
-		ubus_remove_object(ctx, obj);
-		hostapd_ubus_ref_dec();
-	}
-
-	free(name);
-}
-
-struct ubus_event_req {
-	struct ubus_notify_request nreq;
-	int resp;
-};
-
-static void
-ubus_event_cb(struct ubus_notify_request *req, int idx, int ret)
-{
-	struct ubus_event_req *ureq = container_of(req, struct ubus_event_req, nreq);
-
-	ureq->resp = ret;
-}
-
-int hostapd_ubus_handle_event(struct hostapd_data *hapd, struct hostapd_ubus_request *req)
-{
-	struct ubus_banned_client *ban;
-	const char *types[HOSTAPD_UBUS_TYPE_MAX] = {
-		[HOSTAPD_UBUS_PROBE_REQ] = "probe",
-		[HOSTAPD_UBUS_AUTH_REQ] = "auth",
-		[HOSTAPD_UBUS_ASSOC_REQ] = "assoc",
-	};
-	const char *type = "mgmt";
-	struct ubus_event_req ureq = {};
-	const u8 *addr;
-
-	if (req->mgmt_frame)
-		addr = req->mgmt_frame->sa;
-	else
-		addr = req->addr;
-
-	ban = avl_find_element(&hapd->ubus.banned, addr, ban, avl);
-	if (ban)
-		return WLAN_STATUS_AP_UNABLE_TO_HANDLE_NEW_STA;
-
-	if (!hapd->ubus.obj.has_subscribers)
-		return WLAN_STATUS_SUCCESS;
-
-	if (req->type < ARRAY_SIZE(types))
-		type = types[req->type];
-
-	blob_buf_init(&b, 0);
-	blobmsg_add_macaddr(&b, "address", addr);
-	if (req->mgmt_frame)
-		blobmsg_add_macaddr(&b, "target", req->mgmt_frame->da);
-	if (req->ssi_signal)
-		blobmsg_add_u32(&b, "signal", req->ssi_signal);
-	blobmsg_add_u32(&b, "freq", hapd->iface->freq);
-
-	if (req->elems) {
-		if(req->elems->ht_capabilities)
-		{
-			struct ieee80211_ht_capabilities *ht_capabilities;
-			void *ht_cap, *ht_cap_mcs_set, *mcs_set;
-
-
-			ht_capabilities = (struct ieee80211_ht_capabilities*) req->elems->ht_capabilities;
-			ht_cap = blobmsg_open_table(&b, "ht_capabilities");
-			blobmsg_add_u16(&b, "ht_capabilities_info", ht_capabilities->ht_capabilities_info);
-			ht_cap_mcs_set = blobmsg_open_table(&b, "supported_mcs_set");
-			blobmsg_add_u16(&b, "a_mpdu_params", ht_capabilities->a_mpdu_params);
-			blobmsg_add_u16(&b, "ht_extended_capabilities", ht_capabilities->ht_extended_capabilities);
-			blobmsg_add_u32(&b, "tx_bf_capability_info", ht_capabilities->tx_bf_capability_info);
-			blobmsg_add_u16(&b, "asel_capabilities", ht_capabilities->asel_capabilities);
-			mcs_set = blobmsg_open_array(&b, "supported_mcs_set");
-			for (int i = 0; i < 16; i++) {
-				blobmsg_add_u16(&b, NULL, (u16) ht_capabilities->supported_mcs_set[i]);
-			}
-			blobmsg_close_array(&b, mcs_set);
-			blobmsg_close_table(&b, ht_cap_mcs_set);
-			blobmsg_close_table(&b, ht_cap);
-		}
-		if(req->elems->vht_capabilities)
-		{
-			struct ieee80211_vht_capabilities *vht_capabilities;
-			void *vht_cap, *vht_cap_mcs_set;
-
-			vht_capabilities = (struct ieee80211_vht_capabilities*) req->elems->vht_capabilities;
-			vht_cap = blobmsg_open_table(&b, "vht_capabilities");
-			blobmsg_add_u32(&b, "vht_capabilities_info", vht_capabilities->vht_capabilities_info);
-			vht_cap_mcs_set = blobmsg_open_table(&b, "vht_supported_mcs_set");
-			blobmsg_add_u16(&b, "rx_map", vht_capabilities->vht_supported_mcs_set.rx_map);
-			blobmsg_add_u16(&b, "rx_highest", vht_capabilities->vht_supported_mcs_set.rx_highest);
-			blobmsg_add_u16(&b, "tx_map", vht_capabilities->vht_supported_mcs_set.tx_map);
-			blobmsg_add_u16(&b, "tx_highest", vht_capabilities->vht_supported_mcs_set.tx_highest);
-			blobmsg_close_table(&b, vht_cap_mcs_set);
-			blobmsg_close_table(&b, vht_cap);
-		}
-	}
-
-	if (!hapd->ubus.notify_response) {
-		ubus_notify(ctx, &hapd->ubus.obj, type, b.head, -1);
-		return WLAN_STATUS_SUCCESS;
-	}
-
-	if (ubus_notify_async(ctx, &hapd->ubus.obj, type, b.head, &ureq.nreq))
-		return WLAN_STATUS_SUCCESS;
-
-	ureq.nreq.status_cb = ubus_event_cb;
-	ubus_complete_request(ctx, &ureq.nreq.req, 100);
-
-	if (ureq.resp)
-		return ureq.resp;
-
-	return WLAN_STATUS_SUCCESS;
-}
-
-void hostapd_ubus_notify(struct hostapd_data *hapd, const char *type, const u8 *addr)
-{
-	if (!hapd->ubus.obj.has_subscribers)
-		return;
-
-	if (!addr)
-		return;
-
-	blob_buf_init(&b, 0);
-	blobmsg_add_macaddr(&b, "address", addr);
-
-	ubus_notify(ctx, &hapd->ubus.obj, type, b.head, -1);
-}
-
-void hostapd_ubus_notify_beacon_report(
-	struct hostapd_data *hapd, const u8 *addr, u8 token, u8 rep_mode,
-	struct rrm_measurement_beacon_report *rep, size_t len)
-{
-	if (!hapd->ubus.obj.has_subscribers)
-		return;
-
-	if (!addr || !rep)
-		return;
-
-	blob_buf_init(&b, 0);
-	blobmsg_add_macaddr(&b, "address", addr);
-	blobmsg_add_u16(&b, "op-class", rep->op_class);
-	blobmsg_add_u16(&b, "channel", rep->channel);
-	blobmsg_add_u64(&b, "start-time", rep->start_time);
-	blobmsg_add_u16(&b, "duration", rep->duration);
-	blobmsg_add_u16(&b, "report-info", rep->report_info);
-	blobmsg_add_u16(&b, "rcpi", rep->rcpi);
-	blobmsg_add_u16(&b, "rsni", rep->rsni);
-	blobmsg_add_macaddr(&b, "bssid", rep->bssid);
-	blobmsg_add_u16(&b, "antenna-id", rep->antenna_id);
-	blobmsg_add_u16(&b, "parent-tsf", rep->parent_tsf);
-
-	ubus_notify(ctx, &hapd->ubus.obj, "beacon-report", b.head, -1);
-}
diff --git a/package/network/services/hostapd/src/src/ap/ubus.h b/package/network/services/hostapd/src/src/ap/ubus.h
deleted file mode 100644
index e16017394f..0000000000
--- a/package/network/services/hostapd/src/src/ap/ubus.h
+++ /dev/null
@@ -1,103 +0,0 @@
-/*
- * hostapd / ubus support
- * Copyright (c) 2013, Felix Fietkau <nbd@nbd.name>
- *
- * This software may be distributed under the terms of the BSD license.
- * See README for more details.
- */
-#ifndef __HOSTAPD_UBUS_H
-#define __HOSTAPD_UBUS_H
-
-enum hostapd_ubus_event_type {
-	HOSTAPD_UBUS_PROBE_REQ,
-	HOSTAPD_UBUS_AUTH_REQ,
-	HOSTAPD_UBUS_ASSOC_REQ,
-	HOSTAPD_UBUS_TYPE_MAX
-};
-
-struct hostapd_ubus_request {
-	enum hostapd_ubus_event_type type;
-	const struct ieee80211_mgmt *mgmt_frame;
-	const struct ieee802_11_elems *elems;
-	int ssi_signal; /* dBm */
-	const u8 *addr;
-};
-
-struct hostapd_iface;
-struct hostapd_data;
-struct hapd_interfaces;
-struct rrm_measurement_beacon_report;
-
-#ifdef UBUS_SUPPORT
-
-#include <libubox/avl.h>
-#include <libubus.h>
-
-struct hostapd_ubus_bss {
-	struct ubus_object obj;
-	struct avl_tree banned;
-	int notify_response;
-};
-
-void hostapd_ubus_add_iface(struct hostapd_iface *iface);
-void hostapd_ubus_free_iface(struct hostapd_iface *iface);
-void hostapd_ubus_add_bss(struct hostapd_data *hapd);
-void hostapd_ubus_free_bss(struct hostapd_data *hapd);
-
-int hostapd_ubus_handle_event(struct hostapd_data *hapd, struct hostapd_ubus_request *req);
-void hostapd_ubus_notify(struct hostapd_data *hapd, const char *type, const u8 *mac);
-void hostapd_ubus_notify_beacon_report(struct hostapd_data *hapd,
-				       const u8 *addr, u8 token, u8 rep_mode,
-				       struct rrm_measurement_beacon_report *rep,
-				       size_t len);
-
-void hostapd_ubus_add(struct hapd_interfaces *interfaces);
-void hostapd_ubus_free(struct hapd_interfaces *interfaces);
-
-#else
-
-struct hostapd_ubus_bss {};
-
-static inline void hostapd_ubus_add_iface(struct hostapd_iface *iface)
-{
-}
-
-static inline void hostapd_ubus_free_iface(struct hostapd_iface *iface)
-{
-}
-
-static inline void hostapd_ubus_add_bss(struct hostapd_data *hapd)
-{
-}
-
-static inline void hostapd_ubus_free_bss(struct hostapd_data *hapd)
-{
-}
-
-static inline int hostapd_ubus_handle_event(struct hostapd_data *hapd, struct hostapd_ubus_request *req)
-{
-	return 0;
-}
-
-static inline void hostapd_ubus_notify(struct hostapd_data *hapd, const char *type, const u8 *mac)
-{
-}
-
-static inline void hostapd_ubus_notify_beacon_report(struct hostapd_data *hapd,
-						     const u8 *addr, u8 token,
-						     u8 rep_mode,
-						     struct rrm_measurement_beacon_report *rep,
-						     size_t len)
-{
-}
-
-static inline void hostapd_ubus_add(struct hapd_interfaces *interfaces)
-{
-}
-
-static inline void hostapd_ubus_free(struct hapd_interfaces *interfaces)
-{
-}
-#endif
-
-#endif
diff --git a/package/network/services/hostapd/src/src/utils/build_features.h b/package/network/services/hostapd/src/src/utils/build_features.h
deleted file mode 100644
index c7fccad413..0000000000
--- a/package/network/services/hostapd/src/src/utils/build_features.h
+++ /dev/null
@@ -1,59 +0,0 @@
-#ifndef BUILD_FEATURES_H
-#define BUILD_FEATURES_H
-
-static inline int has_feature(const char *feat)
-{
-#if defined(IEEE8021X_EAPOL) || (defined(HOSTAPD) && !defined(CONFIG_NO_RADIUS))
-	if (!strcmp(feat, "eap"))
-		return 1;
-#endif
-#ifdef CONFIG_IEEE80211N
-	if (!strcmp(feat, "11n"))
-		return 1;
-#endif
-#ifdef CONFIG_IEEE80211AC
-	if (!strcmp(feat, "11ac"))
-		return 1;
-#endif
-#ifdef CONFIG_IEEE80211AX
-	if (!strcmp(feat, "11ax"))
-		return 1;
-#endif
-#ifdef CONFIG_IEEE80211R
-	if (!strcmp(feat, "11r"))
-		return 1;
-#endif
-	if (!strcmp(feat, "11w"))
-		return 1;
-#ifdef CONFIG_ACS
-	if (!strcmp(feat, "acs"))
-		return 1;
-#endif
-#ifdef CONFIG_SAE
-	if (!strcmp(feat, "sae"))
-		return 1;
-#endif
-#ifdef CONFIG_OWE
-	if (!strcmp(feat, "owe"))
-		return 1;
-#endif
-#ifdef CONFIG_SUITEB192
-	if (!strcmp(feat, "suiteb192"))
-		return 1;
-#endif
-#ifdef CONFIG_WEP
-	if (!strcmp(feat, "wep"))
-		return 1;
-#endif
-#ifdef CONFIG_HS20
-	if (!strcmp(feat, "hs20"))
-		return 1;
-#endif
-#ifdef CONFIG_WPS
-	if (!strcmp(feat, "wps"))
-		return 1;
-#endif
-	return 0;
-}
-
-#endif /* BUILD_FEATURES_H */
diff --git a/package/network/services/hostapd/src/wpa_supplicant/ubus.c b/package/network/services/hostapd/src/wpa_supplicant/ubus.c
deleted file mode 100644
index 16a68c5073..0000000000
--- a/package/network/services/hostapd/src/wpa_supplicant/ubus.c
+++ /dev/null
@@ -1,430 +0,0 @@
-/*
- * wpa_supplicant / ubus support
- * Copyright (c) 2018, Daniel Golle <daniel@makrotopia.org>
- * Copyright (c) 2013, Felix Fietkau <nbd@nbd.name>
- *
- * This software may be distributed under the terms of the BSD license.
- * See README for more details.
- */
-
-#include "utils/includes.h"
-#include "utils/common.h"
-#include "utils/eloop.h"
-#include "utils/wpabuf.h"
-#include "common/ieee802_11_defs.h"
-#include "wpa_supplicant_i.h"
-#include "wps_supplicant.h"
-#include "ubus.h"
-
-static struct ubus_context *ctx;
-static struct blob_buf b;
-static int ctx_ref;
-
-static inline struct wpa_global *get_wpa_global_from_object(struct ubus_object *obj)
-{
-	return container_of(obj, struct wpa_global, ubus_global);
-}
-
-static inline struct wpa_supplicant *get_wpas_from_object(struct ubus_object *obj)
-{
-	return container_of(obj, struct wpa_supplicant, ubus.obj);
-}
-
-static void ubus_receive(int sock, void *eloop_ctx, void *sock_ctx)
-{
-	struct ubus_context *ctx = eloop_ctx;
-	ubus_handle_event(ctx);
-}
-
-static void ubus_reconnect_timeout(void *eloop_data, void *user_ctx)
-{
-	if (ubus_reconnect(ctx, NULL)) {
-		eloop_register_timeout(1, 0, ubus_reconnect_timeout, ctx, NULL);
-		return;
-	}
-
-	eloop_register_read_sock(ctx->sock.fd, ubus_receive, ctx, NULL);
-}
-
-static void wpas_ubus_connection_lost(struct ubus_context *ctx)
-{
-	eloop_unregister_read_sock(ctx->sock.fd);
-	eloop_register_timeout(1, 0, ubus_reconnect_timeout, ctx, NULL);
-}
-
-static bool wpas_ubus_init(void)
-{
-	if (ctx)
-		return true;
-
-	ctx = ubus_connect(NULL);
-	if (!ctx)
-		return false;
-
-	ctx->connection_lost = wpas_ubus_connection_lost;
-	eloop_register_read_sock(ctx->sock.fd, ubus_receive, ctx, NULL);
-	return true;
-}
-
-static void wpas_ubus_ref_inc(void)
-{
-	ctx_ref++;
-}
-
-static void wpas_ubus_ref_dec(void)
-{
-	ctx_ref--;
-	if (!ctx)
-		return;
-
-	if (ctx_ref)
-		return;
-
-	eloop_unregister_read_sock(ctx->sock.fd);
-	ubus_free(ctx);
-	ctx = NULL;
-}
-
-static int
-wpas_bss_get_features(struct ubus_context *ctx, struct ubus_object *obj,
-			struct ubus_request_data *req, const char *method,
-			struct blob_attr *msg)
-{
-	struct wpa_supplicant *wpa_s = get_wpas_from_object(obj);
-
-	blob_buf_init(&b, 0);
-	blobmsg_add_u8(&b, "ht_supported", ht_supported(wpa_s->hw.modes));
-	blobmsg_add_u8(&b, "vht_supported", vht_supported(wpa_s->hw.modes));
-	ubus_send_reply(ctx, req, b.head);
-
-	return 0;
-}
-
-static int
-wpas_bss_reload(struct ubus_context *ctx, struct ubus_object *obj,
-		struct ubus_request_data *req, const char *method,
-		struct blob_attr *msg)
-{
-	struct wpa_supplicant *wpa_s = get_wpas_from_object(obj);
-
-	if (wpa_supplicant_reload_configuration(wpa_s))
-		return UBUS_STATUS_UNKNOWN_ERROR;
-	else
-		return 0;
-}
-
-#ifdef CONFIG_WPS
-enum {
-	WPS_START_MULTI_AP,
-	__WPS_START_MAX
-};
-
-static const struct blobmsg_policy wps_start_policy[] = {
-	[WPS_START_MULTI_AP] = { "multi_ap", BLOBMSG_TYPE_BOOL },
-};
-
-static int
-wpas_bss_wps_start(struct ubus_context *ctx, struct ubus_object *obj,
-			struct ubus_request_data *req, const char *method,
-			struct blob_attr *msg)
-{
-	int rc;
-	struct wpa_supplicant *wpa_s = get_wpas_from_object(obj);
-	struct blob_attr *tb[__WPS_START_MAX], *cur;
-	int multi_ap = 0;
-
-	blobmsg_parse(wps_start_policy, __WPS_START_MAX, tb, blobmsg_data(msg), blobmsg_data_len(msg));
-
-	if (tb[WPS_START_MULTI_AP])
-		multi_ap = blobmsg_get_bool(tb[WPS_START_MULTI_AP]);
-
-	rc = wpas_wps_start_pbc(wpa_s, NULL, 0, multi_ap);
-
-	if (rc != 0)
-		return UBUS_STATUS_NOT_SUPPORTED;
-
-	return 0;
-}
-
-static int
-wpas_bss_wps_cancel(struct ubus_context *ctx, struct ubus_object *obj,
-			struct ubus_request_data *req, const char *method,
-			struct blob_attr *msg)
-{
-	int rc;
-	struct wpa_supplicant *wpa_s = get_wpas_from_object(obj);
-
-	rc = wpas_wps_cancel(wpa_s);
-
-	if (rc != 0)
-		return UBUS_STATUS_NOT_SUPPORTED;
-
-	return 0;
-}
-#endif
-
-static const struct ubus_method bss_methods[] = {
-	UBUS_METHOD_NOARG("reload", wpas_bss_reload),
-	UBUS_METHOD_NOARG("get_features", wpas_bss_get_features),
-#ifdef CONFIG_WPS
-	UBUS_METHOD_NOARG("wps_start", wpas_bss_wps_start),
-	UBUS_METHOD_NOARG("wps_cancel", wpas_bss_wps_cancel),
-#endif
-};
-
-static struct ubus_object_type bss_object_type =
-	UBUS_OBJECT_TYPE("wpas_bss", bss_methods);
-
-void wpas_ubus_add_bss(struct wpa_supplicant *wpa_s)
-{
-	struct ubus_object *obj = &wpa_s->ubus.obj;
-	char *name;
-	int ret;
-
-	if (!wpas_ubus_init())
-		return;
-
-	if (asprintf(&name, "wpa_supplicant.%s", wpa_s->ifname) < 0)
-		return;
-
-	obj->name = name;
-	obj->type = &bss_object_type;
-	obj->methods = bss_object_type.methods;
-	obj->n_methods = bss_object_type.n_methods;
-	ret = ubus_add_object(ctx, obj);
-	wpas_ubus_ref_inc();
-}
-
-void wpas_ubus_free_bss(struct wpa_supplicant *wpa_s)
-{
-	struct ubus_object *obj = &wpa_s->ubus.obj;
-	char *name = (char *) obj->name;
-
-	if (!ctx)
-		return;
-
-	if (obj->id) {
-		ubus_remove_object(ctx, obj);
-		wpas_ubus_ref_dec();
-	}
-
-	free(name);
-}
-
-enum {
-	WPAS_CONFIG_DRIVER,
-	WPAS_CONFIG_IFACE,
-	WPAS_CONFIG_BRIDGE,
-	WPAS_CONFIG_HOSTAPD_CTRL,
-	WPAS_CONFIG_CTRL,
-	WPAS_CONFIG_FILE,
-	__WPAS_CONFIG_MAX
-};
-
-static const struct blobmsg_policy wpas_config_add_policy[__WPAS_CONFIG_MAX] = {
-	[WPAS_CONFIG_DRIVER] = { "driver", BLOBMSG_TYPE_STRING },
-	[WPAS_CONFIG_IFACE] = { "iface", BLOBMSG_TYPE_STRING },
-	[WPAS_CONFIG_BRIDGE] = { "bridge", BLOBMSG_TYPE_STRING },
-	[WPAS_CONFIG_HOSTAPD_CTRL] = { "hostapd_ctrl", BLOBMSG_TYPE_STRING },
-	[WPAS_CONFIG_CTRL] = { "ctrl", BLOBMSG_TYPE_STRING },
-	[WPAS_CONFIG_FILE] = { "config", BLOBMSG_TYPE_STRING },
-};
-
-static int
-wpas_config_add(struct ubus_context *ctx, struct ubus_object *obj,
-		struct ubus_request_data *req, const char *method,
-		struct blob_attr *msg)
-{
-	struct blob_attr *tb[__WPAS_CONFIG_MAX];
-	struct wpa_global *global = get_wpa_global_from_object(obj);
-	struct wpa_interface *iface;
-
-	blobmsg_parse(wpas_config_add_policy, __WPAS_CONFIG_MAX, tb, blob_data(msg), blob_len(msg));
-
-	if (!tb[WPAS_CONFIG_FILE] || !tb[WPAS_CONFIG_IFACE] || !tb[WPAS_CONFIG_DRIVER])
-		return UBUS_STATUS_INVALID_ARGUMENT;
-
-	iface = os_zalloc(sizeof(struct wpa_interface));
-	if (iface == NULL)
-		return UBUS_STATUS_UNKNOWN_ERROR;
-
-	iface->driver = blobmsg_get_string(tb[WPAS_CONFIG_DRIVER]);
-	iface->ifname = blobmsg_get_string(tb[WPAS_CONFIG_IFACE]);
-	iface->confname = blobmsg_get_string(tb[WPAS_CONFIG_FILE]);
-
-	if (tb[WPAS_CONFIG_BRIDGE])
-		iface->bridge_ifname = blobmsg_get_string(tb[WPAS_CONFIG_BRIDGE]);
-
-	if (tb[WPAS_CONFIG_CTRL])
-		iface->ctrl_interface = blobmsg_get_string(tb[WPAS_CONFIG_CTRL]);
-
-	if (tb[WPAS_CONFIG_HOSTAPD_CTRL])
-		iface->hostapd_ctrl = blobmsg_get_string(tb[WPAS_CONFIG_HOSTAPD_CTRL]);
-
-	if (!wpa_supplicant_add_iface(global, iface, NULL))
-		return UBUS_STATUS_INVALID_ARGUMENT;
-
-	blob_buf_init(&b, 0);
-	blobmsg_add_u32(&b, "pid", getpid());
-	ubus_send_reply(ctx, req, b.head);
-
-	return UBUS_STATUS_OK;
-}
-
-enum {
-	WPAS_CONFIG_REM_IFACE,
-	__WPAS_CONFIG_REM_MAX
-};
-
-static const struct blobmsg_policy wpas_config_remove_policy[__WPAS_CONFIG_REM_MAX] = {
-	[WPAS_CONFIG_REM_IFACE] = { "iface", BLOBMSG_TYPE_STRING },
-};
-
-static int
-wpas_config_remove(struct ubus_context *ctx, struct ubus_object *obj,
-		   struct ubus_request_data *req, const char *method,
-		   struct blob_attr *msg)
-{
-	struct blob_attr *tb[__WPAS_CONFIG_REM_MAX];
-	struct wpa_global *global = get_wpa_global_from_object(obj);
-	struct wpa_supplicant *wpa_s = NULL;
-	unsigned int found = 0;
-
-	blobmsg_parse(wpas_config_remove_policy, __WPAS_CONFIG_REM_MAX, tb, blob_data(msg), blob_len(msg));
-
-	if (!tb[WPAS_CONFIG_REM_IFACE])
-		return UBUS_STATUS_INVALID_ARGUMENT;
-
-	/* find wpa_s object for to-be-removed interface */
-	for (wpa_s = global->ifaces; wpa_s; wpa_s = wpa_s->next) {
-		if (!strncmp(wpa_s->ifname,
-			     blobmsg_get_string(tb[WPAS_CONFIG_REM_IFACE]),
-			     sizeof(wpa_s->ifname)))
-		{
-			found = 1;
-			break;
-		}
-	}
-
-	if (!found)
-		return UBUS_STATUS_INVALID_ARGUMENT;
-
-	if (wpa_supplicant_remove_iface(global, wpa_s, 0))
-		return UBUS_STATUS_INVALID_ARGUMENT;
-
-	return UBUS_STATUS_OK;
-}
-
-static const struct ubus_method wpas_daemon_methods[] = {
-	UBUS_METHOD("config_add", wpas_config_add, wpas_config_add_policy),
-	UBUS_METHOD("config_remove", wpas_config_remove, wpas_config_remove_policy),
-};
-
-static struct ubus_object_type wpas_daemon_object_type =
-	UBUS_OBJECT_TYPE("wpa_supplicant", wpas_daemon_methods);
-
-void wpas_ubus_add(struct wpa_global *global)
-{
-	struct ubus_object *obj = &global->ubus_global;
-	int ret;
-
-	if (!wpas_ubus_init())
-		return;
-
-	obj->name = strdup("wpa_supplicant");
-
-	obj->type = &wpas_daemon_object_type;
-	obj->methods = wpas_daemon_object_type.methods;
-	obj->n_methods = wpas_daemon_object_type.n_methods;
-	ret = ubus_add_object(ctx, obj);
-	wpas_ubus_ref_inc();
-}
-
-void wpas_ubus_free(struct wpa_global *global)
-{
-	struct ubus_object *obj = &global->ubus_global;
-	char *name = (char *) obj->name;
-
-	if (!ctx)
-		return;
-
-	if (obj->id) {
-		ubus_remove_object(ctx, obj);
-		wpas_ubus_ref_dec();
-	}
-
-	free(name);
-}
-
-
-#ifdef CONFIG_WPS
-void wpas_ubus_notify(struct wpa_supplicant *wpa_s, const struct wps_credential *cred)
-{
-	u16 auth_type;
-	char *ifname, *encryption, *ssid, *key;
-	size_t ifname_len;
-
-	if (!cred)
-		return;
-
-	auth_type = cred->auth_type;
-
-	if (auth_type == (WPS_AUTH_WPAPSK | WPS_AUTH_WPA2PSK))
-		auth_type = WPS_AUTH_WPA2PSK;
-
-	if (auth_type != WPS_AUTH_OPEN &&
-	    auth_type != WPS_AUTH_WPAPSK &&
-	    auth_type != WPS_AUTH_WPA2PSK) {
-		wpa_printf(MSG_DEBUG, "WPS: Ignored credentials for "
-			   "unsupported authentication type 0x%x",
-			   auth_type);
-		return;
-	}
-
-	if (auth_type == WPS_AUTH_WPAPSK || auth_type == WPS_AUTH_WPA2PSK) {
-		if (cred->key_len < 8 || cred->key_len > 2 * PMK_LEN) {
-			wpa_printf(MSG_ERROR, "WPS: Reject PSK credential with "
-				   "invalid Network Key length %lu",
-				   (unsigned long) cred->key_len);
-			return;
-		}
-	}
-
-	blob_buf_init(&b, 0);
-
-	ifname_len = strlen(wpa_s->ifname);
-	ifname = blobmsg_alloc_string_buffer(&b, "ifname", ifname_len + 1);
-	memcpy(ifname, wpa_s->ifname, ifname_len + 1);
-	ifname[ifname_len] = '\0';
-	blobmsg_add_string_buffer(&b);
-
-	switch (auth_type) {
-		case WPS_AUTH_WPA2PSK:
-			encryption = "psk2";
-			break;
-		case WPS_AUTH_WPAPSK:
-			encryption = "psk";
-			break;
-		default:
-			encryption = "none";
-			break;
-	}
-
-	blobmsg_add_string(&b, "encryption", encryption);
-
-	ssid = blobmsg_alloc_string_buffer(&b, "ssid", cred->ssid_len + 1);
-	memcpy(ssid, cred->ssid, cred->ssid_len);
-	ssid[cred->ssid_len] = '\0';
-	blobmsg_add_string_buffer(&b);
-
-	if (cred->key_len > 0) {
-		key = blobmsg_alloc_string_buffer(&b, "key", cred->key_len + 1);
-		memcpy(key, cred->key, cred->key_len);
-		key[cred->key_len] = '\0';
-		blobmsg_add_string_buffer(&b);
-	}
-
-//	ubus_notify(ctx, &wpa_s->ubus.obj, "wps_credentials", b.head, -1);
-	ubus_send_event(ctx, "wps_credentials", b.head);
-}
-#endif /* CONFIG_WPS */
diff --git a/package/network/services/hostapd/src/wpa_supplicant/ubus.h b/package/network/services/hostapd/src/wpa_supplicant/ubus.h
deleted file mode 100644
index bf92b98c01..0000000000
--- a/package/network/services/hostapd/src/wpa_supplicant/ubus.h
+++ /dev/null
@@ -1,66 +0,0 @@
-/*
- * wpa_supplicant / ubus support
- * Copyright (c) 2018, Daniel Golle <daniel@makrotopia.org>
- * Copyright (c) 2013, Felix Fietkau <nbd@nbd.name>
- *
- * This software may be distributed under the terms of the BSD license.
- * See README for more details.
- */
-#ifndef __WPAS_UBUS_H
-#define __WPAS_UBUS_H
-
-struct wpa_supplicant;
-struct wpa_global;
-
-#include "wps_supplicant.h"
-
-#ifdef UBUS_SUPPORT
-#include <libubus.h>
-
-struct wpas_ubus_bss {
-	struct ubus_object obj;
-};
-
-void wpas_ubus_add_bss(struct wpa_supplicant *wpa_s);
-void wpas_ubus_free_bss(struct wpa_supplicant *wpa_s);
-
-void wpas_ubus_add(struct wpa_global *global);
-void wpas_ubus_free(struct wpa_global *global);
-
-#ifdef CONFIG_WPS
-void wpas_ubus_notify(struct wpa_supplicant *wpa_s, const struct wps_credential *cred);
-#endif
-
-#else
-struct wpas_ubus_bss {};
-
-static inline void wpas_ubus_add_iface(struct wpa_supplicant *wpa_s)
-{
-}
-
-static inline void wpas_ubus_free_iface(struct wpa_supplicant *wpa_s)
-{
-}
-
-static inline void wpas_ubus_add_bss(struct wpa_supplicant *wpa_s)
-{
-}
-
-static inline void wpas_ubus_free_bss(struct wpa_supplicant *wpa_s)
-{
-}
-
-static inline void wpas_ubus_notify(struct wpa_supplicant *wpa_s, struct wps_credential *cred)
-{
-}
-
-static inline void wpas_ubus_add(struct wpa_global *global)
-{
-}
-
-static inline void wpas_ubus_free(struct wpa_global *global)
-{
-}
-#endif
-
-#endif
-- 
2.34.1

